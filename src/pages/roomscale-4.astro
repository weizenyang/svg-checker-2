---
import ObjectList from "../components/object-list.tsx";
// import * as DECODER from "../scripts/decoder/draco_decoder.js";
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Three.js - Three Sides of a Cube</title>
    </head>
    <body id="drop-zone" class="overflow-hidden">
        <div
            class="ui-area transition-all bg-zinc-100 p-1 rounded-sm text-xs"
            id="ui-area"
        >
            <div class="flex">
                <a
                    href="/"
                    class="flex w-fit border-2 border-zinc-300 pl-2 pr-2 p-1 mb-3 transition-all duration-75 drop-shadow-sm text-center rounded-md content-center hover:bg-neutral-100 hover:drop-shadow-lg"
                >
                    <div class="align-center content-center">
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke-width="1.5"
                            stroke="currentColor"
                            class="size-5"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                d="m2.25 12 8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25"
                            ></path>
                        </svg>
                    </div>
                    <p class="ml-2 text-center">Home</p>
                </a>
                <button
                    id="clear-all-data"
                    class="flex transition-all duration-75 drop-shadow-sm bg-red-600 text-white p-2 ml-2 mb-3 rounded-md hover:drop-shadow-xl hover:bg-red-500 hover:text-white"
                >
                    Clear All Data
                </button>
            </div>

            <hr class="border-b border-zinc-200 mb-3" />
            <button
                class="bg-zinc-300 text-lime-600 font-mono p-0.5 rounded-md w-full drop-shadow-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                id="log-scene">... Log Scene ...</button
            >

            <div class="flex space-x-1 mt-3">
                <p class="font-medium">Flip:</p>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="x-flip"
                >
                    X-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="y-flip"
                >
                    Y-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="z-flip"
                >
                    Z-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="y-up"
                >
                    -Y Coords
                </button>
            </div>

            <div class="rounded-md bg-white max-w-60 p-3 mt-3 space-y-2">
                <div>
                    <label for="center-csv">Center</label>
                    <input type="checkbox" id="center-csv" name="center-csv" />
                </div>
                <div>
                    <label for="show-labels">Show Labels</label>
                    <input
                        type="checkbox"
                        id="show-labels"
                        name="show-labels"
                        checked
                    />
                </div>
                <div>
                    <label for="show-face-orientation"
                        >Show Face Orientation</label
                    >
                    <input
                        type="checkbox"
                        id="show-face-orientation"
                        name="show-face-orientation"
                        checked
                    />
                </div>
                <div>
                    <label for="scale-slider">Cone Size</label>
                    <input
                        type="range"
                        class="accent-gray-400 hover:accent-lime-600 active:accent-lime-800 transition-all duration-75"
                        id="cone-size-slider"
                        name="cone-size-slider"
                        min='0"'
                        max="50"
                        step="1"
                        value="1"
                    />
                </div>
                <div>
                    <label for="scale-slider">Scale</label>
                    <input
                        type="range"
                        class="accent-gray-400 hover:accent-lime-600 active:accent-lime-800 transition-all duration-75"
                        id="scale-slider"
                        name="scale-slider"
                        min="-5"
                        max="5"
                        step="0.1"
                        value="1"
                    />
                </div>
            </div>

            <!-- <ObjectList client:load /> -->

            <button
                id="export-all-fbx"
                class="flex transition-all duration-75 drop-shadow-sm bg-zinc-600 text-lime-100 p-2 mt-3 rounded-md hover:drop-shadow-xl hover:bg-zinc-500 hover:text-lime-400"
                style="margin-bottom: 10px"
            >
                Export All To GLB
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    class="ml-2 rotate-180"
                >
                    <path
                        d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
                        stroke-width="2"></path>
                    <polyline points="7 10 12 15 17 10" stroke-width="2"
                    ></polyline>
                    <line x1="12" x2="12" y1="15" y2="3" stroke-width="2"
                    ></line>
                </svg></button
            >

            <label style="margin-left: 10px; font-family: monospace;">
                <input type="checkbox" id="export-all-scene-checkbox" />
                Export Entire Scene
            </label>

            <div class="rounded-md bg-zinc-300 max-w-52 p-5 pl-2 pr-2 mt-3">
                <h2 class="font-bold">Floors:</h2>
                <div class="flex flex-col" id="show-floors">
                    <p>Import a Camera CSV to start</p>
                </div>
            </div>
        </div>

        <main class="fixed flex right-0 pointer-events-none">
            <div
                id="vr-image-panel"
                class="relative right-0 w-[400px] h-[200px] resize overflow-auto border border-gray-400 min-w-[150px] min-h-[150px] pointer-events-auto"
                style="resize: both;"
            >
                <img
                    id="vr-img"
                    src=""
                    style="width:100%; height:100%; object-fit: contain;"
                    alt="VR view"
                />

                <!-- bottom-left resize handle -->
                <div
                    id="vr-resize-handle"
                    class="absolute bottom-0 left-0 w-4 h-4 bg-white bg-opacity-50 rounded-tr-md"
                    style="cursor: sw-resize;"
                >
                </div>
            </div>

            <div class="flex flex-col pointer-events-auto">
                <div
                    class="right-0 max-w-2xl h-50 bg-neutral-100 text-xs"
                    id="gizmo"
                >
                    <button
                        id="camera-top"
                        class="bg-zinc-300 w-full p-5 pt-0 pb-0 rounded-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                        id="x-flip"
                    >
                        Top
                    </button>
                    <div class="flex">
                        <button
                            id="camera-left"
                            class="bg-zinc-300 p-5 pr-1 pl-1 rounded-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                            id="x-flip"
                        >
                            L
                        </button>
                        <div class="h-36 w-44" id="orthoView"></div>
                        <button
                            id="camera-right"
                            class="bg-zinc-300 p-5 pl-1 pr-1 rounded-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                            id="x-flip"
                        >
                            R
                        </button>
                    </div>

                    <button
                        id="camera-bottom"
                        class="bg-zinc-300 w-full p-5 pt-0 pb-0 rounded-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                        id="x-flip"
                    >
                        Bottom
                    </button>
                    <button id="open-align-popup"> Align Points </button>
                </div>

                <div
                    id="outliner"
                    class="pointer-events-auto mt-2 max-h-5xl overflow-y-auto bg-gray-200 pl-2 text-[10px]"
                >
                </div>
                <!-- Alignment Popup: hidden by default -->
                <div
                    id="alignment-popup"
                    class="fixed left-4 top-1/2 transform -translate-y-1/2 bg-white border border-gray-300 rounded-md shadow-lg p-4 hidden z-50"
                >
                    <div class="mb-2">
                        <h3 class="font-bold text-sm mb-1">Reference Points</h3>
                        <div
                            id="reference-dropzone"
                            class="w-40 h-20 border-2 border-dashed border-gray-400 flex flex-col items-center justify-center text-xs"
                        >
                            Drop 2 items here
                        </div>
                    </div>
                    <div class="mb-2">
                        <h3 class="font-bold text-sm mb-1">Align Points</h3>
                        <div
                            id="align-dropzone"
                            class="w-40 h-20 border-2 border-dashed border-gray-400 flex flex-col items-center justify-center text-xs"
                        >
                            Drop 2 items here
                        </div>
                    </div>
                    <button
                        id="align-button"
                        class="w-full bg-blue-500 text-white py-1 rounded-md text-xs hidden"
                    >
                        Align
                    </button>
                </div>
            </div>
        </main>

        <div class="notification-panel" id="notification-panel"></div>

        <div id="tag" class="z-[101]">
            <h3 id="label">-</h3>
        </div>
    </body>
    <div
        id="marker-label-container"
        class="overflow-hidden pointer-events-none z-[100]"
    >
    </div>
</html>

<script>
    import * as THREE from "../scripts/three";
    import { OrbitControls } from "../scripts/three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "../scripts/three/examples/jsm/loaders/GLTFLoader.js";
    import { FBXLoader } from "../scripts/three/examples/jsm/loaders/FBXLoader";
    import { GLTFExporter } from "../scripts/three/examples/jsm/exporters/GLTFExporter.js";
    import { DRACOLoader } from "../scripts/three/examples/jsm/loaders/DRACOLoader.js";
    import JSZip from "jszip";

    //Resizing image previewer

    const panel = document.getElementById("vr-image-panel");
    const handle = document.getElementById("vr-resize-handle");

    let isResizing = false;
    let startX, startY, startWidth, startHeight;

    handle.addEventListener("mousedown", function (e) {
        e.preventDefault();
        isResizing = true;

        // record starting mouse coords and panel size
        startX = e.clientX;
        startY = e.clientY;
        const rect = panel.getBoundingClientRect();
        startWidth = rect.width;
        startHeight = rect.height;

        window.addEventListener("mousemove", resizePanel);
        window.addEventListener("mouseup", stopResize);
    });

    // // 1) Spawn the worker (once, at module load)
    // const compressor = new Worker("compressor.worker.js");

    // // Map to hold pending promises
    // const pending = new Map();

    // // 2) Handle responses from Worker
    // compressor.onmessage = (e) => {
    //     const { id, buffer } = e.data;
    //     const { resolve } = pending.get(id);
    //     pending.delete(id);
    //     resolve(buffer); // hand back the raw JPEG bytes
    // };

    // // 3) Helper to offload JPEG encode
    // function encodeJPEGOffthread(canvas, quality = 0.8) {
    //     return new Promise(async (resolve, reject) => {
    //         try {
    //             // Create a small unique ID for this request
    //             const id = crypto.randomUUID();
    //             // Snapshot to an ImageBitmap (transferable)
    //             const bitmap = await createImageBitmap(canvas);
    //             // Store promise callbacks
    //             pending.set(id, { resolve, reject });
    //             // Post to worker
    //             compressor.postMessage({ id, imageBitmap: bitmap, quality }, [
    //                 bitmap,
    //             ]);
    //         } catch (err) {
    //             reject(err);
    //         }
    //     });
    // }

    function clearAllData() {
        // 1) Remove all dynamic scene children except axes & lights
        scene.children.slice().forEach((child) => {
            const t = child.type;
            if (
                t !== "AxesHelper" &&
                t !== "AmbientLight" &&
                t !== "DirectionalLight"
            ) {
                scene.remove(child);
            }
        });

        // 2) Reset your tracking arrays
        objects.length = 0;
        markers.length = 0;
        VRSpheres.length = 0;
        imageArray.length = 0;
        VRRef.length = 0;
        simplifiedNamesId.length = 0;
        csvGroups.length = 0;
        fbxFiles.length = 0;
        glbFiles.length = 0;
        globalFloors.length = 0;

        // 3) Clear HTML overlays
        document.getElementById("marker-label-container").innerHTML = "";
        document.getElementById("outliner").innerHTML = "";
        document.getElementById("alignment-popup").classList.add("hidden");

        console.log("Scene and data cleared.");
    }

    // Re-wire your button
    document
        .getElementById("clear-all-data")
        .addEventListener("click", clearAllData);

    // Wire up the button
    document
        .getElementById("clear-all-data")
        .addEventListener("click", clearAllData);

    function resizePanel(e) {
        if (!isResizing) return;

        // horizontal drag (to the left) increases width
        const deltaX = startX - e.clientX;
        let newWidth = startWidth + deltaX;
        const minW = 150;
        if (newWidth < minW) newWidth = minW;

        // enforce 2:1 ratio → height = width / 2
        let newHeight = newWidth / 2;
        const minH = minW / 2;
        if (newHeight < minH) {
            newHeight = minH;
            newWidth = newHeight * 2;
        }

        panel.style.width = `${newWidth}px`;
        panel.style.height = `${newHeight}px`;
    }

    function stopResize() {
        if (!isResizing) return;
        isResizing = false;
        window.removeEventListener("mousemove", resizePanel);
        window.removeEventListener("mouseup", stopResize);
    }

    // Initialize the GLTFLoader
    const GLTFloader = new GLTFLoader();
    const FBXloader = new FBXLoader();
    const dracoLoader = new DRACOLoader();
    // Set the path to the Draco decoder
    // dracoLoader.setDecoderConfig({ type: 'js' });
    dracoLoader.setDecoderPath("/draco/decoder/");
    dracoLoader.preload();
    GLTFloader.setDRACOLoader(dracoLoader);

    var arrowAsset;
    GLTFloader.load("/Arrow.glb", (e) => {
        // Preload Arrow asset
        console.log("Arrow asset loaded");
        arrowAsset = e;
    });

    const scene = new THREE.Scene();
    var imageArray = [];
    var VRRef = [];
    var VRSpheres = [];
    var objects = [];
    var markers = [];
    let labelContainer;
    let referenceSelection = [];
    let alignSelection = [];

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.autoClear = false;
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const orthoRenderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
    });
    orthoRenderer.autoClear = false;
    const orthoView = document.getElementById("orthoView");
    orthoRenderer.setSize(orthoView.clientWidth, orthoView.clientHeight);
    document.getElementById("orthoView").appendChild(orthoRenderer.domElement);

    //Manipulatable Group
    var m_Group;

    //Axis
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    //Lights
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    scene.add(directionalLight);

    const light = new THREE.AmbientLight(0x404040);
    scene.add(light);

    //Camera
    const camera = new THREE.PerspectiveCamera(
        110,
        window.innerWidth / window.innerHeight,
        0.1,
        800000,
    );
    camera.position.x = -210.41;
    camera.position.y = 1.31;
    camera.position.z = 0;

    const orthoCamera = new THREE.OrthographicCamera(
        orthoView.clientWidth / -2,
        orthoView.clientWidth / 2,
        orthoView.clientHeight / 2,
        orthoView.clientHeight / -2,
        0.1,
        80000,
    );
    orthoCamera.position.x = -210.41;
    orthoCamera.position.y = 1.31;
    orthoCamera.position.z = 0;
    //Mouse Raycaster Perspective
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    //Mouse Raycaster Orthographic
    const orthoRaycaster = new THREE.Raycaster();
    const orthoPointer = new THREE.Vector2();

    function onPointerMove(event) {
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    function handleFloors() {
        //Floor section
        //Dynamically add Floors section
        var floorNumbers = [];
        const labelDivInstance = document.getElementById("labelDiv");
        if (labelDivInstance) {
            labelDivInstance.remove();
        }
        globalFloors.forEach((e) => {
            // console.log("Pushing " + e.floor);
            if (!floorNumbers.includes(e.floor)) {
                floorNumbers.push(e.floor);
            }
        });

        // console.log(floorNumbers);
        // console.log(globalFloors);

        if (floorNumbers.length > 0) {
            const floorSection = document.getElementById("show-floors");
            // console.log(floorSection);
            if (floorSection.classList.contains("hidden")) {
                floorSection.classList.remove("hidden");
            }
            const listChild = floorSection.getElementsByTagName("*");
            // console.log(listChild);
            if (listChild.length > 0) {
                Array.from(listChild).forEach((element) => {
                    element.remove();
                });
            }

            const checkboxesId = [];

            floorNumbers.forEach((e) => {
                const div = document.createElement("div");
                const checkbox = document.createElement("input");
                const label = document.createElement("label");

                label.innerText = `Floor ${e}`;
                label.htmlFor = `floor-${e}-checkbox`;

                checkbox.type = "checkbox";
                checkbox.checked = true;
                checkbox.id = `floor-${e}-checkbox`;
                checkbox.setAttribute("class", "mr-1");

                checkboxesId.push(`floor-${e}-checkbox`);
                div.appendChild(checkbox);
                div.appendChild(label);
                div.setAttribute("class", "p-2 bg-zinc-100 rounded-sm mt-1");

                checkbox.addEventListener("change", (e) => {
                    // const g = globalSvgContainer.querySelector('g')
                    const selectedFloor = e.target.id.split("-")[1];
                    const selectedMarkers = globalFloors.filter(
                        (i) => i.floor == selectedFloor,
                    );

                    if (e.target.checked) {
                        selectedMarkers.forEach((e) => {
                            e.arrow.visible = true;
                        });
                    } else {
                        selectedMarkers.forEach((e) => {
                            e.arrow.visible = false;
                        });
                    }

                    createLabels();
                });

                floorSection.appendChild(div);
            });
        }
    }

    let showGeneratedView = false;

async function moveTo(event) {
    const intersects = raycaster.intersectObjects(markers);
    const hit = intersects.find(
        (i) => i.object.cameraPos && i.object.parent.visible
    );
    if (!hit) return;

    const cone = hit.object;
    const targetName = cone.name.toLowerCase();
    const panel = document.getElementById("vr-image-panel");
    const img = document.getElementById("vr-img");

    if (showGeneratedView) {
        console.log(cone)
        const renderURL = await render360SnapshotForCone(cone);
        img.src = renderURL;
        panel.classList.remove("hidden");
    } else {
        const entry = imageArray.find((e) =>
            e.name.toLowerCase().includes(targetName)
        );
        if (entry) {
            img.src = entry.image;
            panel.classList.remove("hidden");
        } else {
            panel.classList.add("hidden");
        }
    }

    showGeneratedView = !showGeneratedView;
}
    

    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(2048, {
        format: THREE.RGBAFormat,
        generateMipmaps: true,
        minFilter: THREE.LinearMipmapLinearFilter,
    });

    // CubeCamera will render into cubeRenderTarget
    const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
    scene.add(cubeCamera);

    // after you’ve created cubeRenderTarget & cubeCamera…

    // 1. Full‐screen quad geometry (2:1 aspect space)
    const quadGeo = new THREE.PlaneGeometry(2, 2);

    // 2. ShaderMaterial that maps UV→direction→cubemap
    const eqMaterial = new THREE.ShaderMaterial({
        uniforms: {
            envMap: { value: cubeRenderTarget.texture },
        },
        vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = vec4(position, 1.0);
    }
  `,
        fragmentShader: `
    #define PI 3.141592653589793
    varying vec2 vUv;
    uniform samplerCube envMap;
    void main() {
      // φ ∈ [0,2π], θ ∈ [0,π]
      float phi   = vUv.x * PI * 2.0;
      float theta = PI - (vUv.y * PI);
      vec3 dir = vec3(
        sin(theta) * cos(phi),
        cos(theta),
        sin(theta) * sin(phi)
      );
      gl_FragColor = textureCube(envMap, dir);
    }
  `,
        depthTest: false,
        depthWrite: false,
    });

    // 3. Put it in its own scene
    // 3. Build the EQ scene & camera
    const eqScene = new THREE.Scene();
    const quadMesh = new THREE.Mesh(quadGeo, eqMaterial);
    quadMesh.frustumCulled = false; // ensure it always draws
    eqScene.add(quadMesh);

    // 4. Orthographic camera that exactly covers NDC –1 to +1 in X & Y
    const eqCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    eqMaterial.needsUpdate = true;

    window.addEventListener("pointermove", onPointerMove);

    window.addEventListener("click", moveTo);

    window.addEventListener("keydown", (e) => {
        if (e.key == "ArrowLeft") {
            console.log(e.key);
            camera.rotateY(THREE.MathUtils.degToRad(5));
        } else if (e.key == "ArrowRight") {
            console.log(e.key);
            camera.rotateY(THREE.MathUtils.degToRad(-5));
        }
        if (e.key == "ArrowUp") {
            console.log(e.key);
            camera.rotateX(THREE.MathUtils.degToRad(5));
        } else if (e.key == "ArrowDown") {
            console.log(e.key);
            camera.rotateX(THREE.MathUtils.degToRad(-5));
        }
    });

    const orbitalControls = new OrbitControls(camera, renderer.domElement);
    orbitalControls.enableKeys = false;

    // const orbitalControlsOrtho = new OrbitControls(orthoCamera, orthoRenderer.domElement);
    // orbitalControlsOrtho.enabled = false;

    // Variables for keyboard control
    const keyState = {};

    // Event listeners for keydown and keyup
    window.addEventListener("keydown", (event) => {
        keyState[event.key.toLowerCase()] = true;
    });

    window.addEventListener("keyup", (event) => {
        keyState[event.key.toLowerCase()] = false;
    });

    // Adjust these speeds to control rotation and movement
    const rotationSpeed = 0.02;
    const movementSpeed = 0.5;

    function animate() {
        // Update raycaster for object intersections
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children);

        orthoRaycaster.setFromCamera(orthoPointer, orthoCamera);
        const orthoIntersects = orthoRaycaster.intersectObjects(scene.children);
        var label = document.getElementById("label");
        label.innerHTML = "";

        // Default Tag State
        document.getElementById("tag").style.display = "none";
        if (intersects.length > 0 && orthoIntersects.length > 0) {
            document.getElementById("tag").style.display = "flex";
            document.getElementById("tag").style.flexDirection = "column";

            var idLabel = document.createElement("p");
            var detailLabel = document.createElement("p");
            let positionObjects = intersects.filter(
                (item) => item.object.cameraPos && item.object.parent.visible,
            );

            let orthoPositionObjects = orthoIntersects.filter(
                (item) => item.object.cameraPos && item.object.parent.visible,
            );

            // positionObjects = orthoPositionObjects

            if (positionObjects.length > 0) {
                idLabel.innerText = `ID: ${positionObjects[0].object.name}`;
                idLabel.style.color = "#007700";
                idLabel.style.lineHeight = "1em";
                label.append(idLabel);

                idLabel.innerText += ` \nPos: ${positionObjects[0].object.position.x} ${positionObjects[0].object.position.y} ${positionObjects[0].object.position.z}`;
                idLabel.innerText += ` \nRot: ${THREE.MathUtils.radToDeg(positionObjects[0].object.rotation.x).toFixed(4)} ${THREE.MathUtils.radToDeg(positionObjects[0].object.rotation.z).toFixed(4)} ${THREE.MathUtils.radToDeg(positionObjects[0].object.rotation.y).toFixed(4)}`;
                detailLabel.style.color = "#007700";
                label.append(detailLabel);
            }
        }

        // Update camera position/rotation based on keyboard input
        if (keyState["arrowup"] || keyState["w"]) {
            camera.position.z -= movementSpeed;
        }
        if (keyState["arrowdown"] || keyState["s"]) {
            camera.position.z += movementSpeed;
        }
        if (keyState["arrowleft"] || keyState["a"]) {
            camera.rotation.y += rotationSpeed;
        }
        if (keyState["arrowright"] || keyState["d"]) {
            camera.rotation.y -= rotationSpeed;
        }

        // Ensure camera target is updated correctly after manual rotation
        orbitalControls.update();
        orthoCamera.position.copy(camera.position);
        orthoCamera.rotation.copy(camera.rotation);
        orthoCamera.zoom = 100 / orbitalControls.getDistance();
        orthoCamera.updateProjectionMatrix();
        // orthoCamera.left = (orthoView.clientWidth / -2) * orbitalControls.getDistance()
        // orthoCamera.right = (orthoView.clientWidth / 2) * orbitalControls.getDistance()
        // orthoCamera.top = (orthoView.clientHeight / 2) * orbitalControls.getDistance()
        // orthoCamera.bottom = (orthoView.clientHeight / -2) * orbitalControls.getDistance()

        requestAnimationFrame(animate);

        // Render loop
        renderer.clear();
        VRSpheres.forEach((e) => {
            renderer.render(e, camera);
        });
        renderer.clearDepth();
        renderer.render(scene, camera);

        objects.forEach((e) => {
            renderer.clearDepth();
            renderer.render(e, camera);
        });

        markers.forEach((e) => {
            renderer.clearDepth();
            renderer.render(e, camera);
        });

        updateLabelPositions();

        // Render loop for orthographic camera
        orthoRenderer.clear();
        VRSpheres.forEach((e) => {
            orthoRenderer.render(e, orthoCamera);
        });
        orthoRenderer.clearDepth();
        orthoRenderer.render(scene, orthoCamera);

        objects.forEach((e) => {
            orthoRenderer.clearDepth();
            orthoRenderer.render(e, orthoCamera);
        });

        markers.forEach((e) => {
            orthoRenderer.clearDepth();
            orthoRenderer.render(e, orthoCamera);
        });

        // console.log(orbitalControls.getDistance())

        // console.log(camera.position)
        // console.log(camera.rotation)
    }

    animate();

    //Tag
    document.addEventListener("mousemove", (e) => {
        document.getElementById("tag").style.left = `${e.x}px`;
        document.getElementById("tag").style.top = `${e.y}px`;
        document.getElementById("tag").style.transform = `translate(${
            (e.clientX / window.innerWidth) * -100
        }%, ${(e.clientY / window.innerHeight) * -150}%)`;
    });

    const fbxFiles = [];
    const glbFiles = [];
    const csvGroups = [];
    const simplifiedNamesId = [];
    const images = [];
    let globalFloors = [];
    let originalWireframeMeshes = []

    async function fetchDataFromServer() {
        try {
            // // Fetch the image data
            // const modelResponse = await fetch("http://localhost:9234/model");
            // if (!modelResponse.ok) throw new Error("Failed to fetch model");
            // const modelArray = await modelResponse.json();

            // console.log(modelArray)

            // modelArray.forEach((e) => {
            //     console.log(e)
            //     // Convert the model buffer to a Blob
            //     const modelBlob = new Blob(e.model.data, {
            //         type: "model/gltf-binary",
            //     }); // Update type if necessary
            //     const modelFile = new File([modelBlob], e.modelName, {
            //         type: "model/gltf-binary",
            //     });
            //     // Pass the model File object to handleFileChange
            //     handleFileChange(modelFile, [modelFile]);
            // })
            // Fetch the manifest of models
            // Fetch the manifest of models
            let fileName;
            try {
                const modelResponse = await fetch(
                    "http://localhost:9234/model",
                );
                if (!modelResponse.ok) throw new Error("Failed to fetch model");

                const { models } = await modelResponse.json();

                for (const fileObj of models) {
                    // Decode the base64 string into binary
                    const binaryStr = atob(fileObj.data);
                    const len = binaryStr.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryStr.charCodeAt(i);
                    }

                    // Create a File object from the binary data
                    const blob = new Blob([bytes], {
                        type: "model/gltf-binary",
                    });
                    const glbFile = new File([blob], fileObj.modelName, {
                        type: "model/gltf-binary",
                    });
                    fileName = fileObj.modelName;

                    // Now pass the File object to handleFileChange
                    handleFileChange(glbFile, [glbFile]);
                }
            } catch (error) {
                console.error("Error fetching model data from server:", error);
            }

            try {
                const modelResponse = await fetch(
                    "http://localhost:9234/model",
                    {
                        method: "PUT",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ modelName: fileName }),
                    },
                );

                if (!modelResponse.ok) throw new Error("Failed to fetch model");

                const { models } = await modelResponse.json();

                for (const fileObj of models) {
                    // Decode the base64 string into binary
                    const binaryStr = atob(fileObj.data);
                    const len = binaryStr.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryStr.charCodeAt(i);
                    }

                    // Create a File object from the binary data
                    const blob = new Blob([bytes], {
                        type: "model/gltf-binary",
                    });
                    const glbFile = new File([blob], fileObj.modelName, {
                        type: "model/gltf-binary",
                    });

                    // Now pass the File object to handleFileChange
                    handleFileChange(glbFile, [glbFile]);
                }
            } catch (error) {
                console.error("Error fetching model data from server:", error);
            }
        } catch (error) {
            console.error("Error fetching model data from server:", error);
        }

        try {
            // Fetch the CSV data
            const csvResponse = await fetch("http://localhost:9234/camera-csv");
            if (!csvResponse.ok) throw new Error("Failed to fetch CSV");
            const { csv, csvName } = await csvResponse.json();
            console.log({ csv, csvName });

            // Convert the CSV buffer to a Blob
            const csvBlob = new Blob([new Uint8Array(csv.data)], {
                type: "text/csv",
            });
            const csvFile = new File([csvBlob], csvName, { type: "text/csv" });

            // Pass the CSV File object to handleFileChange
            handleFileChange(csvFile, [csvFile]);
        } catch (error) {
            console.error("Error fetching CSV data from server:", error);
        }
    }

    fetchDataFromServer();

    //File Drop
    function handleDrop(event) {
        event.preventDefault();
        const items = event.dataTransfer.items;
        const files = event.dataTransfer.files;
        console.log(event.dataTransfer);

        handleFileChange(items, files);
    }

    async function handleFileChange(items, files) {
        console.log("Dropped files:", files);
        const fileArray = Array.from(files);

        for (let i = 0; i < fileArray.length; i++) {
            const file = fileArray[i];
            const lower = file.name.toLowerCase();
            console.log("Processing:", file.name);

            // ----- Directory? -----
            const item = items[i];
            if (item && item.webkitGetAsEntry) {
                const entry = item.webkitGetAsEntry();
                if (entry && entry.isDirectory) {
                    // recurse through folders
                    await enumerateDirectoryWithManyFiles(entry);
                    continue;
                }
            }

            // ----- CSV -----
            if (file.type === "text/csv" || lower.endsWith(".csv")) {
                globalFloors = [];
                const text = await file.text();
                processCSVData(text, file.name);
                continue;
            }

            // ----- GLB / GLTF -----
            if (file.type === "model/gltf-binary" || lower.endsWith(".glb")) {
                const arrayBuffer = await file.arrayBuffer();

                // read the JSON chunk to detect Draco
                try {
                    const dv = new DataView(arrayBuffer);
                    const decoder = new TextDecoder("utf-8");
                    const jsonLen = dv.getUint32(12, true);
                    const jsonChunk = new Uint8Array(arrayBuffer, 20, jsonLen);
                    const jsonText = decoder.decode(jsonChunk);
                    const json = JSON.parse(jsonText);
                    console.log(
                        "GLB uses DRACO?",
                        json.extensionsUsed?.includes(
                            "KHR_draco_mesh_compression",
                        ),
                    );
                } catch (e) {
                    console.warn("Failed to inspect GLB JSON chunk:", e);
                }

                GLTFloader.parse(
                    arrayBuffer,
                    "",
                    (gltf) => {
                        applyLitMaterialToGLTF(gltf.scene);
                        gltf.scene.name = file.name;
                        gltf.scene.scale.set(100, 100, 100);
                        objects.push(gltf.scene);
                        simplifiedNamesId.push({
                            uuid: gltf.scene.uuid,
                            simplifiedName: file.name.replace(/\D/g, ""),
                        });
                        scene.add(gltf.scene);
                        updateOutliner();
                    },
                    (err) => console.error("GLB load error:", err),
                );
                continue;
            }

            // ----- FBX -----
            if (lower.endsWith(".fbx")) {
                const arrayBuffer = await file.arrayBuffer();
                // turn into a Blob URL for FBXLoader
                const blob = new Blob([arrayBuffer]);
                const url = URL.createObjectURL(blob);

                const loader = new FBXLoader();
                loader.load(
                    url,
                    (fbx) => {
                        applyLitMaterialToGLTF(fbx);
                        fbx.name = file.name;
                        fbx.scale.set(0.1, 0.1, 0.1);
                        objects.push(fbx);
                        simplifiedNamesId.push({
                            uuid: fbx.uuid,
                            simplifiedName: file.name.replace(/\D/g, ""),
                        });
                        scene.add(fbx);
                        updateOutliner();
                        URL.revokeObjectURL(url);
                    },
                    undefined,
                    (err) => console.error("FBX load error:", err),
                );
                continue;
            }

            // ----- JPG / Other Images -----
            if (file.type.startsWith("image/") && (lower.endsWith(".jpg") || lower.endsWith(".png"))) {
                const dataURL = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
                imageArray.push({ name: file.name, image: dataURL });
                continue;
            }

            console.warn("Unsupported file type:", file.name);
        }
    }

    function applyLitMaterialToGLTF(gltfScene) {
        const material = new THREE.MeshStandardMaterial({
            color: 0x00ff00, // Set your desired color
            wireframe: true, // Default to wireframe off
        });

        gltfScene.traverse((child) => {
            if (child.isMesh) {
                child.material = material;
                child.material.wireframe = true; // Ensure wireframe is initially false
                originalWireframeMeshes.push(child);
            }
        });
    }

    async function enumerateDirectoryWithManyFiles(directoryEntry) {
        //Workaround because readEntries only reads 100 files
        let reader = directoryEntry.createReader();
        let resultEntries = [];

        let read = async function () {
            let entries = await traverseDirectoryAsync(reader);
            if (entries.length > 0) {
                resultEntries = resultEntries.concat(entries);
                await read();
            }
        };

        await read();
        return resultEntries;
    }

    function getGrandparent(entry) {
        return new Promise((resolve, reject) => {
            entry.getParent(
                (parent) => {
                    parent.getParent(
                        (grandparent) => {
                            resolve(grandparent.name);
                        },
                        (error) => {
                            reject(error);
                        },
                    );
                },
                (error) => {
                    reject(error);
                },
            );
        });
    }
    //Traverse File Tree Workaround because readEntries only reads 100 files
    function traverseDirectoryAsync(reader) {
        return new Promise((resolve, reject) => {
            reader.readEntries(
                (entries) => {
                    var objectCount = 0;

                    entries.forEach((entry) => {
                        if (entry.isFile && entry.name.endsWith(".fbx")) {
                            entry.file((file) => {
                                objectCount++;
                                const tempCount = objectCount;
                                const reader = new FileReader();
                                reader.readAsArrayBuffer(file);
                                reader.onload = (event) => {
                                    const arrayBuffer = event.target.result;
                                    const loader = new FBXLoader();
                                    const item = loader.parse(arrayBuffer, "");
                                    var currentObject;
                                    getGrandparent(entry)
                                        .then((grandparentName) => {
                                            item.unitName = grandparentName;
                                            item.name = entry.name;
                                            currentObject = {
                                                fileName: entry.name,
                                                unitName: grandparentName,
                                            };
                                            const csvObject = csvGroups.find(
                                                (x) =>
                                                    x.userData
                                                        .simplifiedName ===
                                                    grandParent,
                                            );
                                            var newObject = {
                                                uuid: item.uuid,
                                                simplifiedName: grandparentName,
                                                csvObject: csvObject
                                                    ? csvObject
                                                    : "",
                                            };
                                            simplifiedNamesId.push(newObject);
                                            fbxFiles.push(currentObject);

                                            const fileUploadEvent =
                                                new CustomEvent("file-upload", {
                                                    detail: currentObject,
                                                });
                                            window.dispatchEvent(
                                                fileUploadEvent,
                                            );
                                        })
                                        .catch((error) =>
                                            console.error(
                                                "Error fetching grandparent:",
                                                error,
                                            ),
                                        );

                                    scene.add(item);
                                };
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".glb")
                        ) {
                            glbFiles.push(entry);
                            entry.file((file) => {
                                objectCount++;
                                const tempCount = objectCount;
                                const reader = new FileReader();
                                reader.readAsArrayBuffer(file);
                                reader.onload = (event) => {
                                    const arrayBuffer = event.target.result;
                                    const loader = new GLTFLoader();
                                    const item = loader.parse(arrayBuffer, "");
                                    item.name = entry.name;
                                    simplifiedNamesId.push({
                                        uuid: item.uuid,
                                        simplifiedName: entry.name.replace(
                                            /\D/g,
                                            "",
                                        ),
                                    });
                                    console.log("item name" + item.name);
                                    glbFiles.push(item.name);
                                    scene.add(item);
                                };
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".csv")
                        ) {
                            entry.file((file) => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    processCSVData(e.target.result, file.name);
                                };
                                reader.readAsText(file);
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".jpg")
                        ) {
                            entry.file((file) => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    processVRImage(e.target.result, file.name);
                                };
                                reader.readAsDataURL(file);
                            });
                        } else if (entry.isDirectory) {
                            const subReader = entry.createReader();
                            traverseDirectoryAsync(subReader); // Recursive call
                        }
                    });
                    resolve(entries);
                },
                (error) => reject(error),
            );
        });
    }

    // Function to export a Three.js object to a GLB file
    function exportToGLB(object, filename) {
        const exporter = new GLTFExporter();
        exporter.parse(
            object,
            (result) => {
                let blob;
                if (result instanceof ArrayBuffer) {
                    blob = new Blob([result], {
                        type: "application/octet-stream",
                    });
                } else if (typeof result === "object") {
                    blob = new Blob([JSON.stringify(result)], {
                        type: "application/json",
                    });
                } else {
                    console.error("Unexpected result type:", result);
                    return;
                }

                saveBlob(blob, filename);
            },
            (error) => {
                console.error("An error occurred during the GLB export", error);
            },
            { binary: true }, // Options object with binary set to true
        );
    }

    // Function to save the Blob as a file
    function saveBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.style.display = "none";
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();

        // Clean up
        setTimeout(() => {
            URL.revokeObjectURL(url);
            document.body.removeChild(link);
        }, 100);
    }

    // Function to export all FBX files in fbxFiles array
    function exportAllFBXFilesToGLB() {
        const exportEntireScene = document.getElementById(
            "export-all-scene-checkbox",
        ).checked;
        if (exportEntireScene) {
            // Export the entire scene
            exportToGLB(scene, "scene.glb");
        } else {
            // Export only the FBX models
            fbxFiles.forEach((fbxFile) => {
                const object = scene.getObjectByName(fbxFile.fileName);
                if (object) {
                    const filename = `${fbxFile.fileName.split(".")[0]}.glb`;
                    exportToGLB(object, filename);
                }
            });
        }
    }

    // Add an event listener to the export button
    const exportButton = document.getElementById("export-all-fbx");
    exportButton.addEventListener("click", exportAllFBXFilesToGLB);

    const logScene = document.getElementById("log-scene");
    logScene.addEventListener("click", (e) => {
        console.log(scene);
    });
    const dropZone = document.getElementById("drop-zone");
    dropZone.addEventListener("drop", handleDrop);
    document.body.addEventListener("dragover", (e) => {
        event.preventDefault();
    });

    function createCone(name, position, rotation) {
        const geometry = new THREE.ConeGeometry(20, 40, 32); // Cone with radius 0.5 and height 1
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color, change as needed
        const cone = new THREE.Mesh(geometry, material);
        const dir = new THREE.Vector3(Math.sin(THREE.MathUtils.degToRad(rotation.z)), 0, Math.cos(THREE.MathUtils.degToRad(rotation.z)));
        //normalize the direction vector (convert to vector of length 1)
        dir.normalize();

        // const origin = new THREE.Vector3( position.x, position.y, position.z);
        // const length = 15;
        // const hex = 0xff0000;
        // const arrow = new THREE.ArrowHelper( dir, origin, length, hex, 5, 8);
        // arrow.scale.set(3,3,3)

        // Set position
        cone.position.set(0, 0, 0);

        // Set rotation using Euler angles, converting degrees to radians
        cone.rotation.set(
            THREE.MathUtils.degToRad(0),
            THREE.MathUtils.degToRad(90),
            THREE.MathUtils.degToRad(90),
        );
        cone.updateMatrix();
        cone.geometry.applyMatrix4(cone.matrix); //to bake rotation to cone
        cone.position.set(position.x, position.y, position.z);
        cone.rotation.set(0, THREE.MathUtils.degToRad(rotation.z), 0);
        cone.scale.set(1, 1, 1);
        cone.updateMatrix();
        console.log(cone.rotation);
        cone.renderOrder = 0;
        cone.name = name;
        markers.push(cone);
        return cone;
    }
    var showMarkerNames = false;

    // function createCone(name, position, rotation) {
    //     const loader = new GLTFLoader();
    //     const camera = loader.load("./camera.glb", (e) => {
    //         const model = e.scene

    //         model.position.set(position.x, position.y, position.z)
    //         model.renderOrder = 0;
    //         model.name = name;
    //     })
    //     return camera
    // }

    // Create a label div for each marker
    function createLabels() {
        document.getElementById("marker-label-container").innerHTML = "";
        var copiedMarkers;
        copiedMarkers = markers.filter((e) => e.visible);
        copiedMarkers.forEach((marker) => {
            const labelDiv = document.createElement("div");
            labelDiv.style.backgroundColor = "#444444";
            labelDiv.style.padding = "2px 5px";
            labelDiv.style.borderRadius = "6px";
            labelDiv.className = "marker-label";
            labelDiv.innerText = marker.name;

            // Style the label
            labelDiv.style.position = "absolute";
            labelDiv.style.color = "white";
            labelDiv.style.fontSize = "10px";

            document
                .getElementById("marker-label-container")
                .appendChild(labelDiv);
            marker.userData.label = labelDiv; // Store the label in userData
        });
    }

    // Function to update label positions on the screen
    function updateLabelPositions() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const widthHalf = width / 2;
        const heightHalf = height / 2;

        const distances = markers.map((marker) =>
            camera.position.distanceTo(marker.position),
        );
        const minDistance = Math.min(...distances);
        const maxDistance = Math.max(...distances);
        const distanceRange = maxDistance - minDistance || 1;

        // Sort markers by distance from the camera (closest markers first)
        const sortedMarkers = markers
            .sort((a, b) => {
                const distanceA = camera.position.distanceTo(a.position);
                const distanceB = camera.position.distanceTo(b.position);
                return distanceA - distanceB;
            })
            .filter((e) => e.visible);

        sortedMarkers.map((marker, i) => {
            // console.log(marker)
            const labelDiv = marker.userData.label;
            if (!labelDiv) return;

            // Get the 3D position of the marker and project it to 2D
            const vector = new THREE.Vector3();
            vector.setFromMatrixPosition(marker.matrixWorld).project(camera);

            // Convert to 2D screen space
            const x = vector.x * widthHalf + widthHalf;
            const y = -(vector.y * heightHalf) + heightHalf;

            // Update label position and visibility based on camera view
            labelDiv.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            labelDiv.style.display =
                vector.z > -1 && vector.z < 1 ? "block" : "none";

            // Calculate distance and adjust opacity based on the relative distance
            const distance = camera.position.distanceTo(marker.position);
            const normalizedDistance =
                (distance - minDistance + 1) / distanceRange;
            const minOpacity = 0.2;
            labelDiv.style.opacity =
                minOpacity +
                (1 - minOpacity) *
                    (1 - normalizedDistance) ** (maxDistance / minDistance);
            labelDiv.style.zIndex = 1000 - Math.floor(distance); // Higher z-index for closer markers
        });
    }

    function createCSVFromSphereGroups(csvGroups) {
        let csvContent = ""; // CSV header

        csvGroups.forEach((group) => {
            group.children.forEach((child) => {
                if (child instanceof THREE.Mesh) {
                    // Ensure child is a mesh (sphere)
                    const name = child.name;
                    const worldPosition = new THREE.Vector3();
                    const worldQuaternion = new THREE.Quaternion();
                    const worldEuler = new THREE.Euler();
                    const position = child.getWorldPosition(worldPosition);
                    const rotation = child.getWorldQuaternion(worldQuaternion);
                    worldEuler.setFromQuaternion(worldQuaternion);

                    csvContent += `${name},${worldPosition.x},${-worldPosition.y},${worldPosition.z},${worldEuler.x},${worldEuler.y},${worldEuler.z}\n`;
                }
            });

            // Create a downloadable CSV file
            const blob = new Blob([csvContent], { type: "text/csv" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${group.name.split(".")[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
    }

    //Calculate center of all CSV points
    function calculateGroupCenter(group) {
        const positions = group.children.map((child) => child.position);
        const totalPositions = positions.length;

        if (totalPositions === 0) return null;

        const sum = positions.reduce(
            (acc, pos) => {
                acc.x += pos.x;
                acc.y += pos.y;
                acc.z += pos.z;
                return acc;
            },
            { x: 0, y: 0, z: 0 },
        );

        return {
            x: sum.x / totalPositions,
            y: sum.y / totalPositions,
            z: sum.z / totalPositions,
        };
    }

    function translateGroupToOrigin(group) {
        const center = calculateGroupCenter(group);
        group.initPosition = new THREE.Vector3(-center.x, -center.y, -center.z);
        if (!center) return;

        group.position.set(-center.x, -center.y, -center.z);
    }

    function alert(type, message) {
        var el = document.createElement("div");
        el.style.background = "#ffffff88";
        el.style.padding = "20px";
        el.style.borderRadius = "15px";
        el.classList.add("notification");
        var text = document.createElement("p");
        if (type == "error") {
            el.classList.add("alert-error");
        } else if (type == "notify") {
            el.classList.add("alert-notify");
        }
        text.innerText = message;
        text.style.margin = "0px";
        el.appendChild(text);

        document.getElementById("notification-panel").appendChild(el);

        setTimeout((e) => {
            el.remove();
        }, 2000);
    }

    // Function to scale each point relative to the center point of the group
    function scaleGroupRelativeToCenter(group, scaleFactor) {
        m_Group.scale.set(scaleFactor, scaleFactor, scaleFactor);
        if (!m_Group.initPosition) {
            m_Group.initPosition = new THREE.Vector3(
                m_Group.position.x,
                m_Group.position.y,
                m_Group.position.z,
            );
        }
        m_Group.position.set(
            m_Group.initPosition.x * scaleFactor,
            m_Group.initPosition.y * 1,
            m_Group.initPosition.z * scaleFactor,
        );
        var center = group.position;
        group.children.forEach((child) => {
            child.scale.set(1 / scaleFactor, 1 / scaleFactor, 1 / scaleFactor);
        });
    }

    function convertFBXtoGLB(position, rotation) {
        // Assuming FBX is Y-up and GLB is Z-up
        // Convert position
        const convertedPosition = {
            x: position.x,
            y: position.z,
            z: -position.y,
        };

        // Convert rotation (assuming Euler angles)
        const convertedRotation = {
            x: rotation.x,
            y: rotation.z,
            z: -rotation.y,
        };

        return { position: convertedPosition, rotation: convertedRotation };
    }

    // Function to process CSV data and create spheres
    function processCSVData(csvText, name?) {
        const lines = csvText.split("\n"); // Split CSV text into lines
        // Skip the first line if it contains headers, and process the rest

        const group = new THREE.Group();

        for (let i = 0; i < lines.length; i++) {
            const row = lines[i].split(",");
            if (row.length >= 7) {
                const name = row[0];
                const position = {
                    x: parseFloat(row[1]),
                    y: parseFloat(row[3]),
                    z: -parseFloat(row[2]),
                };
                const rotation = {
                    x: parseFloat(row[4]),
                    y: parseFloat(row[5]),
                    z: parseFloat(row[6]),
                };
                const floor = name.includes("_") ? name.split("_")[0] : name; //Get Floor Number
                const arrow = createCone(name, position, rotation);
                arrow.cameraPos = true;
                arrow.floor = floor;

                globalFloors.push({ floor: floor, arrow: arrow }); //Push obj to globalFloors

                group.add(arrow);
                // console.log(arrow);
            }

            if (name) {
                group.name = name;
                group.userData.simplifiedName = name.replace(/\D/g, "");
            }
            scene.add(group);
            m_Group = group;
        }
        createLabels();
        csvGroups.push(group);
        handleFloors();

        //Update main object references
        if (simplifiedNamesId.length > 0) {
            simplifiedNamesId.forEach((e) => {
                if (e.simplifiedName == name.replace(/\D/g, "")) {
                    e.csvObject = group.uuid;
                } else {
                    group.remove();
                }
            });
        }
        const csvUploadEvent = new CustomEvent("file-upload-csv", {
            detail: {
                simplifiedName: group.userData.simplifiedName,
                name: group.name,
            },
        });
        window.dispatchEvent(csvUploadEvent);
        updateOutliner();
    }

    function processVRImage(data, name?) {
        const thisImage = { name: name, image: data };
        imageArray.push(thisImage);
    }

    document.getElementById("ui-area").addEventListener("click", (e) => {
        if (!m_Group) {
            alert(
                "error",
                "Please Import some CSV files to use these features",
            );
        }
    });

    document.getElementById("x-flip").addEventListener("click", (e) => {
        m_Group.rotateOnWorldAxis(
            new THREE.Vector3(1, 0, 0),
            THREE.MathUtils.degToRad(180),
        );
    });

    document.getElementById("y-flip").addEventListener("click", (e) => {
        m_Group.rotateOnWorldAxis(
            new THREE.Vector3(0, 1, 0),
            THREE.MathUtils.degToRad(180),
        );
    });

    document.getElementById("z-flip").addEventListener("click", (e) => {
        m_Group.rotateOnWorldAxis(
            new THREE.Vector3(0, 0, 1),
            THREE.MathUtils.degToRad(180),
        );
    });

    document.getElementById("y-up").addEventListener("click", (e) => {
        m_Group.children.forEach((e) => {
            const initYPos = e.position.y;
            e.position.y = -initYPos;
        });
    });

    document.getElementById("center-csv").addEventListener("change", (e) => {
        if (e.target.checked) {
            calculateGroupCenter(m_Group);
            translateGroupToOrigin(m_Group);
            alert("notify", "csv-centered");
        } else {
            m_Group.position.set(0, 0, 0);
            alert("notify", "csv-centered");
        }
    });

    document.getElementById("show-labels").addEventListener("change", (e) => {
        createLabels();
        if (e.target.checked) {
            document.getElementById("marker-label-container").style.display =
                "block";
        } else {
            document.getElementById("marker-label-container").style.display =
                "none";
        }
    });

    document
        .getElementById("show-face-orientation")
        .addEventListener("change", (e) => {
            if (e.target.checked) {
                console.log(glbFiles);
                console.log(markers);
                scene.traverse(function (child) {
                    console.log(child.name);
                    if (
                        child.isMesh &&
                        !(child.userData && child.userData.label) &&
                        !child.name.toLowerCase().includes("sphere")
                    ) {
                        child.material = new THREE.ShaderMaterial({
                            vertexShader: `
                                varying vec3 vNormal;
                                void main() {
                                    vNormal = normalize(normalMatrix * normal);
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }`,
                            fragmentShader: `
                                varying vec3 vNormal;
                                void main() {
                                    float facingRatio = dot(vNormal, vec3(0.0, 0.0, 1.0));
                                    float blueIntensity = 0.5 + 0.5 * facingRatio; // Blue becomes more intense as the normal faces the viewer
                                    float redIntensity = 0.5 - 0.5 * facingRatio; // Red becomes more intense as the normal faces away
                                    gl_FragColor = vec4(redIntensity, 0.0, blueIntensity, 0.5); // Semi-transparent
                                }`,
                            side: THREE.FrontSide,
                            transparent: true,
                        });
                    }
                });
            } else {
                scene.traverse((child) => {
                    if (
                        child.isMesh &&
                        !(child.userData && child.userData.label) &&
                        !child.name.toLowerCase().includes("sphere")
                    ) {
                        child.material = material;
                        child.material.wireframe = true; // Ensure wireframe is initially false
                        originalWireframeMeshes.push(child);
                    }
                });
            }
        });

    // Updated buildTree with collapsible parents, auto-collapse for >6 children, and dblclick to toggle visibility
    function buildTree(object) {
        // Create <li> for this node
        const li = document.createElement("li");
        li.className =
            "my-[3px] text-2xs hover:bg-gray-300 cursor-pointer flex flex-col";

        // Container holds toggle (if any), name, and color picker
        const container = document.createElement("div");
        container.className = "flex items-center gap-2";

        // Initialize enabled state if not already
        if (object.userData.isEnabled === undefined) {
            object.userData.isEnabled = true;
        }

        // Double-click to toggle this object and its children
        container.addEventListener("dblclick", (e) => {
            e.stopPropagation();
            const newState = !object.userData.isEnabled;
            toggleVisibility(object, newState);
            styleSubtree(li, newState);
            // Clear or refresh HTML labels overlay when CSV cones visibility changes
            if (typeof createLabels === "function") {
                createLabels();
            }
        });

        // Create toggle button for nodes with children
        const hasChildren = object.children && object.children.length > 0;
        let toggle;
        if (hasChildren) {
            toggle = document.createElement("button");
            // Start collapsed if >6 children, otherwise expanded
            const startCollapsed = object.children.length > 6;
            toggle.textContent = startCollapsed ? "+" : "\u2212";
            toggle.className =
                "toggle-btn w-4 h-4 p-0 m-0 border-none bg-transparent";
            toggle.style.cursor = "pointer";
            container.appendChild(toggle);
        }

        // Name label
        const nameSpan = document.createElement("span");
        nameSpan.textContent = object.name || object.type || "Unnamed";
        container.appendChild(nameSpan);

        // Color picker
        const colorPicker = document.createElement("input");
        colorPicker.type = "color";
        colorPicker.style.cursor = "pointer";
        colorPicker.value = "#ff0000";
        colorPicker.className = "w-6 h-6 p-0 m-0 border-none";
        object.userData.colorPicker = colorPicker;
        colorPicker.addEventListener("input", (e) => {
            e.stopPropagation();
            updateObjectColor(object, e.target.value);
        });
        container.appendChild(colorPicker);

        li.appendChild(container);

        // Build children list
        if (hasChildren) {
            const ul = document.createElement("ul");
            ul.className = "ml-4 list-disc";
            // Auto-collapse large lists
            const isCollapsed = object.children.length > 6;
            ul.style.display = isCollapsed ? "none" : "block";

            // Recursively add children
            object.children.forEach((child) => {
                const childLi = buildTree(child);
                ul.appendChild(childLi);
            });
            li.appendChild(ul);

            // Toggle expand/collapse
            toggle.addEventListener("click", (e) => {
                e.stopPropagation();
                const hidden = ul.style.display === "none";
                ul.style.display = hidden ? "block" : "none";
                toggle.textContent = hidden ? "\u2212" : "+";
            });
        } else {
            // Leaf: make draggable
            container.draggable = true;
            container.addEventListener("dragstart", (e) => {
                e.stopPropagation();
                e.dataTransfer.setData("text/plain", object.id);
            });
        }

        // Context menu on CSV files: export 360 for the whole group
        if (object.name.toLowerCase().endsWith(".csv")) {
            container.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                if (
                    confirm(`Export all 360° images for group ${object.name}?`)
                ) {
                    // Determine group key
                    const key = getGroupId(object.name);
                    // Hide everything
                    scene.children.forEach((o) => (o.visible = false));
                    // Show only objects in this group (matching key)
                    scene.children.forEach((o) => {
                        const k = getGroupId(o.name || "");
                        if (k === key) o.visible = true;
                    });
                    // Also show cones under the CSV group
                    const csvGroup = scene.getObjectByName(object.name);
                    if (csvGroup) csvGroup.visible = true;
                    // Trigger 360 export
                    exportAll360ForGroup(object);
                }
            });
        }

        // Apply initial disabled style if needed
        styleSubtree(li, object.userData.isEnabled);
        li.setAttribute("data-object-id", object.id);
        return li;
    }

    // helper to save the current renderer canvas as a PNG
    function saveDebugImage(label) {
        const link = document.createElement("a");
        link.href = renderer.domElement.toDataURL("image/png");
        link.download = `${label}.png`;
        link.click();
    }

async function render360SnapshotForCone(cone, allCones = markers) {
    // 1) backup renderer state
    const origSize       = renderer.getSize(new THREE.Vector2());
    const origDPR        = renderer.getPixelRatio();
    const origClearColor = renderer.getClearColor(new THREE.Color()).getHex();
    const origClearAlpha = renderer.getClearAlpha();
    const origAutoClear  = renderer.autoClear;



    // 2) add a light at every cone in the group
    const lights = markers.map((mark) => {
        const light = new THREE.PointLight(0xffffff, 20, 0, 0.8);
        light.position.copy(mark.position);
        scene.add(light);
        return light;
    });

    // Hide everything but the cones
    // scene.children.forEach(o => o.visible = false);
    // markers.forEach(m => {
    //   m.visible = true;
    //   // keep their original materials
    // });
    cone.visible = true

    markers.forEach((m) => (m.visible = false));
    const whiteMat = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        shininess: 30,
    });
    whiteMat.dithering = true;
    const prevOverride = scene.overrideMaterial;
    scene.overrideMaterial = whiteMat;

    // Capture cube map
    cubeCamera.position.copy(cone.position);
    cubeCamera.quaternion.copy(cone.quaternion);
    cubeCamera.quaternion.multiply(
      new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0,1,0),
        Math.PI/2
      )
    );
    renderer.autoClear = true
    cubeCamera.update(renderer, scene);

    // Restore material and visibility
    scene.overrideMaterial = prevOverride;
    markers.forEach((m) => (m.visible = true));

    // 6) equirectangular pass (identical to exportAll360ForGroup)
    // Equirectangular pass
    renderer.setPixelRatio(1);
    renderer.setSize(4096, 2048);
    renderer.setRenderTarget(null);
    renderer.autoClear = true;
    renderer.setClearColor(0x000000, 1);
    renderer.clear(true, true, true);
    renderer.render(eqScene, eqCam);

    // Source canvas
    const srcCanvas = renderer.domElement;

    const dataURL = srcCanvas.toDataURL("image/jpeg", 0.8);

    // 8) re-enable wireframes
    originalWireframeMeshes.forEach(m => {
      m.material.wireframe = true;
      m.material.needsUpdate = true;
    });

    lights.forEach((l) => scene.remove(l));

    // 7) restore renderer state
    renderer.setPixelRatio(origDPR);
    renderer.setSize(origSize.x, origSize.y, true);
    renderer.setClearColor(origClearColor, origClearAlpha);
    renderer.autoClear = origAutoClear;

    // 9) return a JPEG data-URL
    return dataURL;
}

    /**
     * exportAll360ForGroup: exports one group's CSV+cones into a zip folder (or downloads directly)
     * @param {Object3D} groupObj - the CSV group object
     * @param {JSZip} [zipFolder] - optional JSZip folder for multi-group export
     */
    async function exportAll360ForGroup(groupObj, zipFolder) {
        const isRootCall = !zipFolder;
        // Capture original renderer state
        const origSize = renderer.getSize(new THREE.Vector2());
        const origDPR = renderer.getPixelRatio();
        const origClearColor = renderer
            .getClearColor(new THREE.Color())
            .getHex();
        const origClearAlpha = renderer.getClearAlpha();
        const origAutoClear = renderer.autoClear;
        const origPhysLights = renderer.physicallyCorrectLights;
        const origToneMapping = renderer.toneMapping;
        const origToneExp = renderer.toneMappingExposure;
        const origDither = renderer.dither;

        // Prepare ZIP target
        const zip = zipFolder || new JSZip();

        // Derive prefix from CSV name
        const base = groupObj.name.toLowerCase().replace(/\.csv$/, "");
        const prefix = base.split("_").slice(-5).join("_");
        console.log(
            `Starting export for group: ${groupObj.name}, prefix: ${prefix}`,
        );

        // Find cones
        const cones = groupObj.children.filter((ch) => ch.cameraPos);
        console.log(`Found ${cones.length} cones for group ${prefix}`);

        // Add lights once
        const lights = cones.map((cone) => {
            const light = new THREE.PointLight(0xffffff, 20, 0, 0.8);
            light.position.copy(cone.position);
            scene.add(light);
            return light;
        });

        // Helper to yield control
        const tick = () => new Promise((r) => setTimeout(r, 0));

        // Single loop: render once per cone, then zip original + flipped
        for (let i = 0; i < cones.length; i++) {
            const cone = cones[i];
            const instanceName = `${prefix}_${cone.name}`.toLowerCase();
            console.log(
                `▶ [${groupObj.name}] Processing cone ${i + 1}/${cones.length}: ${instanceName}`,
            );

            // Hide cones and override material
            markers.forEach((m) => (m.visible = false));
            const whiteMat = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                shininess: 30,
            });
            whiteMat.dithering = true;
            const prevOverride = scene.overrideMaterial;
            scene.overrideMaterial = whiteMat;

            // Capture cube map
            cubeCamera.position.copy(cone.position);
            console.log(cone.quaternion)
            cubeCamera.quaternion.copy(cone.quaternion);
               // add a 90° clockwise offset about world-Y
               cubeCamera.quaternion.multiply(
                 new THREE.Quaternion().setFromAxisAngle(
                   new THREE.Vector3(0,1,0),
                   -Math.PI/2
                 )
               );
            cubeCamera.update(renderer, scene);

            // Restore material and visibility
            scene.overrideMaterial = prevOverride;
            markers.forEach((m) => (m.visible = true));

            // Equirectangular pass
            renderer.setPixelRatio(1);
            renderer.setSize(4096, 2048);
            renderer.setRenderTarget(null);
            renderer.autoClear = true;
            renderer.setClearColor(0x000000, 1);
            renderer.clear(true, true, true);
            renderer.render(eqScene, eqCam);

            // Source canvas
            const srcCanvas = renderer.domElement;

            // ZIP original
            console.log(`  Capturing original: ${instanceName}.jpg`);
            const origDataURL = srcCanvas.toDataURL("image/jpeg", 0.8);
            zip.file(`${instanceName}.jpg`, origDataURL.split(",")[1], {
                base64: true,
            });

            // Prepare flipped name
            const flipParts = prefix.split("_");
            if (flipParts.length >= 3) flipParts[2] += "f";
            const flippedName =
                `${flipParts.join("_")}_${cone.name}`.toLowerCase();

            // ZIP flipped
            console.log(`  Capturing flipped: ${flippedName}.jpg`);
            const off = document.createElement("canvas");
            off.width = srcCanvas.width;
            off.height = srcCanvas.height;
            const ctx = off.getContext("2d");
            ctx.translate(off.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(srcCanvas, 0, 0);
            const flipDataURL = off.toDataURL("image/jpeg", 0.8);
            zip.file(`${flippedName}.jpg`, flipDataURL.split(",")[1], {
                base64: true,
            });

            // Yield periodically
            if (i % 5 === 4) await tick();
        }

        // Duplicate s1→s2
        Object.keys(zip.files).forEach((fn) => {
            if (/s1/i.test(fn)) {
                const newName = fn.replace(/s1/gi, "s2");
                console.log(`↪ Duplicating ${fn} to ${newName}`);
                const data = zip.files[fn]._data;
                zip.file(newName, data, { base64: true });
            }
        });

        // Cleanup lights
        lights.forEach((l) => scene.remove(l));
        console.log(`Completed export for group ${prefix}`);

        // If root call, finalize and download ZIP
        if (isRootCall) {
            console.log("Generating ZIP...");
            const blob = await zip.generateAsync(
                { type: "blob", streamFiles: true, worker: true },
                (meta) => {
                    console.log(`  ZIP progress: ${meta.percent.toFixed(1)}%`);
                },
            );
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `${base}-360s-batches.zip`;
            a.click();
            console.log("Download triggered");
        }

        // Restore renderer state
        renderer.setPixelRatio(origDPR);
        renderer.setSize(origSize.x, origSize.y);
        renderer.setClearColor(origClearColor, origClearAlpha);
        renderer.autoClear = origAutoClear;
        renderer.physicallyCorrectLights = origPhysLights;
        renderer.toneMapping = origToneMapping;
        renderer.toneMappingExposure = origToneExp;
        renderer.dither = origDither;

        // Re-enable wireframes
        scene.traverse((o) => {
            if (o.isMesh && o.material) {
                const mats = Array.isArray(o.material)
                    ? o.material
                    : [o.material];
                mats.forEach((m) => {
                    m.wireframe = true;
                    m.needsUpdate = true;
                });
            }
        });
        console.log("Renderer and wireframes restored.");
    }

    // Recursively toggle visibility in the Three.js scene
    function toggleVisibility(object, visible) {
        object.visible = visible;
        object.userData.isEnabled = visible;
        if (object.children) {
            object.children.forEach((child) =>
                toggleVisibility(child, visible),
            );
        }
    }

    // Apply or remove visual "disabled" style on a <li> subtree
    function styleSubtree(liElement, enabled) {
        const applyStyle = (el) => {
            el.style.opacity = enabled ? "1" : "0.5";
            el.style.textDecoration = enabled ? "" : "line-through";
        };
        applyStyle(liElement.querySelector("div"));
        // Also style all descendant <div> containers
        liElement
            .querySelectorAll("li > div")
            .forEach((div) => applyStyle(div));
    }

    function updateObjectColor(object, color) {
        // Update material color if this object is a Mesh.
        if (object.isMesh && object.material && object.material.color) {
            object.material.color.set(color);
            object.material.needsUpdate = true;
        }
        // If a color picker was stored on this object, update it.
        if (object.userData && object.userData.colorPicker) {
            object.userData.colorPicker.value = color;
        }
        // Recursively update all children.
        if (object.children && object.children.length > 0) {
            object.children.forEach((child) => updateObjectColor(child, color));
        }
    }

    // Utility to extract a grouping key from object names (segments 3–6)
    function getGroupId(name) {
        const segments = name.split("_");
        if (segments.length >= 6) {
            // take segments[2], [3], [4], [5]
            return segments.slice(2, 6).join("_");
        }
        return null;
    }

    // Updated updateOutliner with grouping logic
    function updateOutliner() {
        const outliner = document.getElementById("outliner");
        if (!outliner) return;
        outliner.innerHTML = "";

        // -- build map of groups --
        const groupsMap = new Map();
        const standalone = [];
        scene.children.forEach((obj) => {
            const nm = obj.name || "";
            const lo = nm.toLowerCase();
            const key = getGroupId(nm);
            if ((lo.endsWith(".csv") || lo.endsWith(".glb")) && key) {
                if (!groupsMap.has(key)) groupsMap.set(key, []);
                groupsMap.get(key).push(obj);
            } else {
                standalone.push(obj);
            }
        });

        // -- status line --
        let statusEl = null;
        if (groupsMap.size > 1) {
            statusEl = document.createElement("div");
            statusEl.className = "mb-1 text-xs text-gray-700";
            statusEl.textContent = "Ready to export groups…";
            outliner.appendChild(statusEl);
        }

        // -- “Export All” button --
        if (groupsMap.size > 1) {
            // Export All Groups button
            const btn = document.createElement("button");
            btn.textContent = "Export All Groups 360°";
            btn.className = "mb-2 p-1 bg-blue-500 text-white text-xs rounded";
            btn.addEventListener('click', async () => {
                btn.disabled = true;
                statusEl.textContent = 'Starting export of all groups…';
                await new Promise(r=>setTimeout(r,0));

                // 1) Single master zip
                const rootZip = new JSZip();
                let idx = 1;
                const total = groupsMap.size;

                // 2) Loop over each group once
                for (const objs of groupsMap.values()) {
                    const csvObj = objs.find(o => o.name.toLowerCase().endsWith('.csv'));
                    if (!csvObj) continue;

                    const key = getGroupId(csvObj.name);
                    statusEl.textContent = `Processing group “${key}” (${idx}/${total})…`;
                    console.log(`→ [${idx}/${total}] exporting group ${key}`);
                    await new Promise(r=>setTimeout(r,0));

                    // 3) Create a sub-folder in the master zip
                    const folder = rootZip.folder(key);
                    // This writes *only* this group’s panoramas into that folder
                    await exportAll360ForGroup(csvObj, folder);

                    idx++;
                }

                // 4) Finalize and download
                statusEl.textContent = 'Finalizing ZIP…';
                console.log('All groups done, generating combined ZIP');
                const blob = await rootZip.generateAsync({
                    type: 'blob',
                    streamFiles: true,
                    worker: true,
                }, meta => console.log(`ZIP ${meta.percent.toFixed(1)}%`));

                const a = document.createElement('a');
                a.href     = URL.createObjectURL(blob);
                a.download = 'all-groups-360s.zip';
                a.click();
                console.log('Combined ZIP download triggered');

                statusEl.textContent = '✅ All groups exported!';
                btn.disabled = false;
            });

            outliner.appendChild(btn);
        }

        // -- now render the tree as before --
        const ul = document.createElement("ul");
        // Build grouped nodes
        groupsMap.forEach((objs, key) => {
            const parentLi = document.createElement("li");
            parentLi.className =
                "group-node my-[3px] text-2xs hover:bg-gray-300 cursor-pointer flex flex-col";

            // Container for name and events
            const container = document.createElement("div");
            container.className = "flex items-center gap-2";
            container.textContent = `Group: ${key}`;

            // Double-click toggles visibility
            container.addEventListener("dblclick", (e) => {
                e.stopPropagation();
                const newState = !objs[0].visible;
                objs.forEach((o) => (o.visible = newState));
                objs.forEach((o) => {
                    if (o.userData.csvObject) {
                        const csvObj = scene.getObjectByProperty(
                            "uuid",
                            o.userData.csvObject,
                        );
                        if (csvObj) csvObj.visible = newState;
                    }
                });
                createLabels();
                styleSubtree(parentLi, newState);
            });

            parentLi.appendChild(container);

            // Children
            const childUl = document.createElement("ul");
            childUl.className = "ml-4 list-disc";
            objs.forEach((childObj) => {
                childUl.appendChild(buildTree(childObj));
            });
            parentLi.appendChild(childUl);
            ul.appendChild(parentLi);
        });

        // Standalone
        standalone.forEach((obj) => {
            ul.appendChild(buildTree(obj));
        });

        outliner.appendChild(ul);
    }

    const refDropzone = document.getElementById("reference-dropzone");
    const alignDropzone = document.getElementById("align-dropzone");
    const alignButton = document.getElementById("align-button");
    const alignmentPopup = document.getElementById("alignment-popup");

    // Prevent default behavior for dragover events.
    [refDropzone, alignDropzone].forEach((zone) => {
        zone.addEventListener("dragover", (e) => {
            e.preventDefault();
            console.log(e);
        });
    });

    // Handle drop on Reference zone.
    refDropzone.addEventListener("drop", (e) => {
        e.preventDefault();
        console.log("Dropped");
        console.log(e);
        if (referenceSelection.length >= 2) return;
        const objId = parseInt(e.dataTransfer.getData("text/plain"));
        const obj = scene.getObjectById(objId);
        if (!obj) return;
        // Optionally, check that this object comes from a CSV-derived group (e.g. via a flag)
        referenceSelection.push(obj);
        console.log(referenceSelection);
        updateDropzoneUI(refDropzone, referenceSelection);
        checkAlignmentReady();
    });

    // Handle drop on Align zone.
    alignDropzone.addEventListener("drop", (e) => {
        e.preventDefault();
        console.log(e);
        if (alignSelection.length >= 2) return;
        const objId = parseInt(e.dataTransfer.getData("text/plain"));
        const obj = scene.getObjectById(objId);
        if (!obj) return;
        alignSelection.push(obj);
        console.log(alignSelection);
        updateDropzoneUI(alignDropzone, alignSelection);
        checkAlignmentReady();
    });

    // Helper to update the dropzone display.
    function updateDropzoneUI(zone, selectionArray) {
        zone.innerHTML = "";
        selectionArray.forEach((obj) => {
            const span = document.createElement("span");
            span.textContent = obj.name;
            span.className = "block text-center text-blue-700";
            zone.appendChild(span);
        });
        if (selectionArray.length === 0) {
            zone.textContent = "Drop 2 items here";
        }
    }

    // Check if both zones have 2 items and show the Align button.
    function checkAlignmentReady() {
        if (referenceSelection.length === 2 && alignSelection.length === 2) {
            alignButton.classList.remove("hidden");
        }
    }

    alignButton.addEventListener("click", () => {
        alignGroups(referenceSelection, alignSelection);
        // Clear selections and hide popup
        referenceSelection = [];
        alignSelection = [];
        refDropzone.innerHTML = "Drop 2 items here";
        alignDropzone.innerHTML = "Drop 2 items here";
        alignButton.classList.add("hidden");
        alignmentPopup.classList.add("hidden");
    });

    // Alignment function: splits the transformation between the two groups.
    function alignGroups(refMarkers, alignMarkers) {
        // Assume the CSV-derived group is the parent of a marker.
        const groupA = refMarkers[0].parent;
        const groupB = alignMarkers[0].parent;

        // Helper to get an object's world position.
        const getPosition = (obj) => {
            const pos = new THREE.Vector3();
            obj.getWorldPosition(pos);
            return pos;
        };

        // Get the world positions of the two markers for each group.
        const p1 = getPosition(refMarkers[0]);
        const p2 = getPosition(refMarkers[1]);
        const q1 = getPosition(alignMarkers[0]);
        const q2 = getPosition(alignMarkers[1]);

        // Compute each group's anchor (midpoint of its two markers).
        const midA = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
        const midB = new THREE.Vector3().addVectors(q1, q2).multiplyScalar(0.5);

        // Compute the global target anchor (average of the two midpoints).
        const midAvg = new THREE.Vector3()
            .addVectors(midA, midB)
            .multiplyScalar(0.5);

        // Compute rotation angles based on projection to the XZ plane.
        const getXZ = (vec) => new THREE.Vector2(vec.x, vec.z);
        const angleA = Math.atan2(
            getXZ(p2).y - getXZ(p1).y,
            getXZ(p2).x - getXZ(p1).x,
        );
        const angleB = Math.atan2(
            getXZ(q2).y - getXZ(q1).y,
            getXZ(q2).x - getXZ(q1).x,
        );
        const deltaAngle = angleB - angleA;

        // For each group, compute how much to translate so that its anchor becomes midAvg.
        const offsetA = new THREE.Vector3().subVectors(midAvg, midA);
        const offsetB = new THREE.Vector3().subVectors(midAvg, midB);

        // Apply the translation to each group.
        groupA.position.add(offsetA);
        groupB.position.add(offsetB);

        // Helper function to rotate a group about a given world point.
        function rotateGroupAboutPoint(group, point, angle) {
            group.position.sub(point);
            group.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
            group.position.add(point);
            group.rotation.y += angle;
        }

        // Rotate groupA about midAvg by half the deltaAngle.
        rotateGroupAboutPoint(groupA, midAvg, deltaAngle / 2);
        // Rotate groupB about midAvg by the negative half deltaAngle.
        rotateGroupAboutPoint(groupB, midAvg, -deltaAngle / 2);

        console.log(
            "Aligned groups using marker anchors:",
            groupA.name,
            groupB.name,
        );
    }

    document
        .getElementById("open-align-popup")
        ?.addEventListener("click", () => {
            alignmentPopup.classList.remove("hidden");
        });

    document.getElementById("scale-slider").addEventListener("input", (e) => {
        scaleGroupRelativeToCenter(m_Group, e.target.value);
    });

    document
        .getElementById("cone-size-slider")
        .addEventListener("input", (e) => {
            markers.forEach((i) => {
                console.log(e);
                i.scale.set(e.target.value, e.target.value, e.target.value);
                console.log(i.scale);
            });
        });

    window.addEventListener("export-csv", (e) => {
        createCSVFromSphereGroups([m_Group]);
    });

    window.addEventListener("object-switch", (e) => {
        csvGroups.forEach((e) => {
            e.visible = false;
        });
        fbxFiles.forEach((e) => {
            e.visible = false;
        });
        simplifiedNamesId.forEach((i) => {
            if (i.simplifiedName == e.detail) {
                // console.log(i.csvObject);
                scene.getObjectByProperty("uuid", i.uuid).visible = true;
                if (i.csvObject) {
                    const csvObj = scene.getObjectByProperty(
                        "uuid",
                        i.csvObject,
                    );
                    csvObj.visible = true;
                    csvObj.children.forEach((j) => {
                        j.visible = true;
                    });
                    m_Group = scene.getObjectByProperty("uuid", i.csvObject);
                }
            } else {
                scene.getObjectByProperty("uuid", i.uuid).visible = false;
                if (i.csvObject) {
                    const csvObj = scene.getObjectByProperty(
                        "uuid",
                        i.csvObject,
                    );
                    csvObj.visible = false;
                    csvObj.children.forEach((j) => {
                        j.visible = false;
                    });
                }
            }
        });
    });

    //Gizmo controls
    document.getElementById("camera-top").addEventListener("click", (e) => {
        camera.position.set(0, 400, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    });

    document.getElementById("camera-bottom").addEventListener("click", (e) => {
        camera.position.set(0, -400, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 180, 0));
    });

    document.getElementById("camera-left").addEventListener("click", (e) => {
        camera.position.set(-200, 0, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    });

    document.getElementById("camera-right").addEventListener("click", (e) => {
        camera.position.set(200, 0, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    });

    window.addEventListener("resize", onWindowResize, false);

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>

<style>
    html {
        min-height: 100vh;
        width: 100%;
        margin: 0%;
    }

    body {
        /* min-height: 100vh;
        width: 100%;
        margin: 0%; */
        max-width: 100vw;
        display: flex;
        flex-wrap: wrap;
        min-height: 90vh;
        margin: 0%;
    }

    .ui-area {
        position: fixed;
        height: min-content;
    }

    .notification-panel {
        position: fixed;
        display: flex;
        flex-direction: column;
        right: 0%;
        width: 250px;
        grid-column: auto;
        gap: 10px;
    }

    .notification {
        padding: 0.5em;
        background-color: azure;
    }

    #tag,
    #tag * {
        display: flex;
        position: fixed;
        background-color: #cccccccc;
        padding: 0em 0.5em;
        text-align: left;
        line-height: 0.5em;
        font-family: monospace;
        font-weight: 100;
        justify-content: center;
        min-width: max-content;
        pointer-events: none;
        /* transform: translate(-50%); */
        /* min-height: 50px; */
        height: fit-content;
        border-radius: 6px;
        /* font-family: sans-serif; */
    }
    #label {
        display: flex;
        text-align: center;
        justify-content: center;
        margin: 0%;
        height: 100%;
        font-family: sans-serif;
    }
</style>
