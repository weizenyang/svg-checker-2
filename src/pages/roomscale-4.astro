---
import ObjectList from "../components/object-list.tsx";
// import * as DECODER from "../scripts/decoder/draco_decoder.js";
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Three.js - Three Sides of a Cube</title>
    </head>
    <body id="drop-zone" class="overflow-hidden">
        <button 
            id="ui-toggle" 
            class="absolute bottom-1/3 transform -translate-y-1/2 bg-zinc-300 hover:bg-zinc-400 text-zinc-700 px-2 py-1 rounded-r-md transition-colors duration-75 z-50"
            title="Toggle UI Panel (N key)"
        >
            <span id="ui-arrow" class="transform transition-transform duration-200">â—€</span>
        </button>
        
        <div
            class="ui-area transition-all bg-zinc-100 p-1 rounded-sm text-xs relative"
            id="ui-area"
            style="transition: transform 0.3s ease-in-out;"
        >
            <div id="ui-content" class="flex flex-col">
                <div class="flex">
                    <a
                    href="/"
                    class="flex w-fit border-2 border-zinc-300 pl-2 pr-2 p-1 mb-1 transition-all duration-75 drop-shadow-sm text-center rounded-md content-center hover:bg-neutral-100 hover:drop-shadow-lg"
                >
                    <div class="align-center content-center">
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke-width="1.5"
                            stroke="currentColor"
                            class="size-5"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                d="m2.25 12 8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25"
                            ></path>
                        </svg>
                    </div>
                    <p class="ml-2 text-center">Home</p>
                </a>
                <button
                    id="clear-all-data"
                    class="flex transition-all duration-75 drop-shadow-sm bg-red-600 text-white p-2 ml-2 mb-1 rounded-md hover:drop-shadow-xl hover:bg-red-500 hover:text-white"
                >
                    Clear All Data
                </button>
                </div>
                
                <div class="flex">
                    <button
                    id="next-csv-point"
                    class="flex transition-all duration-75 drop-shadow-sm bg-blue-600 text-white p-2 mb-1 rounded-md hover:drop-shadow-xl hover:bg-blue-500 hover:text-white"
                >
                    Next Point
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="16"
                        height="16"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        class="ml-2"
                    >
                        <path d="M9 18l6-6-6-6" stroke-width="2"></path>
                    </svg>
                </button>
                </div>
                
            </div>

            <hr class="border-b border-zinc-200 mb-3" />
            <button
                class="bg-zinc-300 text-lime-600 font-mono p-0.5 rounded-md w-full drop-shadow-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                id="log-scene">... Log Scene ...</button
            >
            <div>
                
            </div>
            <div class="flex mt-3">
                <p class="font-medium">Flip Points:</p>
            </div>
            <div class="flex space-x-1">
                
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="x-flip"
                >
                    X-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="y-flip"
                >
                    Y-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="z-flip"
                >
                    Z-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="y-up"
                >
                    -Y Coord
                </button>
            </div>

            <div class="flex mt-3">
                <p class="font-medium">Flip Models:</p>
            </div>
            <div class="flex space-x-1">
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="model-x-flip"
                >
                    X-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="model-y-flip"
                >
                    Y-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="model-z-flip"
                >
                    Z-Axis
                </button>
            </div>

            <div class="flex flex-col mt-3">
                <div class="relative">
                    <button
                        id="select-reversed-faces" 
                        class="bg-purple-500 text-white p-2 rounded-md transition-all duration-75 drop-shadow-sm hover:bg-purple-600 hover:drop-shadow-lg active:bg-purple-700 w-full flex items-center justify-between"
                    >
                        <span>Select Reversed Faces</span>
                        <span class="ml-2">â–¼</span>
                    </button>
                    <div id="select-reversed-faces-dropdown" class="hidden absolute top-full left-0 mt-1 w-full bg-white border border-gray-300 rounded-md shadow-lg z-50">
                        <button
                            id="select-reversed-faces-single"
                            class="w-full text-left px-4 py-2 hover:bg-gray-100 rounded-t-md"
                        >
                            Process Current Model
                        </button>
                        <button
                            id="select-reversed-faces-batch"
                            class="w-full text-left px-4 py-2 hover:bg-gray-100 rounded-b-md border-t border-gray-200"
                        >
                            Batch Process Collision Models
                        </button>
                    </div>
                </div>
                <button
                    id="select-reversed-faces-current"
                    class="bg-purple-200 text-purple-900 p-2 rounded-md transition-all duration-75 drop-shadow-sm hover:bg-purple-300 hover:drop-shadow-lg active:bg-purple-400 mt-2"
                    style="display: none;"
                >
                    Select This Camera's Reversed Faces
                </button>
                <button
                    id="flip-selected-normals"
                    class="bg-red-200 text-red-900 p-2 rounded-md transition-all duration-75 drop-shadow-sm hover:bg-red-300 hover:drop-shadow-lg active:bg-red-400 mt-2"
                    style="display: none;"
                >
                    Flip Selected Normals
                </button>
                <button
                    id="flatten-combine-meshes"
                    class="bg-green-200 text-green-900 p-2 rounded-md transition-all duration-75 drop-shadow-sm hover:bg-green-300 hover:drop-shadow-lg active:bg-green-400 mt-2"
                >
                    Flatten & Combine Meshes (Exclude Spheres)
                </button>
                <label class="mt-2 flex items-center space-x-2 text-sm">
                    <input type="checkbox" id="toggle-export-logs" class="accent-purple-600" />
                    <span>Export logs & screengrabs (first 3 cameras)</span>
                </label>
            </div>

            <div class="rounded-md bg-white max-w-60 mt-3">
                <button 
                    id="controls-toggle" 
                    class="w-full p-2 text-left font-medium bg-gray-100 hover:bg-gray-200 transition-colors duration-75 rounded-t-md flex items-center justify-between"
                >
                    <span>Controls</span>
                    <span id="controls-arrow" class="transform transition-transform duration-200" style="transform: rotate(-90deg);">â–¼</span>
                </button>
                <div id="controls-content" class="p-3 space-y-2" style="display: none;">
                    <div>
                        <label for="center-csv">Center</label>
                        <input type="checkbox" id="center-csv" name="center-csv" />
                    </div>
                    <div>
                        <label for="show-labels">Show Labels</label>
                        <input
                            type="checkbox"
                            id="show-labels"
                            name="show-labels"
                            checked
                        />
                    </div>
                    <div>
                        <label for="show-face-orientation"
                            >Show Face Orientation</label
                        >
                        <input
                            type="checkbox"
                            id="show-face-orientation"
                            name="show-face-orientation"
                            checked
                        />
                    </div>
                    <div>
                        <label for="scale-slider">Cone Size</label>
                        <input
                            type="range"
                            class="accent-gray-400 hover:accent-lime-600 active:accent-lime-800 transition-all duration-75"
                            id="cone-size-slider"
                            name="cone-size-slider"
                            min='0"'
                            max="50"
                            step="1"
                            value="1"
                        />
                    </div>
                    <div>
                        <label for="scale-slider">Scale</label>
                        <input
                            type="range"
                            class="accent-gray-400 hover:accent-lime-600 active:accent-lime-800 transition-all duration-75"
                            id="scale-slider"
                            name="scale-slider"
                            min="-5"
                            max="5"
                            step="0.1"
                            value="1"
                        />
                    </div>
                </div>
            </div>

            <!-- <ObjectList client:load /> -->

            <button
                id="export-all-fbx"
                class="flex transition-all duration-75 drop-shadow-sm bg-zinc-600 text-lime-100 p-2 mt-3 rounded-md hover:drop-shadow-xl hover:bg-zinc-500 hover:text-lime-400"
                style="margin-bottom: 10px"
            >
                Export All To GLB
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    class="ml-2 rotate-180"
                >
                    <path
                        d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
                        stroke-width="2"></path>
                    <polyline points="7 10 12 15 17 10" stroke-width="2"
                    ></polyline>
                    <line x1="12" x2="12" y1="15" y2="3" stroke-width="2"
                    ></line>
                </svg></button
            >

            <label style="margin-left: 10px; font-family: monospace;">
                <input type="checkbox" id="export-all-scene-checkbox" />
                Export Entire Scene
            </label>

            <button
                id="export-csv-rotations"
                class="flex transition-all duration-75 drop-shadow-sm bg-green-600 text-white p-2 mt-3 rounded-md hover:drop-shadow-xl hover:bg-green-500 hover:text-white"
                style="margin-bottom: 10px"
            >
                Export CSV with Rotations
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    class="ml-2"
                >
                    <path
                        d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
                        stroke-width="2"></path>
                    <polyline points="7 10 12 15 17 10" stroke-width="2"
                    ></polyline>
                    <line x1="12" x2="12" y1="15" y2="3" stroke-width="2"
                    ></line>
                </svg></button
            >

            <div class="rounded-md bg-zinc-300 max-w-52 p-5 pl-2 pr-2 mt-3">
                <h2 class="font-bold">Floors:</h2>
                <div class="flex flex-col" id="show-floors">
                    <p>Import a Camera CSV to start</p>
                </div>
            </div>

            <div class="rounded-md bg-green-100 max-w-52 p-3 mt-3">
                <h2 class="font-bold text-xs">Image Storage:</h2>
                <div class="text-xs" id="image-cache-stats">
                    <p>Total: 0 images</p>
                    <p>Cached: 0/20</p>
                    <p>Hit Rate: <span style="color: green">100%</span></p>
                    <p>Avg Load: 0ms</p>
                </div>
                
                <div id="loading-progress" class="mt-2 hidden">
                    <div class="bg-gray-200 rounded-full h-2">
                        <div id="progress-bar" class="bg-green-500 h-2 rounded-full" style="width: 0%"></div>
                    </div>
                    <p class="text-xs mt-1" id="progress-text">Indexing images...</p>
                </div>
            </div>
            </div>
        </div>

        <main class="fixed flex right-0 pointer-events-none">

            

            <div class="flex flex-col pointer-events-auto">
                <div class="right-0 max-w-2xl text-xs" id="gizmo">
                    <div class="p-2">
                        <div id="rendering-mode" class="mb-2">
                            <div class="flex bg-gray-100 rounded-lg p-1">
                                <button id="perspective-tab" class="flex-1 px-3 py-1 text-xs font-medium rounded-md transition-colors bg-white text-gray-900 shadow-sm">
                                    Perspective
                                </button>
                                <button id="orthographic-tab" class="flex-1 px-3 py-1 text-xs font-medium rounded-md transition-colors text-gray-600 hover:text-gray-900">
                                    Orthographic
                                </button>
                            </div>
                        </div>
                        <div class="h-36 w-44" id="orthoView"></div>
                    </div>
                    <button id="open-align-popup"> Align Points </button>
                </div>

                <div
                    id="outliner"
                    class="pointer-events-auto mt-2 bg-gray-200 pl-2 text-[10px]"
                    style="height: 400px; max-height: 400px; overflow-y: auto; overflow-x: hidden;"
                >
                </div>
                <!-- Alignment Popup: hidden by default -->
                <div
                    id="alignment-popup"
                    class="fixed left-4 top-1/2 transform -translate-y-1/2 bg-white border border-gray-300 rounded-md shadow-lg p-4 hidden z-50"
                >
                    <div class="mb-2">
                        <h3 class="font-bold text-sm mb-1">Reference Points</h3>
                        <div
                            id="reference-dropzone"
                            class="w-40 h-20 border-2 border-dashed border-gray-400 flex flex-col items-center justify-center text-xs"
                        >
                            Drop 2 items here
                        </div>
                    </div>
                    <div class="mb-2">
                        <h3 class="font-bold text-sm mb-1">Align Points</h3>
                        <div
                            id="align-dropzone"
                            class="w-40 h-20 border-2 border-dashed border-gray-400 flex flex-col items-center justify-center text-xs"
                        >
                            Drop 2 items here
                        </div>
                    </div>
                    <button
                        id="align-button"
                        class="w-full bg-blue-500 text-white py-1 rounded-md text-xs hidden"
                    >
                        Align
                    </button>
                </div>
            </div>
        </main>

        <div class="notification-panel" id="notification-panel"></div>

        <div id="tag" class="z-[101]">
            <h3 id="label">-</h3>
        </div>

        <!-- Batch Processing Modal -->
        <div id="batch-process-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-[200] flex items-center justify-center">
            <div class="bg-white rounded-lg shadow-xl p-6 max-w-2xl w-full mx-4 max-h-[90vh] flex flex-col">
                <h2 class="text-xl font-bold mb-4">Batch Process Collision Models</h2>
                <p class="text-sm text-gray-600 mb-4">Upload collision model files (.glb) and their corresponding camera CSV files. Files will be paired automatically.</p>
                
                <div 
                    id="batch-file-drop-zone"
                    class="border-2 border-dashed border-gray-300 rounded-lg p-6 mb-4 min-h-[200px] flex flex-col"
                >
                    <div class="text-center text-gray-500 mb-4">
                        <p class="mb-2">Drag and drop files here</p>
                        <p class="text-xs">or</p>
                        <input 
                            type="file" 
                            id="batch-file-input" 
                            multiple 
                            accept=".glb,.csv"
                            class="hidden"
                        />
                        <label 
                            for="batch-file-input" 
                            class="inline-block mt-2 px-4 py-2 bg-purple-500 text-white rounded-md cursor-pointer hover:bg-purple-600"
                        >
                            Browse Files
                        </label>
                    </div>
                    
                    <div id="batch-file-list" class="flex-1 overflow-y-auto">
                        <p class="text-sm text-gray-400 text-center">No files added yet</p>
                    </div>
                </div>
                
                <div class="flex justify-end space-x-3">
                    <button
                        id="batch-process-cancel"
                        class="px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300"
                    >
                        Cancel
                    </button>
                    <button
                        id="batch-process-start"
                        class="px-4 py-2 bg-purple-500 text-white rounded-md hover:bg-purple-600 disabled:bg-gray-400 disabled:cursor-not-allowed"
                        disabled
                    >
                        Batch Process
                    </button>
                </div>
                
                <div id="batch-process-progress" class="hidden mt-4">
                    <div class="flex items-center justify-between mb-2">
                        <span class="text-sm font-medium">Processing...</span>
                        <span id="batch-process-status" class="text-sm text-gray-600">0/0</span>
                    </div>
                    <div class="w-full bg-gray-200 rounded-full h-2">
                        <div id="batch-process-progress-bar" class="bg-purple-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <p id="batch-process-current-file" class="text-xs text-gray-500 mt-2"></p>
                </div>
            </div>
        </div>
    </body>
    <div
        id="marker-label-container"
        class="overflow-hidden pointer-events-none z-[100]"
    >
    </div>
    <div id="hover-tooltip"
     style="position:fixed; padding:4px 8px; font:11px/1 monospace;
            color:#fff; background:#000d; border-radius:4px;
            pointer-events:none; opacity:0; transition:opacity .15s">
    Click to focus
    </div>
</html>

<script>
    import * as THREE from "../scripts/three";
    import { OrbitControls } from "../scripts/three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "../scripts/three/examples/jsm/loaders/GLTFLoader.js";
    import { FBXLoader } from "../scripts/three/examples/jsm/loaders/FBXLoader";
    import { GLTFExporter } from "../scripts/three/examples/jsm/exporters/GLTFExporter.js";
    import { DRACOLoader } from "../scripts/three/examples/jsm/loaders/DRACOLoader.js";
    import JSZip from "jszip";
    import gsap from "gsap";

    //Resizing image previewer
    // Floating VR widget (chat-style)
    const vrWidget = document.createElement('div');
    vrWidget.id = 'vr-widget';
    Object.assign(vrWidget.style, {
        position: 'fixed',
        right: '16px',
        bottom: '16px',
        width: '360px',
        height: '180px',
        display: 'none',
        zIndex: '120',
        pointerEvents: 'auto'
    });
    document.body.appendChild(vrWidget);

    // Launcher (round button)
    const vrLauncher = document.createElement('button');
    vrLauncher.id = 'vr-launcher';
    vrLauncher.title = 'Open VR View';
    Object.assign(vrLauncher.style, {
        position: 'fixed',
        right: '16px',
        bottom: '16px',
        width: '44px',
        height: '44px',
        borderRadius: '9999px',
        background: '#e5e7eb',
        border: '1px solid #d4d4d8',
        boxShadow: '0 6px 20px rgba(0,0,0,.15)',
        cursor: 'pointer',
        zIndex: '121'
    } as CSSStyleDeclaration);
    vrLauncher.innerHTML = '<span style="font-size:12px; font-family: monospace;">VR</span>';
    document.body.appendChild(vrLauncher);

    // Panel container anchored above the launcher
    const panel = document.createElement('div');
    panel.id = 'vr-image-panel';
    Object.assign(panel.style, {
        position: 'absolute',
        right: '0',
        bottom: '60px',
        width: '360px',
        height: '180px',
        background: '#fff',
        border: '1px solid #a1a1aa',
        boxShadow: '0 10px 30px rgba(0,0,0,.18)',
        borderRadius: '8px',
        overflow: 'hidden',
        resize: 'none'
    } as CSSStyleDeclaration);
    vrWidget.appendChild(panel);

    // Inner contents
    const img = document.createElement('img');
    img.id = 'vr-img';
    Object.assign(img.style, { width: '100%', height: '100%', objectFit: 'contain' });
    panel.appendChild(img);

    const overlayCanvas = document.createElement('canvas');
    overlayCanvas.id = 'vr-overlay-canvas';
    Object.assign(overlayCanvas.style, { position:'absolute', inset:'0', opacity:'0.3', display:'none', pointerEvents:'none' });
    panel.appendChild(overlayCanvas);

    const dragOverlay = document.createElement('div');
    dragOverlay.id = 'vr-drag-overlay';
    dragOverlay.className = 'hidden';
    Object.assign(dragOverlay.style, { position:'absolute', inset:'0', cursor:'grab', zIndex:'8', userSelect:'none' });
    panel.appendChild(dragOverlay);

    const flippedTag = document.createElement('div');
    flippedTag.id = 'vr-flipped-tag';
    flippedTag.className = 'hidden';
    Object.assign(flippedTag.style, { position:'absolute', left:'8px', top:'8px', background:'#dc2626', color:'#fff', fontSize:'10px', fontWeight:'700', borderRadius:'4px', padding:'2px 6px' });
    flippedTag.textContent = 'FLIPPED';
    panel.appendChild(flippedTag);

    const rotationDisplay = document.createElement('div');
    rotationDisplay.id = 'vr-rotation-display';
    rotationDisplay.className = 'hidden';
    Object.assign(rotationDisplay.style, { position:'absolute', left:'50%', bottom:'8px', transform:'translateX(-50%)', background:'rgba(0,0,0,.7)', color:'#fff', fontSize:'10px', borderRadius:'4px', padding:'2px 6px', zIndex:'15', pointerEvents:'auto', cursor:'pointer' });
    
    // Middle mouse click handler to toggle normal visualization
    panel.addEventListener('mousedown', async (e) => {
        if (e.button === 1) { // Middle mouse button
            e.preventDefault();
            e.stopPropagation();
            
            // Only toggle if we're in generated view mode and have a rendered cone
            if (showGeneratedView && currentRenderedCone) {
                showNormalsMode = !showNormalsMode;
                
                // Re-render with the new mode
                const renderResult = await render360SnapshotForCone(currentRenderedCone, markers, showNormalsMode);
                const renderURL = renderResult.dataURL;
                img.src = renderURL;
                setVRImage(renderURL, currentRenderedCone.name);
            }
        }
    });
    rotationDisplay.textContent = 'Rotation: 0.0Â°';
    panel.appendChild(rotationDisplay);
    // Tooltip for rotation apply action
    const rotTooltip = document.createElement('div');
    Object.assign(rotTooltip.style, { position:'absolute', left:'50%', bottom:'32px', transform:'translateX(-50%)', background:'rgba(0,0,0,.8)', color:'#fff', fontSize:'10px', borderRadius:'4px', padding:'3px 6px', opacity:'0', transition:'opacity .15s', pointerEvents:'none' });
    rotTooltip.textContent = 'Click to apply as offset';
    panel.appendChild(rotTooltip);

    // Custom resize handle (bottom-left)
    const handle = document.createElement('div');
    handle.id = 'vr-resize-handle';
    Object.assign(handle.style, { position:'absolute', left:'0', bottom:'0', width:'14px', height:'14px', background:'rgba(255,255,255,.6)', borderTopRightRadius:'6px', cursor:'sw-resize', zIndex:'20', pointerEvents:'auto' });
    panel.appendChild(handle);

    // Helper: ensure VR widget is visible
    function ensureVRWidgetVisible() {
        const widget = document.getElementById('vr-widget') as HTMLDivElement | null;
        if (widget) {
            widget.style.display = 'block';
        } else {
            const launcher = document.getElementById('vr-launcher') as HTMLButtonElement | null;
            launcher?.click();
        }
    }

    // Top-left resize handle + hover indicator (iPad-style)
    const handleTL = document.createElement('div');
    handleTL.id = 'vr-resize-handle-tl';
    Object.assign(handleTL.style, { position:'absolute', left:'0', top:'0', width:'14px', height:'14px', background:'rgba(255,255,255,.6)', borderBottomRightRadius:'6px', cursor:'nw-resize', zIndex:'20', pointerEvents:'auto' });
    panel.appendChild(handleTL);

    const tlHoverIndicator = document.createElement('div');
    Object.assign(tlHoverIndicator.style, {
        position: 'absolute',
        width: '34px',
        height: '6px',
        left: '-14px',
        top: '-14px',
        background: 'rgba(0,0,0,.18)',
        borderRadius: '9999px',
        transform: 'rotate(-45deg)',
        opacity: '0',
        transition: 'opacity .12s ease',
        pointerEvents: 'none'
    } as CSSStyleDeclaration);
    panel.appendChild(tlHoverIndicator);

    panel.addEventListener('mousemove', (e) => {
        const rect = panel.getBoundingClientRect();
        const dx = e.clientX - rect.left;
        const dy = e.clientY - rect.top;
        const nearTL = Math.hypot(dx, dy) < 28;
        tlHoverIndicator.style.opacity = nearTL ? '1' : '0';
        if (!isResizing) panel.style.cursor = nearTL ? 'nw-resize' : '';
    });

    handleTL.addEventListener('mousedown', function (e) {
        e.preventDefault();
        isResizing = true;
        startX = e.clientX;
        startY = e.clientY;
        const rect = panel.getBoundingClientRect();
        startWidth = rect.width;
        startHeight = rect.height;
        window.addEventListener('mousemove', resizePanel);
        window.addEventListener('mouseup', stopResize);
    });

    // Launcher toggles visibility and anchors panel
    vrLauncher.addEventListener('click', () => {
        const visible = vrWidget.style.display !== 'none';
        vrWidget.style.display = visible ? 'none' : 'block';
    });

    // Drag to move the widget
    let dragStart: { x: number; y: number; rx: number; by: number } | null = null;
    vrLauncher.addEventListener('mousedown', (e) => {
        dragStart = { x: e.clientX, y: e.clientY, rx: parseInt(vrWidget.style.right || '16'), by: parseInt(vrWidget.style.bottom || '16') };
        (document.body as any).style.userSelect = 'none';
    });
    window.addEventListener('mousemove', (e) => {
        if (!dragStart) return;
        const dx = e.clientX - dragStart.x;
        const dy = e.clientY - dragStart.y;
        vrWidget.style.right = Math.max(8, dragStart.rx - dx) + 'px';
        vrWidget.style.bottom = Math.max(8, dragStart.by - dy) + 'px';
    });
    window.addEventListener('mouseup', () => {
        dragStart = null;
        (document.body as any).style.userSelect = '';
    });

    let isResizing = false;
    let startX, startY, startWidth, startHeight;

    handle.addEventListener("mousedown", function (e) {
        e.preventDefault();
        isResizing = true;

        // record starting mouse coords and panel size
        startX = e.clientX;
        startY = e.clientY;
        const rect = panel.getBoundingClientRect();
        startWidth = rect.width;
        startHeight = rect.height;

        window.addEventListener("mousemove", resizePanel);
        window.addEventListener("mouseup", stopResize);
    });

    // // 1) Spawn the worker (once, at module load)
    // const compressor = new Worker("compressor.worker.js");

    // // Map to hold pending promises
    // const pending = new Map();

    // // 2) Handle responses from Worker
    // compressor.onmessage = (e) => {
    //     const { id, buffer } = e.data;
    //     const { resolve } = pending.get(id);
    //     pending.delete(id);
    //     resolve(buffer); // hand back the raw JPEG bytes
    // };

    // // 3) Helper to offload JPEG encode
    // function encodeJPEGOffthread(canvas, quality = 0.8) {
    //     return new Promise(async (resolve, reject) => {
    //         try {
    //             // Create a small unique ID for this request
    //             const id = crypto.randomUUID();
    //             // Snapshot to an ImageBitmap (transferable)
    //             const bitmap = await createImageBitmap(canvas);
    //             // Store promise callbacks
    //             pending.set(id, { resolve, reject });
    //             // Post to worker
    //             compressor.postMessage({ id, imageBitmap: bitmap, quality }, [
    //                 bitmap,
    //             ]);
    //         } catch (err) {
    //             reject(err);
    //         }
    //     });
    // }

    function clearAllData() {
        // Clear selected reversed faces
        selectedReversedFaceIds.clear();
        selectedReversedFacesGroup.children.slice().forEach(child => {
            selectedReversedFacesGroup.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
        // 1) Remove all dynamic scene children except axes & lights
        scene.children.slice().forEach((child) => {
            const t = child.type;
            const n = child.name;
            if (
                t !== "AxesHelper" &&
                t !== "AmbientLight" &&
                t !== "DirectionalLight" &&
                n !== "X-Axis" &&
                n !== "Y-Axis" &&
                n !== "Z-Axis" &&
                n !== "SelectedReversedFacesHighlights"
            ) {
                scene.remove(child);
            }
        });

        // 2) Reset your tracking arrays and clear image storage
        objects.length = 0;
        markers.length = 0;
        VRSpheres.length = 0;
        imageArray.length = 0;
        imageManager.clear(); // Clear persistent image storage
        VRRef.length = 0;
        simplifiedNamesId.length = 0;
        csvGroups.length = 0;
        fbxFiles.length = 0;
        glbFiles.length = 0;
        globalFloors.length = 0;

        // 3) Clear HTML overlays and canvas pool
        document.getElementById("marker-label-container").innerHTML = "";
        document.getElementById("outliner").innerHTML = "";
        document.getElementById("alignment-popup").classList.add("hidden");
        canvasPool.cleanup(); // Clean up canvas pool


        console.log("Scene and data cleared.");
    }

    // Re-wire your button
    document
        .getElementById("clear-all-data")
        .addEventListener("click", clearAllData);

    // Wire up the button
    document
        .getElementById("clear-all-data")
        .addEventListener("click", clearAllData);

    // Wire up the navigation button
    document
        .getElementById("next-csv-point")
        .addEventListener("click", () => {
            const widget = document.getElementById('vr-widget') as HTMLDivElement;
            if (widget) widget.style.display = 'block';
            navigateToNextCsvPoint().catch(console.error);
        });

    function resizePanel(e) {
        if (!isResizing) return;
        const fromTL = (panel.style.cursor === 'nw-resize');
        // delta width depends on which corner is dragged
        const deltaX = fromTL ? (startX - e.clientX) : (startX - e.clientX);
        let newWidth = startWidth + deltaX;
        const minW = 150;
        if (newWidth < minW) newWidth = minW;
        // enforce 2:1 ratio â†’ height = width / 2
        let newHeight = newWidth / 2;
        const minH = minW / 2;
        if (newHeight < minH) {
            newHeight = minH;
            newWidth = newHeight * 2;
        }
        panel.style.width = `${newWidth}px`;
        panel.style.height = `${newHeight}px`;
    }

    function stopResize() {
        if (!isResizing) return;
        isResizing = false;
        window.removeEventListener("mousemove", resizePanel);
        window.removeEventListener("mouseup", stopResize);
    }

    // Initialize the GLTFLoader
    const GLTFloader = new GLTFLoader();
    const FBXloader = new FBXLoader();
    const dracoLoader = new DRACOLoader();
    // Set the path to the Draco decoder
    // dracoLoader.setDecoderConfig({ type: 'js' });
    dracoLoader.setDecoderPath("/draco/decoder/");
    dracoLoader.preload();
    GLTFloader.setDRACOLoader(dracoLoader);

    var arrowAsset;
    GLTFloader.load("/Arrow.glb", (e) => {
        // Preload Arrow asset
        console.log("Arrow asset loaded");
        arrowAsset = e;
    });

    const scene = new THREE.Scene();
    
    // Group for selected reversed face highlights
    const selectedReversedFacesGroup = new THREE.Group();
    selectedReversedFacesGroup.name = "SelectedReversedFacesHighlights";
    selectedReversedFacesGroup.visible = true;
    scene.add(selectedReversedFacesGroup);
    
    // Store selected reversed face IDs
    let selectedReversedFaceIds = new Set();
    // Track last clicked/selected camera marker
    let currentSelectedCone = null;
    
    // Persistent image storage system for random access
    class ImageManager {
        imageIndex: Map<string, any>;
        compressionCache: Map<string, any>;
        maxImageSize: number;
        maxCacheSize: number;
        compressionQueue: Set<string>;
        stats: {
            totalImages: number;
            cacheHits: number;
            cacheMisses: number;
            compressionTime: number;
        };

        constructor(maxImageSize = 1024) {
            this.imageIndex = new Map(); // Lightweight index of all images
            this.compressionCache = new Map(); // Recently compressed images
            this.maxImageSize = maxImageSize;
            this.maxCacheSize = 20; // Only cache 20 compressed images
            this.compressionQueue = new Set(); // Track what's being compressed
            this.stats = {
                totalImages: 0,
                cacheHits: 0,
                cacheMisses: 0,
                compressionTime: 0
            };
        }

        async compressImage(originalData, filename, targetSize = 'medium', quality = 0.7) {
            const startTime = performance.now();
            
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Define size targets for different quality levels
                    const sizeTargets = {
                        thumbnail: 256,   // For previews/lists
                        medium: 1024,     // For normal viewing
                        large: 2048       // For detailed viewing
                    };
                    
                    const maxSize = sizeTargets[targetSize] || this.maxImageSize;
                    
                    // Calculate new dimensions while maintaining aspect ratio
                    let { width, height } = img;
                    if (width > maxSize || height > maxSize) {
                        const ratio = Math.min(maxSize / width, maxSize / height);
                        width = Math.round(width * ratio);
                        height = Math.round(height * ratio);
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to JPEG for smaller file size
                    const compressedData = canvas.toDataURL('image/jpeg', quality);
                    
                    const endTime = performance.now();
                    this.stats.compressionTime += (endTime - startTime);
                    
                    resolve({
                        name: filename,
                        image: compressedData,
                        originalSize: { width: img.width, height: img.height },
                        compressedSize: { width, height },
                        quality: targetSize,
                        compressionTime: endTime - startTime
                    });
                };
                img.src = originalData;
            });
        }

        async addImage(filename, originalImageData) {
            const key = filename.toLowerCase();
            
            // Store in lightweight index (no compression yet)
            this.imageIndex.set(key, {
                name: filename,
                originalData: originalImageData,
                addedAt: Date.now(),
                accessed: 0
            });
            
            this.stats.totalImages++;
            if (this.stats.totalImages % 50 === 0 || this.stats.totalImages <= 10) {
                console.log(`ðŸ“ Image indexed: ${filename} (Total: ${this.stats.totalImages})`);
            }
            this.updateStatsDisplay();
            
            // Return a lazy-loading wrapper
            return {
                name: filename,
                image: null, // Will be loaded on demand
                isLazy: true,
                originalData: originalImageData
            };
        }

        async getImageOnDemand(filename, quality = 'medium') {
            const key = filename.toLowerCase();
            const cacheKey = `${key}_${quality}`;
            
            // Check if compressed version is already cached
            if (this.compressionCache.has(cacheKey)) {
                this.stats.cacheHits++;
                const cached = this.compressionCache.get(cacheKey);
                // Move to end (simple LRU for compressed cache only)
                this.compressionCache.delete(cacheKey);
                this.compressionCache.set(cacheKey, cached);
                this.updateStatsDisplay();
                return cached;
            }
            
            // Get original from index
            const indexed = this.imageIndex.get(key);
            if (!indexed) {
                return null;
            }
            
            // Check if already being compressed
            if (this.compressionQueue.has(cacheKey)) {
                // Wait for existing compression to complete
                while (this.compressionQueue.has(cacheKey)) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                return this.compressionCache.get(cacheKey) || null;
            }
            
            // Start compression
            this.compressionQueue.add(cacheKey);
            this.stats.cacheMisses++;
            
            try {
                const compressed = await this.compressImage(indexed.originalData, filename, quality);
                
                // Manage cache size (simple FIFO for compressed images)
                if (this.compressionCache.size >= this.maxCacheSize) {
                    const firstKey = this.compressionCache.keys().next().value;
                    this.compressionCache.delete(firstKey);
                }
                
                this.compressionCache.set(cacheKey, compressed);
                indexed.accessed++;
                
                this.compressionQueue.delete(cacheKey);
                this.updateStatsDisplay();
                return compressed;
                
            } catch (error) {
                this.compressionQueue.delete(cacheKey);
                console.error(`Failed to compress ${filename}:`, error);
                return null;
            }
        }

        async findImageByName(targetName, quality = 'medium') {
            const lowerTarget = targetName.toLowerCase();
            
            // Search through index (not cache) with precise matching
            for (const [key, indexed] of this.imageIndex) {
                const keyWithoutExt = key.replace(/\.[^/.]+$/, "");
                const targetWithoutExt = lowerTarget.replace(/\.[^/.]+$/, "");
                
                // Exact match (with or without extension)
                if (key === lowerTarget || keyWithoutExt === targetWithoutExt) {
                    return await this.getImageOnDemand(indexed.name, quality);
                }
                
                // Check if the image filename ends with the target name
                // This handles cases like "image_360_prefix_0_livingroom_10.jpg" matching "0_livingroom_10"
                if (keyWithoutExt.endsWith('_' + targetWithoutExt) || keyWithoutExt.endsWith(targetWithoutExt)) {
                    return await this.getImageOnDemand(indexed.name, quality);
                }
                
                // Additional check: see if target appears as a complete segment in the key
                // Split both by underscores and check for exact segment matches
                const keyParts = keyWithoutExt.split('_');
                const targetParts = targetWithoutExt.split('_');
                
                // Look for a sequence in keyParts that exactly matches all targetParts
                for (let i = 0; i <= keyParts.length - targetParts.length; i++) {
                    let sequenceMatch = true;
                    for (let j = 0; j < targetParts.length; j++) {
                        if (keyParts[i + j] !== targetParts[j]) {
                            sequenceMatch = false;
                            break;
                        }
                    }
                    if (sequenceMatch) {
                        return await this.getImageOnDemand(indexed.name, quality);
                    }
                }
            }
            
            console.warn(`No image found for target: ${targetName}`);
            console.log('Available images:', Array.from(this.imageIndex.keys()).slice(0, 10), '...');
            return null;
        }

        // Legacy method for compatibility
        getImage(filename) {
            // For immediate access, return cached version or null
            const key = filename.toLowerCase();
            const cacheKey = `${key}_medium`;
            return this.compressionCache.get(cacheKey) || null;
        }

        cleanupCompressedCache() {
            // Simple cleanup - remove oldest compressed images if cache is full
            if (this.compressionCache.size >= this.maxCacheSize) {
                const toRemove = Math.floor(this.maxCacheSize * 0.3);
                let removed = 0;
                
                for (const [key] of this.compressionCache) {
                    if (removed >= toRemove) break;
                    this.compressionCache.delete(key);
                    removed++;
                }
                
                console.log(`Compressed cache cleanup: Removed ${removed} cached images`);
            }
            this.updateStatsDisplay();
        }

        clear() {
            this.imageIndex.clear();
            this.compressionCache.clear();
            this.compressionQueue.clear();
            this.stats = {
                totalImages: 0,
                cacheHits: 0,
                cacheMisses: 0,
                compressionTime: 0
            };
            this.updateStatsDisplay();
        }

        // Fast indexing for large image sets (no compression during load)
        async indexBatch(imageDataArray, batchSize = 50) {
            const totalImages = imageDataArray.length;
            let processed = 0;
            
            // Show progress bar for large batches
            const showProgress = totalImages > 20;
            if (showProgress) {
                document.getElementById('loading-progress').classList.remove('hidden');
            }
            
            console.log(`Indexing ${totalImages} images in batches of ${batchSize} (no compression)`);
            
            for (let i = 0; i < imageDataArray.length; i += batchSize) {
                const batch = imageDataArray.slice(i, i + batchSize);
                
                // Index batch synchronously (very fast)
                batch.forEach(imageData => {
                    try {
                        const indexed = this.addImage(imageData.name, imageData.data);
                        imageArray.push(indexed);
                    } catch (error) {
                        console.error(`Failed to index image ${imageData.name}:`, error);
                    }
                });
                
                processed += batch.length;
                
                // Update progress
                if (showProgress) {
                    const progress = Math.round((processed / totalImages) * 100);
                    document.getElementById('progress-bar').style.width = `${progress}%`;
                    document.getElementById('progress-text').textContent = 
                        `Indexing images... ${processed}/${totalImages} (${progress}%)`;
                }
                
                // Very small delay to allow UI updates
                if (i + batchSize < imageDataArray.length) {
                    await new Promise(resolve => setTimeout(resolve, 5));
                }
            }
            
            // Hide progress bar
            if (showProgress) {
                setTimeout(() => {
                    document.getElementById('loading-progress').classList.add('hidden');
                }, 500);
            }
            
            console.log(`âœ… Completed indexing ${processed} images instantly! Images will compress on-demand.`);
            return processed;
        }

                 getStats() {
            const totalAccesses = this.stats.cacheHits + this.stats.cacheMisses;
            const hitRate = totalAccesses > 0 ? Math.round((this.stats.cacheHits / totalAccesses) * 100) : 100;
            const avgCompressionTime = this.stats.cacheMisses > 0 ? 
                Math.round(this.stats.compressionTime / this.stats.cacheMisses) : 0;
            
            return {
                totalImages: this.stats.totalImages,
                cachedImages: this.compressionCache.size,
                maxCacheSize: this.maxCacheSize,
                hitRate: hitRate,
                totalAccesses: totalAccesses,
                avgCompressionTime: avgCompressionTime,
                memoryUsage: `${Math.round((this.compressionCache.size / this.maxCacheSize) * 100)}%`
            };
        }

        updateStatsDisplay() {
            const stats = this.getStats();
            const statsElement = document.getElementById('image-cache-stats');
            if (statsElement) {
                const hitRateColor = stats.hitRate > 80 ? 'green' : stats.hitRate > 50 ? 'orange' : 'red';
                
                statsElement.innerHTML = `
                    <p>Total: ${stats.totalImages} images</p>
                    <p>Cached: ${stats.cachedImages}/${stats.maxCacheSize}</p>
                    <p>Hit Rate: <span style="color: ${hitRateColor}">${stats.hitRate}%</span></p>
                    <p>Avg Load: ${stats.avgCompressionTime}ms</p>
                `;
            }
        }
    }

    // Initialize persistent image manager
    console.log(`Initializing persistent image storage system for random access`);
    const imageManager = new ImageManager(1024); // Only need max image size
    var imageArray = []; // Keep for backward compatibility
    var VRRef = [];
    var VRSpheres = [];
    var objects = [];
    var markers = [];
    let labelContainer;
    let referenceSelection = [];
    let alignSelection = [];

    const renderer = new THREE.WebGLRenderer({ 
        antialias: false, 
        alpha: true,
        powerPreference: "high-performance"
    });
    renderer.autoClear = false;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio
    renderer.setSize(window.innerWidth, window.innerHeight);
    if ((renderer as any).shadowMap) {
        (renderer as any).shadowMap.enabled = false; // Disable shadows for better performance
    }
    // Ensure canvas displays correctly
    renderer.domElement.style.display = 'block';
    document.body.appendChild(renderer.domElement);

    const orthoRenderer = new THREE.WebGLRenderer({
        antialias: false,
        alpha: true,
        powerPreference: "high-performance"
    });
    orthoRenderer.autoClear = false;
    orthoRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio
    if ((orthoRenderer as any).shadowMap) {
        (orthoRenderer as any).shadowMap.enabled = false; // Disable shadows for better performance
    }
    const orthoView = document.getElementById("orthoView") as HTMLDivElement;
    orthoRenderer.setSize(orthoView.clientWidth, orthoView.clientHeight);
    document.getElementById("orthoView").appendChild(orthoRenderer.domElement);

    // Explicit resize listener for renderer pixel ratio and size updates
    window.addEventListener("resize", () => {
        // Update renderer pixel ratio and size
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        // Update camera aspect ratio to prevent squashing
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        
        // Update orthographic camera
        orthoCamera.left = window.innerWidth / -0.1;
        orthoCamera.right = window.innerWidth / 0.1;
        orthoCamera.top = window.innerHeight / 0.1;
        orthoCamera.bottom = window.innerHeight / -0.1;
        orthoCamera.updateProjectionMatrix();
        
        // Update orthographic renderer
        orthoRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        updateGizmoSize();
    });

    // Blender-like 3D Gizmo (rendered inside #orthoView)
    const gizmoScene = new THREE.Scene();
    const gizmoCamera = new THREE.PerspectiveCamera(
        18,
        Math.max(1, orthoView.clientWidth) / Math.max(1, orthoView.clientHeight),
        0.1,
        10
    );
    gizmoCamera.position.set(0, 0, 5.0);

    const gizmoRoot = new THREE.Object3D();
    gizmoRoot.scale.setScalar(0.75); // scale down slightly to avoid clipping
    gizmoScene.add(gizmoRoot);

    // 2D overlay for screen-space rendering
    orthoView.style.position = 'relative';
    const gizmoOverlay = document.createElement('canvas');
    gizmoOverlay.style.position = 'absolute';
    gizmoOverlay.style.left = '0';
    gizmoOverlay.style.top = '0';
    gizmoOverlay.style.width = '100%';
    gizmoOverlay.style.height = '100%';
    gizmoOverlay.style.pointerEvents = 'none';
    orthoView.appendChild(gizmoOverlay);
    const overlayCtx = gizmoOverlay.getContext('2d')!;

    type SphereDesc = { mesh: THREE.Mesh, baseColor: number, axisKey: 'X'|'Y'|'Z', sign: '+'|'-', radiusWorld: number };
    const handleSpheres: SphereDesc[] = [];
    let gizmoLocalRadius = 0; // in gizmo local units
    const positiveSphereByAxis: Record<string, THREE.Mesh> = {} as any;

    function buildAxis(axis: THREE.Vector3, color: number, axisKey: 'X' | 'Y' | 'Z') {
        const axisGroup = new THREE.Group();
        const length = 0.65; // bring spheres even closer
        const radius = 0.012; // thinner line
        const sphereRadius = 0.085 * 2.0; // larger spheres

        const cylinderGeo = new THREE.CylinderGeometry(radius, radius, length, 16);
        const cylinderMat = new THREE.MeshBasicMaterial({ color });
        const cylinder = new THREE.Mesh(cylinderGeo, cylinderMat);
        cylinder.matrixAutoUpdate = true;
        // orient cylinder (default +Y) to the desired axis
        const q = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), axis.clone().normalize());
        cylinder.quaternion.copy(q);
        // shift so it starts at origin and extends to +axis direction only
        const half = length / 2;
        const dir = axis.clone().normalize();
        cylinder.position.copy(dir.clone().multiplyScalar(half));
        axisGroup.add(cylinder);

        const sphereGeo = new THREE.SphereGeometry(sphereRadius, 24, 24);
        const matPos = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.0 });
        const matNeg = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.0 });

        const posSphere = new THREE.Mesh(sphereGeo, matPos);
        posSphere.position.copy(dir.clone().multiplyScalar(length));
        posSphere.name = axisKey + '+';
        posSphere.renderOrder = 10;
        axisGroup.add(posSphere);

        // add negative sphere (not connected by a line)
        const negSphere = new THREE.Mesh(sphereGeo, matNeg);
        negSphere.position.copy(dir.clone().multiplyScalar(-length));
        negSphere.name = axisKey + '-';
        negSphere.renderOrder = 10;
        axisGroup.add(negSphere);

        // track for gray tinting based on camera facing
        handleSpheres.push({ mesh: posSphere, baseColor: color, axisKey, sign: '+', radiusWorld: sphereRadius });
        handleSpheres.push({ mesh: negSphere, baseColor: color, axisKey, sign: '-', radiusWorld: sphereRadius });

        positiveSphereByAxis[axisKey] = posSphere as any;

        // track max radius (axis length + sphere radius) in local space
        gizmoLocalRadius = Math.max(gizmoLocalRadius, length + sphereRadius);

        gizmoRoot.add(axisGroup);
    }

    // Solid unlit axes with attached endpoint spheres
    buildAxis(new THREE.Vector3(1, 0, 0), 0xff8080, 'X');
    buildAxis(new THREE.Vector3(0, 1, 0), 0x80ff8c, 'Y');
    buildAxis(new THREE.Vector3(0, 0, 1), 0x74c8ff, 'Z'); 

    // Gizmo interaction: click on handles to snap camera
    const gizmoRaycaster = new THREE.Raycaster();
    const gizmoPointer = new THREE.Vector2();

    function snapCameraTo(label) {
        const target = orbitalControls.target.clone();
        const currentDistance = (typeof orbitalControls.getDistance === 'function')
            ? orbitalControls.getDistance()
            : camera.position.distanceTo(target);
        const pos = new THREE.Vector3();
        switch (label) {
            case "X+": pos.set( currentDistance, 0, 0); break;
            case "X-": pos.set(-currentDistance, 0, 0); break;
            case "Y+": pos.set(0,  currentDistance, 0); break;
            case "Y-": pos.set(0, -currentDistance, 0); break;
            case "Z+": pos.set(0, 0,  currentDistance); break;
            case "Z-": pos.set(0, 0, -currentDistance); break;
            default: return;
        }
        gsap.to(camera.position, {
            x: target.x + pos.x,
            y: target.y + pos.y,
            z: target.z + pos.z,
            duration: 0.5,
            ease: "power2.out",
            onUpdate: () => {
                orbitalControls.target.copy(target);
                orbitalControls.update();
            }
        });
    }

    orthoView.addEventListener('click', (ev) => {
        if (gizmoDragging) return; // don't treat end of drag as a click
        const rect = orthoView.getBoundingClientRect();
        const x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
        gizmoPointer.set(x, y);
        gizmoRaycaster.setFromCamera(gizmoPointer, gizmoCamera);
        const hits = gizmoRaycaster.intersectObjects(gizmoRoot.children, true);
        const handle = hits.find(h => typeof h.object.name === 'string' && /^[XYZ][+-]$/.test(h.object.name));
        if (handle) snapCameraTo(handle.object.name);
    });

    function updateGizmoSize() {
        const rect = orthoView.getBoundingClientRect();
        const w = Math.max(1, rect.width);
        const h = Math.max(1, rect.height);
        orthoRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio
        orthoRenderer.setSize(w, h);
        gizmoCamera.aspect = w / h;
        gizmoCamera.updateProjectionMatrix();
    }
    updateGizmoSize();

    // Drag to orbit main camera using the gizmo area
    let gizmoDragging = false;
    let gizmoLast = { x: 0, y: 0 };
    orthoView.style.cursor = 'grab';
    orthoView.addEventListener('mousedown', (ev: MouseEvent) => {
        gizmoDragging = true;
        gizmoLast.x = ev.clientX;
        gizmoLast.y = ev.clientY;
        orthoView.style.cursor = 'grabbing';
    });
    window.addEventListener('mousemove', (ev: MouseEvent) => {
        if (!gizmoDragging) return;
        const dx = ev.clientX - gizmoLast.x;
        const dy = ev.clientY - gizmoLast.y;
        gizmoLast.x = ev.clientX;
        gizmoLast.y = ev.clientY;

        const yaw = -dx * 0.005;
        const pitch = -dy * 0.005;

        const target = orbitalControls.target.clone();
        const offset = (camera as any).position.clone().sub(target);
        const spherical = new THREE.Spherical();
        spherical.setFromVector3(offset);
        spherical.theta += yaw;
        spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi + pitch));
        offset.setFromSpherical(spherical);
        (camera as any).position.copy(target.clone().add(offset));
        camera.lookAt(target);
        orbitalControls.update();
    });
    window.addEventListener('mouseup', () => {
        gizmoDragging = false;
        orthoView.style.cursor = 'grab';
    });

    //Manipulatable Group
    var m_Group;

    //Infinite Axis Lines
    function createInfiniteAxisLines() {
        const axisLength = 100000; // Large enough to appear infinite
        
        // Create X-axis with unit indicators baked in
        const xPoints = [
            new THREE.Vector3(-axisLength, 0, 0),
            new THREE.Vector3(axisLength, 0, 0)
        ];
        
        // Add unit tick marks to X-axis geometry
        const xUnits = [1, 10, 100];
        xUnits.forEach(unit => {
            [-unit, unit].forEach(value => {
                xPoints.push(new THREE.Vector3(value, -0.5, 0));
                xPoints.push(new THREE.Vector3(value, 0.5, 0));
            });
        });
        
        const xGeometry = new THREE.BufferGeometry().setFromPoints(xPoints);
        const xMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const xLine = new THREE.Line(xGeometry, xMaterial);
        xLine.name = "X-Axis";
        scene.add(xLine);
        
        // Y-axis (Green) - no unit indicators needed for top-down view
        const yGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -axisLength, 0),
            new THREE.Vector3(0, axisLength, 0)
        ]);
        const yMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        const yLine = new THREE.Line(yGeometry, yMaterial);
        yLine.name = "Y-Axis";
        scene.add(yLine);
        
        // Create Z-axis with unit indicators baked in
        const zPoints = [
            new THREE.Vector3(0, 0, -axisLength),
            new THREE.Vector3(0, 0, axisLength)
        ];
        
        // Add unit tick marks to Z-axis geometry
        const zUnits = [1, 10, 100];
        zUnits.forEach(unit => {
            [-unit, unit].forEach(value => {
                zPoints.push(new THREE.Vector3(0, -0.5, value));
                zPoints.push(new THREE.Vector3(0, 0.5, value));
            });
        });
        
        const zGeometry = new THREE.BufferGeometry().setFromPoints(zPoints);
        const zMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
        const zLine = new THREE.Line(zGeometry, zMaterial);
        zLine.name = "Z-Axis";
        scene.add(zLine);
    }
    
    createInfiniteAxisLines();

    //Lights
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    scene.add(directionalLight);

    const light = new THREE.AmbientLight(0x404040);
    scene.add(light);

    //Camera
    const camera = new THREE.PerspectiveCamera(
        110,
        window.innerWidth / window.innerHeight,
        0.1,
        800000,
    );
    (camera as any).position.x = -210.41;
    (camera as any).position.y = 1.31;
    (camera as any).position.z = 0;

    const orthoCamera = new THREE.OrthographicCamera(
        window.innerWidth / -0.1,  // Even wider view (was -0.5)
        window.innerWidth / 0.1,   // Even wider view (was 0.5)
        window.innerHeight / 0.1,  // Even taller view (was 0.5)
        window.innerHeight / -0.1, // Even taller view (was -0.5)
        0.1,
        80000,
    );
    // Set initial top-down position
    orthoCamera.position.set(0, 1000, 0); // High above the scene
    orthoCamera.lookAt(0, 0, 0); // Look down at the origin
    orthoCamera.up.set(0, 0, -1); // Set up vector for proper orientation

    // Rendering mode tracking
    let currentRenderingMode = 'perspective'; // 'perspective' or 'orthographic'
    let currentCamera = camera; // Active camera for main rendering
    
    // Orthographic mode panning controls
    let isOrthoPanning = false;
    let orthoPanStart = { x: 0, y: 0, cameraX: 0, cameraZ: 0 };

    // Function to switch rendering mode
    function switchRenderingMode(mode) {
        currentRenderingMode = mode;
        
        // Update tab UI
        const perspectiveTab = document.getElementById('perspective-tab');
        const orthographicTab = document.getElementById('orthographic-tab');
        
        if (mode === 'perspective') {
            perspectiveTab.className = 'flex-1 px-3 py-1 text-xs font-medium rounded-md transition-colors bg-white text-gray-900 shadow-sm';
            orthographicTab.className = 'flex-1 px-3 py-1 text-xs font-medium rounded-md transition-colors text-gray-600 hover:text-gray-900';
            currentCamera = camera;
            // Enable orbital controls for perspective mode
            orbitalControls.enabled = true;
            // Show orthoView gizmo in perspective mode
            document.getElementById('orthoView').style.display = 'block';
        } else {
            perspectiveTab.className = 'flex-1 px-3 py-1 text-xs font-medium rounded-md transition-colors text-gray-600 hover:text-gray-900';
            orthographicTab.className = 'flex-1 px-3 py-1 text-xs font-medium rounded-md transition-colors bg-white text-gray-900 shadow-sm';
            
            // Set orthographic camera to top-down view
            orthoCamera.position.set(0, 1000, 0); // High above the scene
            orthoCamera.lookAt(0, 0, 0); // Look down at the origin
            orthoCamera.up.set(0, 0, -1); // Set up vector for proper orientation
            
            currentCamera = orthoCamera;
            // Disable orbital controls for orthographic mode
            orbitalControls.enabled = false;
            // Hide orthoView gizmo in orthographic mode
            document.getElementById('orthoView').style.display = 'none';
        }
    }

    // Add event listeners for tab switching
    document.getElementById('perspective-tab').addEventListener('click', () => {
        switchRenderingMode('perspective');
    });

    document.getElementById('orthographic-tab').addEventListener('click', () => {
        switchRenderingMode('orthographic');
    });

    // Controls panel toggle functionality
    document.getElementById('controls-toggle').addEventListener('click', () => {
        const content = document.getElementById('controls-content');
        const arrow = document.getElementById('controls-arrow');
        
        if (content.style.display === 'none') {
            content.style.display = 'block';
            arrow.style.transform = 'rotate(0deg)';
        } else {
            content.style.display = 'none';
            arrow.style.transform = 'rotate(-90deg)';
        }
    });

    // UI panel toggle functionality
    document.getElementById('ui-toggle').addEventListener('click', () => {
        const arrow = document.getElementById('ui-arrow');
        const uiArea = document.getElementById('ui-area');
        
        if (uiArea.style.transform === 'translateX(-100%)') {
            // Show UI panel
            uiArea.style.transform = 'translateX(0)';
            arrow.textContent = 'â—€';
        } else {
            // Hide UI panel off-screen to the left
            uiArea.style.transform = 'translateX(-100%)';
            arrow.textContent = 'â–¶';
        }
    });

    //Mouse Raycaster Perspective
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    //Mouse Raycaster Orthographic
    const orthoRaycaster = new THREE.Raycaster();
    const orthoPointer = new THREE.Vector2();

    function onPointerMove(event) {
       /* If the pointer is over the outliner (or a child of it),
          don't run the viewport-hover logic â€“ let the outliner's
          own mouseenter/leave handlers manage the tooltip. */
       if (event.target.closest('#outliner')) {
           return;
       }
        /* 1â€Šâ€”â€Šturn any movement into a "hide" */
        hideTooltip();                // clears timer + fades out if visible

        /* 2â€Šâ€”â€Šupdate the pointer NDC */
        pointer.x =  (event.clientX / window.innerWidth ) * 2 - 1;
        pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

        /* helper to climb to the GLB root */
        function findGLBRoot(obj) {
            while (obj && obj !== scene) {
                if ((obj.name || "").toLowerCase().endsWith(".glb")) return obj;
                obj = obj.parent;
            }
            return null;
        }

        /* 3â€Šâ€”â€Šrayâ€‘cast and arm a NEW timer (only if cursor stays put) */
        raycaster.setFromCamera(pointer, camera);
        const firstHit = raycaster.intersectObjects(scene.children, true)[0];
        const hitRoot  = firstHit ? findGLBRoot(firstHit.object) : null;

        hoverObject = hitRoot;        // remember current object (may be null)

        /* 4 â€” check if hovering over a cone and disable/enable zoom accordingly */
        const coneHit = raycaster.intersectObjects(markers).find(i => i.object.cameraPos && i.object.parent.visible);
        if (coneHit) {
            // Hovering over a cone - disable zoom functionality
            orbitalControls.enableZoom = false;
            orbitalControls.enablePan = false;
            orbitalControls.enableRotate = false;
            renderer.domElement.style.cursor = 'pointer';
        } else {
            // Not hovering over a cone - enable zoom functionality
            orbitalControls.enableZoom = true;
            orbitalControls.enablePan = true;
            orbitalControls.enableRotate = true;
            renderer.domElement.style.cursor = 'default';
        }

        if (hoverObject) {
            hoverTimerId = setTimeout(() => {
                showTooltip(event.clientX, event.clientY,
                            "Double-click to refocus");
            }, 1000);   // 1â€¯s delay (set to 3000 for 3â€¯s)
        }
    }

    function handleFloors() {
        //Floor section
        //Dynamically add Floors section
        var floorNumbers = [];
        const labelDivInstance = document.getElementById("labelDiv");
        if (labelDivInstance) {
            labelDivInstance.remove();
        }
        globalFloors.forEach((e) => {
            // console.log("Pushing " + e.floor);
            if (!floorNumbers.includes(e.floor)) {
                floorNumbers.push(e.floor);
            }
        });

        // console.log(floorNumbers);
        // console.log(globalFloors);

        if (floorNumbers.length > 0) {
            const floorSection = document.getElementById("show-floors");
            // console.log(floorSection);
            if (floorSection.classList.contains("hidden")) {
                floorSection.classList.remove("hidden");
            }
            const listChild = floorSection.getElementsByTagName("*");
            // console.log(listChild);
            if (listChild.length > 0) {
                Array.from(listChild).forEach((element) => {
                    element.remove();
                });
            }

            const checkboxesId = [];

            floorNumbers.forEach((e) => {
                const div = document.createElement("div");
                const checkbox = document.createElement("input");
                const label = document.createElement("label");

                label.innerText = `Floor ${e}`;
                label.htmlFor = `floor-${e}-checkbox`;

                checkbox.type = "checkbox";
                checkbox.checked = true;
                checkbox.id = `floor-${e}-checkbox`;
                checkbox.setAttribute("class", "mr-1");

                checkboxesId.push(`floor-${e}-checkbox`);
                div.appendChild(checkbox);
                div.appendChild(label);
                div.setAttribute("class", "p-2 bg-zinc-100 rounded-sm mt-1");

                checkbox.addEventListener("change", (e) => {
                    // const g = globalSvgContainer.querySelector('g')
                    const selectedFloor = e.target.id.split("-")[1];
                    const selectedMarkers = globalFloors.filter(
                        (i) => i.floor == selectedFloor,
                    );

                    if (e.target.checked) {
                        selectedMarkers.forEach((e) => {
                            e.arrow.visible = true;
                        });
                    } else {
                        selectedMarkers.forEach((e) => {
                            e.arrow.visible = false;
                        });
                    }

                    createLabels();
                });

                floorSection.appendChild(div);
            });
        }
    }

let lastConeClicked = null;   // remembers which cone we clicked last
let showGeneratedView   = false;  // toggle state *for that cone only*
let showNormalsMode = false;  // toggle state for showing normals in equirectangular render
let currentRenderedCone = null;  // store the currently rendered cone for re-rendering

    // Function to add hoverable HTML elements over reversed faces
    function addReversedFaceHoverElements(panel, img, facePositions) {
        // Remove existing hover elements
        const existingHovers = panel.querySelectorAll('.reversed-face-hover');
        existingHovers.forEach(el => el.remove());
        
        if (!facePositions || facePositions.length === 0) return;
        
        // Wait for image to load to get actual dimensions
        const setupHovers = () => {
            const imgRect = img.getBoundingClientRect();
            const panelRect = panel.getBoundingClientRect();
            
            // Calculate scale factors
            const imgNaturalWidth = img.naturalWidth || 1024;
            const imgNaturalHeight = img.naturalHeight || 512;
            const imgDisplayWidth = imgRect.width;
            const imgDisplayHeight = imgRect.height;
            
            facePositions.forEach((facePos, index) => {
                // Create hover element
                const hoverEl = document.createElement('div');
                hoverEl.className = 'reversed-face-hover';
                hoverEl.style.position = 'absolute';
                hoverEl.style.width = '8px';
                hoverEl.style.height = '8px';
                hoverEl.style.borderRadius = '50%';
                hoverEl.style.backgroundColor = 'rgba(255, 0, 0, 0.6)';
                hoverEl.style.border = '1px solid rgba(255, 0, 0, 0.9)';
                hoverEl.style.cursor = 'pointer';
                hoverEl.style.zIndex = '10';
                hoverEl.style.transition = 'all 0.2s ease';
                hoverEl.style.pointerEvents = 'auto';
                
                // Position relative to image
                const x = (facePos.x / imgNaturalWidth) * imgDisplayWidth;
                const y = (facePos.y / imgNaturalHeight) * imgDisplayHeight;
                
                // Account for image positioning within panel
                const imgOffsetX = (imgRect.left - panelRect.left);
                const imgOffsetY = (imgRect.top - panelRect.top);
                
                hoverEl.style.left = `${imgOffsetX + x - 4}px`;
                hoverEl.style.top = `${imgOffsetY + y - 4}px`;
                
                // Tooltip content
                const tooltip = document.createElement('div');
                tooltip.className = 'reversed-face-tooltip';
                tooltip.style.position = 'absolute';
                tooltip.style.bottom = '100%';
                tooltip.style.left = '50%';
                tooltip.style.transform = 'translateX(-50%)';
                tooltip.style.marginBottom = '5px';
                tooltip.style.padding = '4px 8px';
                tooltip.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                tooltip.style.color = '#fff';
                tooltip.style.fontSize = '10px';
                tooltip.style.borderRadius = '4px';
                tooltip.style.whiteSpace = 'nowrap';
                tooltip.style.pointerEvents = 'none';
                tooltip.style.opacity = '0';
                tooltip.style.transition = 'opacity 0.2s ease';
                tooltip.textContent = `Reversed Normal ${index + 1}`;
                hoverEl.appendChild(tooltip);
                
                // Hover effects
                hoverEl.addEventListener('mouseenter', () => {
                    hoverEl.style.backgroundColor = 'rgba(255, 0, 0, 0.9)';
                    hoverEl.style.transform = 'scale(1.5)';
                    tooltip.style.opacity = '1';
                });
                
                hoverEl.addEventListener('mouseleave', () => {
                    hoverEl.style.backgroundColor = 'rgba(255, 0, 0, 0.6)';
                    hoverEl.style.transform = 'scale(1)';
                    tooltip.style.opacity = '0';
                });
                
                panel.appendChild(hoverEl);
            });
        };
        
        // Setup hovers when image loads or if already loaded
        if (img.complete && img.naturalWidth > 0) {
            setupHovers();
        } else {
            img.onload = setupHovers;
        }
    }

async function reviewVR(event) {
    const intersects = raycaster.intersectObjects(markers);
    const hit = intersects.find(i => i.object.cameraPos && i.object.parent.visible);
    if (!hit) return;

    const cone       = hit.object;
    const panel      = document.getElementById("vr-image-panel");
    const img        = document.getElementById("vr-img") as HTMLImageElement;
    const flippedTag = document.getElementById("vr-flipped-tag") as HTMLDivElement;
    const targetName = cone.name.toLowerCase();

    // Update currentCsvIndex to match the clicked cone
    const coneIndex = csvPoints.findIndex(point => point === cone);
    if (coneIndex !== -1) {
        currentCsvIndex = coneIndex;
        console.log(`Updated currentCsvIndex to ${currentCsvIndex} for cone: ${cone.name}`);
        // Update the Next Point button text to reflect the current index
        updateNavigationDisplay();
    }

    // Helper function to apply flipping based on image name
    function applyImageFlipping(imageName) {
        const shouldFlip = imageName.toLowerCase().includes("bf") || imageName.toLowerCase().includes("sf");
        
        if (shouldFlip) {
            img.style.transform = "scaleX(-1)";
            flippedTag.classList.remove("hidden");
        } else {
            img.style.transform = "scaleX(1)";
            flippedTag.classList.add("hidden");
        }
    }

    /* â”€â”€â”€â”€â”€ decide which view to show â”€â”€â”€â”€â”€ */
    // First check if 360 image is available - if so, always show photo mode (disable collision render)
    const entry = await imageManager.findImageByName(targetName, 'medium').catch(() => null);
    const has360Image = !!entry;
    
    if (has360Image) {
        // When 360 images are available, always show photo mode (disable collision render toggle)
        if (cone !== lastConeClicked) {
            lastConeClicked = cone;
        }
        showGeneratedView = false;  // Force photo mode when 360 images are available
        showNormalsMode = false;
        
        // Load and display the 360 image immediately
        try {
            // Show loading indicator
            img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23666'%3ELoading...%3C/text%3E%3C/svg%3E";
            panel.classList.remove("hidden");
            
            img.src = entry.image;
            
            // Set up rotation for equirectangular image
            setVRImage(entry.image, entry.name);
            // Ensure floating widget is visible when an image is loaded
            const widget = document.getElementById('vr-widget') as HTMLDivElement;
            if (widget) widget.style.display = 'block';
            
            // Render collision overlay as a semi-transparent overlay on top of the 360 image
            // This allows comparison between the 360 image and the collision model render
            await renderOverlayCanvas(cone);
            vrOverlayCanvas.style.display = 'block';
            vrOverlayCanvas.style.opacity = '0.45';
            
            // Apply flipping based on the image entry name
            applyImageFlipping(entry.name);
            
            // Early return to prevent any collision render from replacing the 360 image
            return;
        } catch (error) {
            console.error(`Error loading image ${targetName}:`, error);
            // Show error state but keep panel visible
            img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23ff0000'%3EError loading image%3C/text%3E%3C/svg%3E";
            return;
        }
    } else {
        // Only allow toggle when no 360 images are available
        if (cone !== lastConeClicked) {          // new cone â†’ always start in photo mode
            lastConeClicked = cone;
            showGeneratedView = false;
            showNormalsMode = false;  // Reset normals mode when switching cones
        } else {
            showGeneratedView = !showGeneratedView;      // same cone â†’ toggle back / forth
            if (!showGeneratedView) {
                showNormalsMode = false;  // Reset normals mode when switching to photo view
            }
        }
    }

    // Only render collision as main image if no 360 image is available AND toggle is on
    if (showGeneratedView && !has360Image) {
        console.log(cone)
        currentRenderedCone = cone;  // Store the current cone for re-rendering
        const renderResult = await render360SnapshotForCone(cone, markers, showNormalsMode);
        const renderURL = renderResult.dataURL;
        const facePositions = renderResult.facePositions || [];
        
        img.src = renderURL;
        
        // Set up rotation for generated view
        setVRImage(renderURL, cone.name);
        // Ensure floating widget is visible when a cone is clicked
        const widget = document.getElementById('vr-widget') as HTMLDivElement;
        if (widget) widget.style.display = 'block';
        
        // Hide overlay for generated views (since we're already showing the rendered view)
        vrOverlayCanvas.style.display = 'none';
        
        // Add hoverable elements for reversed faces (disabled for performance)
        // addReversedFaceHoverElements(panel, img, facePositions);
        
        // For generated views, check cone name for flipping
        applyImageFlipping(cone.name);
        panel.classList.remove("hidden");
    } else {
        // No 360 image available - show collision render or overlay based on toggle state
        try {
            // Show loading indicator
            img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23666'%3ELoading...%3C/text%3E%3C/svg%3E";
            panel.classList.remove("hidden");
            
            // No 360 image available - render collision overlay instead
            // Reset states but DO NOT auto-hide the floating panel
            img.style.transform = "scaleX(1)";
            flippedTag.classList.add("hidden");
            vrDragOverlay.classList.add("hidden");
            vrRotationDisplay.classList.add("hidden");
            
            // Prepare overlay and show it for comparison (collision render)
            await renderOverlayCanvas(cone);
            vrOverlayCanvas.style.display = 'block';
            vrOverlayCanvas.style.opacity = '0.45';
            
            console.warn(`Image not found: ${targetName}, using collision render overlay`);
        } catch (error) {
            console.error(`Error loading image ${targetName}:`, error);
            // Show error state but keep panel visible
            img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23ff0000'%3EError loading image%3C/text%3E%3C/svg%3E";
        }
    }

}

async function renderOverlayCanvas(cone) {
    if (!vrOverlayCanvas || !cone) {
        console.warn('Missing overlay canvas or cone');
        return;
    }
    
    try {
    // Set overlay canvas size to match the panel
    const panel = document.getElementById("vr-image-panel");
        if (!panel) {
            console.warn('VR panel not found');
            return;
        }
        
    vrOverlayCanvas.width = panel.offsetWidth;
    vrOverlayCanvas.height = panel.offsetHeight;
        
        console.log(`Rendering overlay for cone: ${cone.name}`);
    
    // Generate a separate render for the overlay
    const overlayRenderResult = await render360SnapshotForCone(cone);
    const overlayRenderURL = overlayRenderResult.dataURL;
    
        // Load and draw the overlay image
        return new Promise((resolve, reject) => {
    const overlayImg = new Image();
            
    overlayImg.onload = function() {
                try {
        vrOverlayCtx.clearRect(0, 0, vrOverlayCanvas.width, vrOverlayCanvas.height);
        vrOverlayCtx.drawImage(overlayImg, 0, 0, vrOverlayCanvas.width, vrOverlayCanvas.height);
                    
                    // Ensure the overlay is visible
                    vrOverlayCanvas.style.display = 'block';
                    vrOverlayCanvas.style.opacity = '0.45';
                    
                    console.log(`Overlay successfully rendered for cone: ${cone.name}`);
                    resolve();
                } catch (error) {
                    console.error('Error drawing overlay:', error);
                    reject(error);
                }
            };
            
            overlayImg.onerror = function() {
                console.error('Failed to load overlay image');
                reject(new Error('Failed to load overlay image'));
            };
            
            overlayImg.src = overlayRenderURL;
        });
    } catch (error) {
        console.error('Error in renderOverlayCanvas:', error);
        throw error;
    }
}

    // Canvas pool for efficient reuse
    class CanvasPool {
        constructor(maxSize = 5) {
            this.pool = [];
            this.maxSize = maxSize;
        }

        getCanvas(width, height) {
            let canvas = this.pool.find(c => 
                c.width >= width && c.height >= height && !c.inUse
            );
            
            if (!canvas) {
                if (this.pool.length < this.maxSize) {
                    canvas = document.createElement('canvas');
                    this.pool.push(canvas);
                } else {
                    // Reuse oldest canvas
                    canvas = this.pool.find(c => !c.inUse) || this.pool[0];
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            canvas.inUse = true;
            return canvas;
        }

        releaseCanvas(canvas) {
            if (canvas) {
                canvas.inUse = false;
                // Clear canvas
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        cleanup() {
            this.pool.forEach(canvas => {
                canvas.inUse = false;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            });
        }
    }

    const canvasPool = new CanvasPool(5);

    // Debounce utility for performance optimization
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // VR Image Rotation Variables
    let vrCurrentImage = null;
    let vrRotation = 0; // degrees
    let vrIsDragging = false;
    let vrLastMouseX = 0;
    let vrImageSize = { width: 0, height: 0 };
    
    // Draw on every mouse move for immediate response

    // VR Image Rotation DOM Elements
    const vrOverlayCanvas = document.getElementById('vr-overlay-canvas') as HTMLCanvasElement;
    const vrDragOverlay = document.getElementById('vr-drag-overlay') as HTMLDivElement;
    const vrRotationDisplay = document.getElementById('vr-rotation-display') as HTMLDivElement;
    const vrOverlayCtx = vrOverlayCanvas.getContext('2d')!;

    // VR Image Rotation Event Handlers
    vrDragOverlay.addEventListener('mousedown', handleVRMouseDown);
    window.addEventListener('mousemove', handleVRMouseMove);
    window.addEventListener('mouseup', handleVRMouseUp);

    function handleVRMouseDown(e) {
        if (!vrCurrentImage) return;
        e.preventDefault();
        (document.body as any).style.userSelect = 'none';
        
        vrIsDragging = true;
        vrLastMouseX = e.clientX;
        vrDragOverlay.style.cursor = 'grabbing';
        
        // Show overlay when starting to drag
        if (vrOverlayCanvas && !showGeneratedView) {
            vrOverlayCanvas.style.display = 'block';
        }
    }

    function handleVRMouseMove(e) {
        if (!vrIsDragging) return;
        
        const deltaX = e.clientX - vrLastMouseX;
        
        // Convert pixels to degrees (adjust sensitivity)
        vrRotation -= deltaX * 0.5;
        // Keep rotation in range -180 to 180
        vrRotation = ((vrRotation + 180) % 360) - 180;
        
        // Update display
        updateVRRotationDisplay();
        
        // Redraw rotated image immediately
        drawVRRotatedImage();
        
        vrLastMouseX = e.clientX;
    }

    function handleVRMouseUp() {
        vrIsDragging = false;
        vrDragOverlay.style.cursor = 'grab';
        (document.body as any).style.userSelect = '';
        
        // Hide overlay when done dragging
        if (vrOverlayCanvas) {
            vrOverlayCanvas.style.display = 'none';
        }
    }

    function updateVRRotationDisplay() {
        vrRotationDisplay.textContent = `Rotation: ${vrRotation.toFixed(1)}Â°`;
    }

    // Make "Rotation:" clickable to apply as offset to the currently focused CSV cone
    let rotHoverTimer: number | null = null;
    vrRotationDisplay.addEventListener('mouseenter', () => {
        rotHoverTimer = window.setTimeout(() => {
            const tt = (panel.querySelector('div:nth-last-child(2)') as HTMLDivElement) || null;
            if (tt) tt.style.opacity = '1';
        }, 600);
    });
    vrRotationDisplay.addEventListener('mouseleave', () => {
        if (rotHoverTimer) window.clearTimeout(rotHoverTimer);
        rotHoverTimer = null;
        const tt = (panel.querySelector('div:nth-last-child(2)') as HTMLDivElement) || null;
        if (tt) tt.style.opacity = '0';
    });
    vrRotationDisplay.addEventListener('click', () => {
        // Find current CSV point under navigation (currentCsvIndex)
        const point = csvPoints[currentCsvIndex];
        console.log(currentCsvIndex);
        if (!point) return;
        // Ensure userData.originalRotation exists
        if (point.userData.originalRotation === undefined) {
            point.userData.originalRotation = point.rotation.y;
        }
        // Apply offset in radians (vrRotation is degrees)
        const offsetRad = THREE.MathUtils.degToRad(vrRotation);
        point.userData.offset = (point.userData.offset || 0) + offsetRad;
        point.rotation.y = point.userData.originalRotation + point.userData.offset;
        point.updateMatrix();
        // Update any outliner-linked rotation input if present
        if (typeof point.userData.updateRotationInput === 'function') {
            point.userData.updateRotationInput();
        }
        // Feedback
        alert('notify', `Applied +${vrRotation.toFixed(1)}Â° to ${point.name}`);
    });

    function drawVRRotatedImage() {
        if (!vrCurrentImage) return;
        
        const img = document.getElementById('vr-img');
        
        // Use canvas pool for better performance
        const canvas = canvasPool.getCanvas(vrImageSize.width, vrImageSize.height);
        const ctx = canvas.getContext('2d');
        
        // Calculate horizontal offset for rotation
        let xOffset = (vrRotation / 360) * vrImageSize.width;
        xOffset = ((xOffset % vrImageSize.width) + vrImageSize.width) % vrImageSize.width;
        
        // Calculate available width from xOffset to the image end
        const availableWidth = vrImageSize.width - xOffset;
        
        // Create a temporary image element for drawing
        const tempImg = new Image();
        tempImg.onload = function() {
            // Draw the right segment of the image
            ctx.drawImage(
                tempImg,
                xOffset, 0, availableWidth, vrImageSize.height,
                0, 0, availableWidth, vrImageSize.height
            );
            
            // Draw the left segment to complete the wrap-around
            if (xOffset > 0) {
                ctx.drawImage(
                    tempImg,
                    0, 0, xOffset, vrImageSize.height,
                    availableWidth, 0, xOffset, vrImageSize.height
                );
            }
            
            // Update the main image with reduced quality for better performance
            img.src = canvas.toDataURL('image/jpeg', 0.7);
            
            // Release canvas back to pool
            canvasPool.releaseCanvas(canvas);
        };
        tempImg.src = vrCurrentImage;
    }

    function setVRImage(imageSrc, imageName) {
        vrCurrentImage = imageSrc;
        vrRotation = 0;
        
        // Create a temporary image to get dimensions
        const tempImg = new Image();
        tempImg.onload = function() {
            vrImageSize.width = tempImg.width;
            vrImageSize.height = tempImg.height;
            
            // Show rotation controls
            vrDragOverlay.classList.remove('hidden');
            vrRotationDisplay.classList.remove('hidden');
            updateVRRotationDisplay();
        };
        tempImg.src = imageSrc;
    }

    // Helper function to show preview from ImageData
    function showRenderPreview(imageData, coneName = 'Render Preview') {
        // Use setTimeout to ensure DOM is ready
        setTimeout(() => {
            const panel = document.getElementById("vr-image-panel");
            const img = document.getElementById("vr-img") as HTMLImageElement;
            const widget = document.getElementById('vr-widget') as HTMLDivElement;
            
            if (!panel || !img || !widget) {
                console.warn('VR panel elements not found:', { panel: !!panel, img: !!img, widget: !!widget });
                return;
            }
            
            // Convert ImageData to data URL
            const canvas = document.createElement('canvas');
            canvas.width = imageData.width;
            canvas.height = imageData.height;
            const ctx = canvas.getContext('2d');
            if (ctx) {
                ctx.putImageData(imageData, 0, 0);
                const dataURL = canvas.toDataURL('image/jpeg', 0.8);
                
                console.log('Setting up render preview from ImageData...', { 
                    width: imageData.width, 
                    height: imageData.height, 
                    dataURLLength: dataURL.length,
                    coneName 
                });
                
                // Ensure image element is visible and properly styled
                img.style.display = 'block';
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.objectFit = 'contain';
                
                // Set image source and wait for it to load
                img.onload = function() {
                    console.log('Render preview image loaded successfully in vr-img for:', coneName);
                };
                img.onerror = function(e) {
                    console.error('Error loading render preview image for:', coneName, e);
                };
                
                // Display in VR panel
                img.src = dataURL;
                setVRImage(dataURL, coneName);
                
                // Show widget and panel - ensure they're visible
                widget.style.display = 'block';
                panel.style.display = 'block';
                panel.classList.remove("hidden");
                
                // Hide overlay for rendered views
                const vrOverlayCanvas = document.getElementById('vr-overlay-canvas') as HTMLCanvasElement;
                if (vrOverlayCanvas) {
                    vrOverlayCanvas.style.display = 'none';
                }
                
                console.log(`Render preview setup complete for: ${coneName}`);
            } else {
                console.error('Failed to get 2D context for preview canvas');
            }
        }, 0);
    }
    

    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
        format: THREE.RGBAFormat,
        generateMipmaps: false,
        minFilter: THREE.LinearFilter,
    });

    // CubeCamera will render into cubeRenderTarget
    const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
    scene.add(cubeCamera);

    // after you've created cubeRenderTarget & cubeCameraâ€¦

    // 1. Fullâ€screen quad geometry (2:1 aspect space)
    const quadGeo = new THREE.PlaneGeometry(2, 2);

    // 2. ShaderMaterial that maps UVâ†’directionâ†’cubemap
    const eqMaterial = new THREE.ShaderMaterial({
        uniforms: {
            envMap: { value: cubeRenderTarget.texture },
        },
        vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = vec4(position, 1.0);
    }
  `,
        fragmentShader: `
    #define PI 3.141592653589793
    varying vec2 vUv;
    uniform samplerCube envMap;
    void main() {
      // Ï† âˆˆ [0,2Ï€], Î¸ âˆˆ [0,Ï€]
      float phi   = vUv.x * PI * 2.0;
      float theta = PI - (vUv.y * PI);
      vec3 dir = vec3(
        sin(theta) * cos(phi),
        cos(theta),
        sin(theta) * sin(phi)
      );
      gl_FragColor = textureCube(envMap, dir);
    }
  `,
        depthTest: false,
        depthWrite: false,
    });

    // 3. Put it in its own scene
    // 3. Build the EQ scene & camera
    const eqScene = new THREE.Scene();
    const quadMesh = new THREE.Mesh(quadGeo, eqMaterial as any);
    quadMesh.frustumCulled = false; // ensure it always draws
    eqScene.add(quadMesh);

    // 4. Orthographic camera that exactly covers NDC â€“1 to +1 in X & Y
    const eqCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    eqMaterial.needsUpdate = true;

    window.addEventListener("pointermove", onPointerMove);

    window.addEventListener("click", reviewVR);

    // Orthographic mode panning controls
    window.addEventListener("mousedown", (event) => {
        if (currentRenderingMode === 'orthographic' && event.button === 0) { // Left mouse button
            isOrthoPanning = true;
            orthoPanStart.x = event.clientX;
            orthoPanStart.y = event.clientY;
            orthoPanStart.cameraX = orthoCamera.position.x;
            orthoPanStart.cameraZ = orthoCamera.position.z;
            document.body.style.cursor = 'grabbing';
        }
    });

    window.addEventListener("mousemove", (event) => {
        if (isOrthoPanning && currentRenderingMode === 'orthographic') {
            const deltaX = event.clientX - orthoPanStart.x;
            const deltaY = event.clientY - orthoPanStart.y;
            
            // Convert screen movement to world movement (inverse of zoom level)
            const zoomFactor = (orthoCamera.right - orthoCamera.left) / window.innerWidth;
            const moveX = -deltaX * zoomFactor;
            const moveZ = -deltaY * zoomFactor; // Fixed: Y screen movement maps to Z world movement (inverted)
            
            orthoCamera.position.x = orthoPanStart.cameraX + moveX;
            orthoCamera.position.z = orthoPanStart.cameraZ + moveZ;
            orthoCamera.lookAt(orthoCamera.position.x, 0, orthoCamera.position.z);
        }
    });

    window.addEventListener("mouseup", (event) => {
        if (isOrthoPanning) {
            isOrthoPanning = false;
            document.body.style.cursor = 'default';
        }
    });

    // Orthographic zoom with mouse wheel
    window.addEventListener("wheel", (event) => {
        if (currentRenderingMode === 'orthographic') {
            event.preventDefault();
            const zoomFactor = event.deltaY > 0 ? 1.1 : 0.9;
            
            const currentSize = orthoCamera.right - orthoCamera.left;
            const newSize = currentSize * zoomFactor;
            
            orthoCamera.left = -newSize / 2;
            orthoCamera.right = newSize / 2;
            orthoCamera.top = newSize / 2;
            orthoCamera.bottom = -newSize / 2;
            orthoCamera.updateProjectionMatrix();
        }
    });

    window.addEventListener("keydown", (e) => {
        if (e.key == "ArrowLeft") {
            console.log(e.key);
            camera.rotateY(THREE.MathUtils.degToRad(5));
        } else if (e.key == "ArrowRight") {
            console.log(e.key);
            camera.rotateY(THREE.MathUtils.degToRad(-5));
        }
        if (e.key == "ArrowUp") {
            console.log(e.key);
            camera.rotateX(THREE.MathUtils.degToRad(5));
        } else if (e.key == "ArrowDown") {
            console.log(e.key);
            camera.rotateX(THREE.MathUtils.degToRad(-5));
        }
        if (e.key.toLowerCase() == "n") {
            // Toggle UI panel with N key
            document.getElementById('ui-toggle').click();
        }
    });

    const orbitalControls = new OrbitControls(camera, renderer.domElement);
    (orbitalControls as any).enableKeys = false;

    // Check URL parameters for default rendering mode and initialize
    const urlParams = new URLSearchParams(window.location.search);
    const defaultMode = urlParams.get('view') || urlParams.get('mode');
    if (defaultMode === 'orthographic' || defaultMode === 'ortho') {
        currentRenderingMode = 'orthographic';
        currentCamera = orthoCamera;
    }
    
    // Initialize the UI based on URL parameter
    switchRenderingMode(currentRenderingMode);

    function fitCameraToObject(cam, controls, obj, padding = 2.5, duration = 0.6) {
    // 1. Get world-space bounding box & size
    const box   = new THREE.Box3().setFromObject(obj);
    const size  = box.getSize(new THREE.Vector3());
    const center= box.getCenter(new THREE.Vector3());

    // 2. Figure out the largest side and required distance
    const maxDim = Math.max(size.x, size.y, size.z);
    const fov    = cam.fov * (Math.PI/180);
    let   dist   = (maxDim/2) / Math.tan(fov/2);
    dist  *= padding;                // add some head-room

    // 3. Build new camera position (keep same spherical angle)
    const dir = new THREE.Vector3()
                    .subVectors(cam.position, controls.target)
                    .normalize();
    const newPos = dir.multiplyScalar(dist).add(center);

    // 4. Animate camera & target
    const tweenObj = {
        cx: cam.position.x, cy: cam.position.y, cz: cam.position.z,
        tx: controls.target.x, ty: controls.target.y, tz: controls.target.z
    };
    gsap.to(tweenObj, {
        cx: newPos.x, cy: newPos.y, cz: newPos.z,
        tx: center.x, ty: center.y, tz: center.z,
        duration,
        ease: "power2.out",
        onUpdate: () => {
        cam.position.set(tweenObj.cx, tweenObj.cy, tweenObj.cz);
        controls.target.set(tweenObj.tx, tweenObj.ty, tweenObj.tz);
        controls.update();
        }
    });
    }

    // Variables for keyboard control
    const keyState = {};

    // CSV navigation variables
    let currentCsvIndex = 0;
    let csvPoints = [];

    // Event listeners for keydown and keyup
    window.addEventListener("keydown", (event) => {
        keyState[event.key.toLowerCase()] = true;
        
        // Handle arrow key navigation for CSV points
        if (event.key === "ArrowRight" || event.key === "ArrowLeft") {
            event.preventDefault(); // Prevent default arrow key behavior
            const widget = document.getElementById('vr-widget') as HTMLDivElement;
            if (widget) widget.style.display = 'block';
            if (event.key === "ArrowRight") {
                navigateToNextCsvPoint().catch(console.error);
            } else if (event.key === "ArrowLeft") {
                navigateToPreviousCsvPoint().catch(console.error);
            }
        }
    });

    window.addEventListener("keyup", (event) => {
        keyState[event.key.toLowerCase()] = false;
    });

    // Function to navigate to the next CSV point
    async function navigateToNextCsvPoint() {
        ensureVRWidgetVisible();
        if (csvPoints.length === 0) {
            updateCsvPointsList();
        }
        
        if (csvPoints.length > 0) {
            currentCsvIndex = (currentCsvIndex + 1) % csvPoints.length;
            await focusOnCsvPoint(csvPoints[currentCsvIndex]);
            updateNavigationDisplay();
        }
    }

    // Function to navigate to the previous CSV point
    async function navigateToPreviousCsvPoint() {
        ensureVRWidgetVisible();
        if (csvPoints.length === 0) {
            updateCsvPointsList();
        }
        
        if (csvPoints.length > 0) {
            currentCsvIndex = (currentCsvIndex - 1 + csvPoints.length) % csvPoints.length;
            await focusOnCsvPoint(csvPoints[currentCsvIndex]);
            updateNavigationDisplay();
        }
    }

    // Function to update the list of CSV points
    function updateCsvPointsList() {
        csvPoints = markers.filter(marker => marker.cameraPos && marker.parent && marker.parent.visible);
        currentCsvIndex = 0;
        console.log(`Found ${csvPoints.length} CSV points for navigation`);
    }

    // Function to focus camera on a specific CSV point
    async function focusOnCsvPoint(point) {
        if (!point) return;
        
        // Calculate a position slightly offset from the point for better viewing
        const offset = new THREE.Vector3(0, 50, 100); // Offset up and back
        const targetPosition = point.position.clone().add(offset);
        
        // Animate camera to the new position
        gsap.to(camera.position, {
            x: targetPosition.x,
            y: targetPosition.y,
            z: targetPosition.z,
            duration: 1,
            ease: "power2.out",
            onUpdate: () => {
                orbitalControls.target.copy(point.position);
                orbitalControls.update();
            }
        });
        
        // Update VR image panel to match the selected point
        currentSelectedCone = point;
        updateSelectCurrentButtonVisibility();
        await updateVRPanelForPoint(point);
        
        console.log(`Navigated to CSV point: ${point.name}`);
    }

    // Function to update VR panel for a specific point
    async function updateVRPanelForPoint(point) {
        const panel = document.getElementById("vr-image-panel");
        const img = document.getElementById("vr-img");
        const flippedTag = document.getElementById("vr-flipped-tag");
        const targetName = point.name.toLowerCase();
        
        currentSelectedCone = point;
        updateSelectCurrentButtonVisibility();

        // Helper function to apply flipping based on image name
        function applyImageFlipping(imageName) {
            const shouldFlip = imageName.toLowerCase().includes("bf") || imageName.toLowerCase().includes("sf");
            
            if (shouldFlip) {
                img.style.transform = "scaleX(-1)";
                flippedTag.classList.remove("hidden");
            } else {
                img.style.transform = "scaleX(1)";
                flippedTag.classList.add("hidden");
            }
        }

        // Show loading indicator
        img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23666'%3ELoading...%3C/text%3E%3C/svg%3E";
        panel.classList.remove("hidden");

        try {
            // Use persistent image manager for on-demand loading
            const entry = await imageManager.findImageByName(targetName, 'medium');
            if (entry) {
                img.src = entry.image;
                
                // Set up rotation for equirectangular image
                setVRImage(entry.image, entry.name);
                
                // Show drag overlay and rotation display
                vrDragOverlay.classList.remove("hidden");
                vrRotationDisplay.classList.remove("hidden");
                
                // Render collision overlay as a semi-transparent overlay on top of the 360 image
                // This allows comparison between the 360 image and the collision model render
                try {
                    await renderOverlayCanvas(point);
                    vrOverlayCanvas.style.display = 'block';
                    vrOverlayCanvas.style.opacity = '0.45';
                    console.log('Collision overlay rendered on top of 360 image');
                } catch (overlayError) {
                    console.error('Error rendering overlay:', overlayError);
                    vrOverlayCanvas.style.display = 'none';
                }
                
                // Apply flipping based on the image entry name
                applyImageFlipping(entry.name);
                
                console.log(`VR panel updated for point: ${point.name}`);
            } else {
                // Reset states but DO NOT auto-hide the floating panel
                img.style.transform = "scaleX(1)";
                flippedTag.classList.add("hidden");
                vrDragOverlay.classList.add("hidden");
                vrRotationDisplay.classList.add("hidden");
                
                // No 360 image available - render collision overlay instead
                try {
                    await renderOverlayCanvas(point);
                    vrOverlayCanvas.style.display = 'block';
                    vrOverlayCanvas.style.opacity = '0.45';
                    console.log('Collision overlay rendered (no 360 image available)');
                } catch (overlayError) {
                    console.error('Error rendering overlay:', overlayError);
                    vrOverlayCanvas.style.display = 'none';
                }
                
                console.warn(`Image not found: ${targetName}`);
            }
        } catch (error) {
            console.error(`Error loading image ${targetName}:`, error);
            // Show error state
            img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23ff0000'%3EError loading image%3C/text%3E%3C/svg%3E";
        }
    }

    // Function to update the navigation display
    function updateNavigationDisplay() {
        const button = document.getElementById('next-csv-point');
        if (button && csvPoints.length > 0) {
            button.textContent = `Next Point (${currentCsvIndex + 1}/${csvPoints.length})`;
            // Re-add the SVG icon
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            svg.setAttribute("width", "16");
            svg.setAttribute("height", "16");
            svg.setAttribute("viewBox", "0 0 24 24");
            svg.setAttribute("fill", "none");
            svg.setAttribute("stroke", "currentColor");
            svg.setAttribute("stroke-linecap", "round");
            svg.setAttribute("stroke-linejoin", "round");
            svg.setAttribute("class", "ml-2");
            
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", "M9 18l6-6-6-6");
            path.setAttribute("stroke-width", "2");
            svg.appendChild(path);
            
            button.appendChild(svg);
        }
    }

    // Adjust these speeds to control rotation and movement
    const rotationSpeed = 0.02;
    const movementSpeed = 0.5;

    // 1) Double-click in the viewport â†’ focus whatever you double-clicked
    renderer.domElement.addEventListener("dblclick", (e) => {
    pointer.x =  (e.clientX / window.innerWidth ) * 2 - 1;
    pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);
    const hit = raycaster.intersectObjects(scene.children, true)[0];
    if (hit) fitCameraToObject(camera, orbitalControls, hit.object);
    });

    // Frame rate limiting for performance
    let lastTime = 0;
    const targetFPS = 60; // Limit to 50 FPS for better performance
    const frameInterval = 1000 / targetFPS;

    function animate(currentTime = 0) {
        // Limit frame rate
        if (currentTime - lastTime < frameInterval) {
            requestAnimationFrame(animate);
            return;
        }
        lastTime = currentTime;

        // Update raycaster for object intersections
        raycaster.setFromCamera(pointer, currentCamera);
        const intersects = raycaster.intersectObjects(scene.children);

        orthoRaycaster.setFromCamera(orthoPointer, orthoCamera);
        const orthoIntersects = orthoRaycaster.intersectObjects(scene.children);
        var label = document.getElementById("label");
        label.innerHTML = "";

        // Default Tag State
        document.getElementById("tag").style.display = "none";
        if (intersects.length > 0 && orthoIntersects.length > 0) {
            document.getElementById("tag").style.display = "flex";
            document.getElementById("tag").style.flexDirection = "column";

            var idLabel = document.createElement("p");
            var detailLabel = document.createElement("p");
            let positionObjects = intersects.filter(
                (item) => item.object.cameraPos && item.object.parent.visible,
            );

            let orthoPositionObjects = orthoIntersects.filter(
                (item) => item.object.cameraPos && item.object.parent.visible,
            );

            // positionObjects = orthoPositionObjects

            if (positionObjects.length > 0) {
                idLabel.innerText = `ID: ${positionObjects[0].object.name}`;
                idLabel.style.color = "#007700";
                idLabel.style.lineHeight = "1em";
                label.append(idLabel);

                idLabel.innerText += ` \nPos: ${positionObjects[0].object.position.x} ${positionObjects[0].object.position.y} ${positionObjects[0].object.position.z}`;
                idLabel.innerText += ` \nRot: ${THREE.MathUtils.radToDeg(positionObjects[0].object.rotation.x).toFixed(4)} ${THREE.MathUtils.radToDeg(positionObjects[0].object.rotation.z).toFixed(4)} ${THREE.MathUtils.radToDeg(positionObjects[0].object.rotation.y).toFixed(4)}`;
                detailLabel.style.color = "#007700";
                label.append(detailLabel);
            }
        }

        // Update camera position/rotation based on keyboard input
        if (keyState["arrowup"] || keyState["w"]) {
            camera.position.z -= movementSpeed;
        }
        if (keyState["arrowdown"] || keyState["s"]) {
            camera.position.z += movementSpeed;
        }
        if (keyState["arrowleft"] || keyState["a"]) {
            camera.rotation.y += rotationSpeed;
        }
        if (keyState["arrowright"] || keyState["d"]) {
            camera.rotation.y -= rotationSpeed;
        }

        // Ensure camera target is updated correctly after manual rotation
        orbitalControls.update();
        // Update gizmo orientation to match current camera
        gizmoRoot.quaternion.copy(camera.quaternion).invert();
        // orthoCamera.left = (orthoView.clientWidth / -2) * orbitalControls.getDistance()
        // orthoCamera.right = (orthoView.clientWidth / 2) * orbitalControls.getDistance()
        // orthoCamera.top = (orthoView.clientHeight / 2) * orbitalControls.getDistance()
        // orthoCamera.bottom = (orthoView.clientHeight / -2) * orbitalControls.getDistance()

        requestAnimationFrame(animate);

        // Ensure renderer size and camera aspect ratio are up-to-date before rendering
        const currentWidth = window.innerWidth;
        const currentHeight = window.innerHeight;
        const rendererSize = renderer.getSize(new THREE.Vector2());
        
        if (rendererSize.width !== currentWidth || rendererSize.height !== currentHeight) {
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.setSize(currentWidth, currentHeight);
        }
        
        // Update camera aspect ratio if needed
        if (currentCamera instanceof THREE.PerspectiveCamera && camera.aspect !== currentWidth / currentHeight) {
            camera.aspect = currentWidth / currentHeight;
            camera.updateProjectionMatrix();
        } else if (currentCamera instanceof THREE.OrthographicCamera) {
            // Update orthographic camera bounds if needed
            const expectedLeft = currentWidth / -0.1;
            const expectedRight = currentWidth / 0.1;
            const expectedTop = currentHeight / 0.1;
            const expectedBottom = currentHeight / -0.1;
            
            if (orthoCamera.left !== expectedLeft || orthoCamera.right !== expectedRight ||
                orthoCamera.top !== expectedTop || orthoCamera.bottom !== expectedBottom) {
                orthoCamera.left = expectedLeft;
                orthoCamera.right = expectedRight;
                orthoCamera.top = expectedTop;
                orthoCamera.bottom = expectedBottom;
                orthoCamera.updateProjectionMatrix();
            }
        }

        // Render loop - Optimized to reduce render calls
        renderer.clear();
        
        // Sort scene children by render order for proper z-indexing
        const sortedChildren = scene.children.slice().sort((a, b) => {
            return (a.renderOrder || 0) - (b.renderOrder || 0);
        });
        
        // Render scene with sorted children
        renderer.render(scene, currentCamera);
        
        // Only render VRSpheres if they have visible content
        if (VRSpheres.length > 0) {
            renderer.clearDepth();
            VRSpheres.forEach((e) => {
                if (e.children.length > 0) renderer.render(e, currentCamera);
            });
        }

        // Render objects (wireframes)
        if (objects.length > 0) {
            renderer.clearDepth();
            objects.forEach((e) => {
                if (e.children.length > 0) renderer.render(e, currentCamera);
            });
        }

        // Render selected reversed faces on top of wireframes
        if (selectedReversedFacesGroup.children.length > 0) {
            // Update highlight mesh transforms to match their parent meshes
            selectedReversedFacesGroup.children.forEach(highlightMesh => {
                const parentMesh = highlightMesh.userData.parentMesh;
                if (parentMesh) {
                    parentMesh.updateMatrixWorld(true);
                    parentMesh.matrixWorld.decompose(
                        highlightMesh.position,
                        highlightMesh.quaternion,
                        highlightMesh.scale
                    );
                    highlightMesh.updateMatrix();
                    highlightMesh.updateMatrixWorld(true);
                }
            });
            
            renderer.clearDepth();
            renderer.render(selectedReversedFacesGroup, currentCamera);
        }

        // Render markers (camera cones) on top of everything
        if (markers.length > 0) {
            renderer.clearDepth();
            markers.forEach((e) => {
                if (e.children.length > 0) renderer.render(e, currentCamera);
            });
        }

        updateLabelPositions();

        // Tint spheres further from the camera to gray (unlit look)
        const camDir = new THREE.Vector3(0, 0, -1).applyQuaternion(gizmoCamera.quaternion); // gizmo camera forward
        handleSpheres.forEach(({ mesh, baseColor }) => {
            // vector from gizmo camera to sphere
            const toSphere = mesh.getWorldPosition(new THREE.Vector3()).sub(gizmoCamera.position).normalize();
            // dot > 0 means in front of camera; < 0 means behind â†’ tint more
            const dot = camDir.dot(toSphere);
            // map dot [-1,1] to tint [0.6, 0] where negative gets more gray
            const t = Math.max(0, -dot); // only gray when behind
            const base = new THREE.Color(baseColor);
            const gray = new THREE.Color(0x808080);
            const mixed = base.clone().lerp(gray, Math.min(0.7, t));
            (mesh.material as any).color.copy(mixed);
        });

        // Ensure orthographic renderer size is up-to-date before rendering
        const orthoView = document.getElementById("orthoView") as HTMLDivElement;
        if (orthoView) {
            const orthoRect = orthoView.getBoundingClientRect();
            const orthoWidth = Math.max(1, orthoRect.width);
            const orthoHeight = Math.max(1, orthoRect.height);
            const orthoRendererSize = orthoRenderer.getSize(new THREE.Vector2());
            
            if (orthoRendererSize.width !== orthoWidth || orthoRendererSize.height !== orthoHeight) {
                orthoRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
                orthoRenderer.setSize(orthoWidth, orthoHeight);
                gizmoCamera.aspect = orthoWidth / orthoHeight;
                gizmoCamera.updateProjectionMatrix();
            }
        }

        // Render gizmo in the side viewport (unlit materials already used)
        orthoRenderer.clear();
        orthoRenderer.render(gizmoScene, gizmoCamera);

        // Draw screen-space spheres and outlines and labels
        const w = (orthoRenderer.domElement as HTMLCanvasElement).width;
        const h = (orthoRenderer.domElement as HTMLCanvasElement).height;
        if (gizmoOverlay.width !== w || gizmoOverlay.height !== h) {
            gizmoOverlay.width = w;
            gizmoOverlay.height = h;
        }
        overlayCtx.clearRect(0, 0, w, h);
        const toScreen = (wp: THREE.Vector3) => {
            const p = wp.clone().project(gizmoCamera);
            return { x: (p.x * 0.5 + 0.5) * w, y: (-p.y * 0.5 + 0.5) * h, z: p.z };
        };
        const gizmoCenterW = gizmoRoot.getWorldPosition(new THREE.Vector3());
        const gizmoScaleW = gizmoRoot.getWorldScale(new THREE.Vector3()).x;
        const gizmoRadiusW = Math.max(1e-6, gizmoLocalRadius * gizmoScaleW);
        const camFwd = gizmoCamera.getWorldDirection(new THREE.Vector3());
        // Sort by projected depth so farther spheres render first, nearer last
        const drawList = handleSpheres.map((desc) => {
            const wp = desc.mesh.getWorldPosition(new THREE.Vector3());
            const sp = toScreen(wp);
            return { desc, wp, sp };
        }).sort((a, b) => b.sp.z - a.sp.z); // far (z~1) first, near (z~-1) last

        drawList.forEach(({ desc, wp, sp }) => {
            const { baseColor, axisKey, sign, radiusWorld } = desc;
            // constant pixel radius (no distance scaling)
            const pxRadius = 10;

            // Depth-based opacity taper and grey tint within gizmo radius only
            const rel = wp.clone().sub(gizmoCenterW);
            const depthAlong = THREE.MathUtils.clamp(rel.dot(camFwd), -gizmoRadiusW, gizmoRadiusW);
            const depth01 = (depthAlong + gizmoRadiusW) / (2 * gizmoRadiusW); // 0 near, 1 far within gizmo radius
            const farFactor = depth01; // 0 near, 1 far
            // Opacity logic:
            // - Positive-region spheres (sign '+') are fully opaque
            // - Others taper with different rates for fill vs outline.
            //   Fill: 1.0 (near) -> 0.3 (far)
            //   Outline: 1.0 (near) -> 0.4 (far)
            const nearFactor = 1 - farFactor; // 1 near, 0 far
            const alphaFill = (sign === '+') ? 1.0 : (0.3 + 0.7 * nearFactor);
            const alphaStroke = (sign === '+') ? 1.0 : (0.4 + 0.6 * nearFactor);

            const base = new THREE.Color(baseColor);
            const gray = new THREE.Color(0x404040); // gentle darkening tint
            const extraDesat = (sign === '-') ? 0.2 : 0.0; // less saturated for negative spheres
            const tintFactorFill = Math.min(0.5, 0.3 * farFactor + extraDesat);
            const tintFactorStroke = Math.min(0.4, 0.25 * farFactor + extraDesat * 0.6);
            const fillCol = base.clone().lerp(gray, tintFactorFill);
            let strokeCol = base.clone().lerp(gray, tintFactorStroke);
            // Negative spheres: keep solid fill but brighten outline color for contrast
            if (sign === '-') {
                const white = new THREE.Color(0xffffff);
                // Pull outline back toward base color (less desaturated), then add a gentle white lift
                strokeCol = strokeCol.lerp(base, 0.4).lerp(white, 0.22);
            }
            const fillAlpha = alphaFill;
            const strokeAlpha = alphaFill;
            const fill = `rgba(${Math.round(fillCol.r*255)}, ${Math.round(fillCol.g*255)}, ${Math.round(fillCol.b*255)}, ${fillAlpha})`;
            const stroke = `rgba(${Math.round(strokeCol.r*255)}, ${Math.round(strokeCol.g*255)}, ${Math.round(strokeCol.b*255)}, ${strokeAlpha})`;

            overlayCtx.beginPath();
            overlayCtx.arc(sp.x, sp.y, pxRadius, 0, Math.PI*2);
            overlayCtx.fillStyle = fill;
            overlayCtx.fill();
            overlayCtx.lineWidth = 1.25;
            overlayCtx.strokeStyle = stroke;
            overlayCtx.stroke();
            // label: embed text centered on the sphere for positive sign
            overlayCtx.font = `${Math.round(pxRadius)}px monospace`;
            overlayCtx.textAlign = 'center';
            overlayCtx.textBaseline = 'middle';
            if (sign === '+') {
                // subtle outline for readability
                overlayCtx.lineWidth = 2;
                overlayCtx.strokeStyle = 'rgba(0,0,0,0.35)';
                overlayCtx.strokeText(axisKey, sp.x, sp.y);
                overlayCtx.fillStyle = '#111';
                overlayCtx.fillText(axisKey, sp.x, sp.y);
            }
        });

        // console.log(orbitalControls.getDistance())

        // console.log(camera.position)
        // console.log(camera.rotation)
    }

    animate(performance.now());

    //Tag
    document.addEventListener("mousemove", (e) => {
        document.getElementById("tag").style.left = `${e.x}px`;
        document.getElementById("tag").style.top = `${e.y}px`;
        document.getElementById("tag").style.transform = `translate(${
            (e.clientX / window.innerWidth) * -100
        }%, ${(e.clientY / window.innerHeight) * -150}%)`;
    });

    const fbxFiles = [];
    const glbFiles = [];
    const csvGroups = [];
    const simplifiedNamesId = [];
    const images = [];
    let globalFloors = [];
    let originalWireframeMeshes = []

    // Load assets from provided data instead of fetching from server
    async function loadAssetsFromData(assetsData) {
        try {
            // Process GLB models
            if (assetsData.models && Array.isArray(assetsData.models)) {
                for (const modelData of assetsData.models) {
                    try {
                        let fileData;
                        
                        if (typeof modelData.data === 'string') {
                            // Handle base64 encoded data
                            const binaryStr = atob(modelData.data);
                            const len = binaryStr.length;
                            const bytes = new Uint8Array(len);
                            for (let i = 0; i < len; i++) {
                                bytes[i] = binaryStr.charCodeAt(i);
                            }
                            fileData = bytes;
                        } else if (modelData.data instanceof ArrayBuffer) {
                            // Handle ArrayBuffer data
                            fileData = new Uint8Array(modelData.data);
                        } else if (modelData.data instanceof Uint8Array) {
                            // Handle Uint8Array data
                            fileData = modelData.data;
                        } else {
                            throw new Error(`Unsupported model data format for ${modelData.modelName}`);
                        }

                        // Create a File object from the binary data
                        const blob = new Blob([fileData], {
                            type: "model/gltf-binary",
                        });
                        const glbFile = new File([blob], modelData.modelName, {
                            type: "model/gltf-binary",
                        });

                        // Process the GLB file
                        await handleFileChange(glbFile, [glbFile]);
                        console.log(`Loaded GLB model: ${modelData.modelName}`);
                    } catch (error) {
                        console.error(`Error loading model ${modelData.modelName}:`, error);
                    }
                }
            }

            // Process camera CSV data
            if (assetsData.cameraCSV) {
                try {
                    let csvBlob;
                    
                    if (typeof assetsData.cameraCSV.data === 'string') {
                        // Handle string CSV data
                        csvBlob = new Blob([assetsData.cameraCSV.data], {
                            type: "text/csv",
                        });
                    } else if (assetsData.cameraCSV.data instanceof ArrayBuffer) {
                        // Handle ArrayBuffer CSV data
                        csvBlob = new Blob([new Uint8Array(assetsData.cameraCSV.data)], {
                            type: "text/csv",
                        });
                    } else if (assetsData.cameraCSV.data.data) {
                        // Handle buffer with .data property (from server response)
                        csvBlob = new Blob([new Uint8Array(assetsData.cameraCSV.data.data)], {
                            type: "text/csv",
                        });
                    } else {
                        throw new Error("Unsupported CSV data format");
                    }

                    const csvFile = new File([csvBlob], assetsData.cameraCSV.csvName || 'camera.csv', { 
                        type: "text/csv" 
                    });

                    // Process the CSV file
                    await handleFileChange(csvFile, [csvFile]);
                    console.log(`Loaded camera CSV: ${assetsData.cameraCSV.csvName}`);
                } catch (error) {
                    console.error("Error loading camera CSV:", error);
                }
            }

            // Process image array with batch optimization
            if (assetsData.images && Array.isArray(assetsData.images)) {
                console.log(`Preparing to load ${assetsData.images.length} images...`);
                
                // Prepare image data for batch processing
                const imageDataForBatch = [];
                
                for (const imageData of assetsData.images) {
                    try {
                        let dataURL;
                        
                        if (typeof imageData.data === 'string') {
                            if (imageData.data.startsWith('data:')) {
                                // Handle data URL directly
                                dataURL = imageData.data;
                            } else {
                                // Handle base64 encoded image
                                const binaryStr = atob(imageData.data);
                                const len = binaryStr.length;
                                const bytes = new Uint8Array(len);
                                for (let i = 0; i < len; i++) {
                                    bytes[i] = binaryStr.charCodeAt(i);
                                }
                                const imageBlob = new Blob([bytes], {
                                    type: imageData.mimeType || "image/jpeg",
                                });
                                dataURL = await new Promise((resolve) => {
                                    const reader = new FileReader();
                                    reader.onload = (e) => resolve(e.target.result);
                                    reader.readAsDataURL(imageBlob);
                                });
                            }
                        } else if (imageData.data instanceof ArrayBuffer) {
                            // Handle ArrayBuffer image data
                            const imageBlob = new Blob([imageData.data], {
                                type: imageData.mimeType || "image/jpeg",
                            });
                            dataURL = await new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(imageBlob);
                            });
                        } else if (imageData.data instanceof Uint8Array) {
                            // Handle Uint8Array image data
                            const imageBlob = new Blob([imageData.data], {
                                type: imageData.mimeType || "image/jpeg",
                            });
                            dataURL = await new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(imageBlob);
                            });
                        } else {
                            throw new Error(`Unsupported image data format for ${imageData.imageName}`);
                        }

                        if (dataURL) {
                            imageDataForBatch.push({
                                name: imageData.imageName,
                                data: dataURL
                            });
                        }
                        
                    } catch (error) {
                        console.error(`Error preparing image ${imageData.imageName}:`, error);
                    }
                }
                
                // Index all images instantly (no compression during load)
                if (imageDataForBatch.length > 0) {
                    await imageManager.indexBatch(imageDataForBatch, 100); // Index 100 images at a time
                    console.log(`Successfully indexed ${imageDataForBatch.length} images for on-demand loading`);
                }
            }

            console.log("All assets loaded successfully");
        } catch (error) {
            console.error("Error loading assets:", error);
        }
    }

    // Example of how to use the new function:
    // loadAssetsFromData({
    //     models: [
    //         { modelName: "model1.glb", data: "base64EncodedData..." },
    //         { modelName: "model2.glb", data: arrayBufferData }
    //     ],
    //     cameraCSV: {
    //         csvName: "cameras.csv",
    //         data: "csvStringData..."
    //     },
    //     images: [
    //         { imageName: "image1.jpg", data: "base64EncodedData...", mimeType: "image/jpeg" },
    //         { imageName: "image2.jpg", data: arrayBufferData, mimeType: "image/jpeg" }
    //     ]
    // });

    // Get project key from URL parameters
    function getProjectKeyFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('project') || urlParams.get('key') || urlParams.get('id') || 'default';
    }

    // Helper function to fetch assets from server using project key
    async function fetchAssetsFromServer(projectKey) {
        if (!projectKey) {
            projectKey = getProjectKeyFromURL();
        }

        try {
            console.log(`Loading project: ${projectKey}`);
            
            // Single endpoint to fetch all assets for a project
            const response = await fetch(`http://localhost:9234/api/project/${projectKey}`);
            
            if (!response.ok) {
                throw new Error(`Failed to fetch project ${projectKey}: ${response.status} ${response.statusText}`);
            }

            const assetsData = await response.json();
            console.log(`Successfully loaded project ${projectKey}:`, {
                models: assetsData.models?.length || 0,
                images: assetsData.images?.length || 0,
                hasCamera: !!assetsData.cameraCSV
            });

            return assetsData;
        } catch (error) {
            console.error(`Error fetching project ${projectKey}:`, error);
            
            // Fallback: try legacy endpoints for backward compatibility
            try {
                console.log("Trying legacy endpoints...");
                const assetsData = {};

                const modelResponse = await fetch("http://localhost:9234/model");
                if (modelResponse.ok) {
                    const { models } = await modelResponse.json();
                    assetsData.models = models;
                }

                const csvResponse = await fetch("http://localhost:9234/camera-csv");
                if (csvResponse.ok) {
                    const csvData = await csvResponse.json();
                    assetsData.cameraCSV = csvData;
                }

                return assetsData;
            } catch (legacyError) {
                console.error("Legacy endpoints also failed:", legacyError);
                return {};
            }
        }
    }

    // Display current project info in UI
    function displayProjectInfo(projectKey) {
        const uiArea = document.getElementById('ui-area');
        if (uiArea) {
            // Remove existing project info
            const existingInfo = uiArea.querySelector('.project-info');
            if (existingInfo) existingInfo.remove();

            // Project info pill is hidden per user request
            return;

            // Add new project info (commented out to hide the pill)
            /* 
            const projectInfo = document.createElement('div');
            projectInfo.className = 'project-info bg-blue-100 p-2 rounded-md mb-3 text-xs';
            projectInfo.innerHTML = `
                <div class="flex items-center justify-between">
                    <span><strong>Project:</strong> ${projectKey}</span>
                    <button id="share-link" class="bg-blue-500 text-white px-2 py-1 rounded text-xs hover:bg-blue-600">
                        ðŸ“‹ Copy Link
                    </button>
                </div>
            `;
            
            // Insert after the home link
            const homeLink = uiArea.querySelector('a[href="/"]');
            if (homeLink && homeLink.parentElement) {
                homeLink.parentElement.insertBefore(projectInfo, homeLink.parentElement.children[1]);
            }

            // Add copy link functionality
            document.getElementById('share-link')?.addEventListener('click', () => {
                const shareUrl = `${window.location.origin}${window.location.pathname}?project=${projectKey}`;
                navigator.clipboard.writeText(shareUrl).then(() => {
                    const btn = document.getElementById('share-link');
                    const originalText = btn.textContent;
                    btn.textContent = 'âœ… Copied!';
                    btn.style.backgroundColor = '#10b981';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '';
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy link:', err);
                    alert(`Share this link: ${shareUrl}`);
                });
            });
            */
        }
    }

    // Auto-load project from URL parameter
    const projectKey = getProjectKeyFromURL();
    displayProjectInfo(projectKey);
    fetchAssetsFromServer(projectKey).then(loadAssetsFromData);

    // Alternative: Load assets directly (uncomment and provide your data)
    // loadAssetsFromData({
    //     models: [
    //         { modelName: "model1.glb", data: "base64EncodedData..." },
    //         { modelName: "model2.glb", data: arrayBufferData }
    //     ],
    //     cameraCSV: {
    //         csvName: "cameras.csv",
    //         data: "csvStringData..."
    //     },
    //     images: [
    //         { imageName: "image1.jpg", data: "base64EncodedData...", mimeType: "image/jpeg" },
    //         { imageName: "image2.jpg", data: arrayBufferData, mimeType: "image/jpeg" }
    //     ]
    // });

    //File Drop
    function handleDrop(event) {
        event.preventDefault();
        const items = event.dataTransfer.items;
        const files = event.dataTransfer.files;
        console.log(event.dataTransfer);

        handleFileChange(items, files);
    }

    async function handleFileChange(items, files) {
        console.log("Dropped files:", files);
        const fileArray = Array.from(files);

        for (let i = 0; i < fileArray.length; i++) {
            const file = fileArray[i];
            const lower = file.name.toLowerCase();
            console.log("Processing:", file.name);

            // ----- Directory? -----
            const item = items[i];
            if (item && item.webkitGetAsEntry) {
                const entry = item.webkitGetAsEntry();
                if (entry && entry.isDirectory) {
                    // recurse through folders
                    await enumerateDirectoryWithManyFiles(entry);
                    continue;
                }
            }

            // ----- CSV -----
            if (file.type === "text/csv" || lower.endsWith(".csv")) {
                globalFloors = [];
                const text = await file.text();
                processCSVData(text, file.name);
                continue;
            }

            // ----- GLB / GLTF -----
            if (file.type === "model/gltf-binary" || lower.endsWith(".glb")) {
                const arrayBuffer = await file.arrayBuffer();

                // read the JSON chunk to detect Draco
                try {
                    const dv = new DataView(arrayBuffer);
                    const decoder = new TextDecoder("utf-8");
                    const jsonLen = dv.getUint32(12, true);
                    const jsonChunk = new Uint8Array(arrayBuffer, 20, jsonLen);
                    const jsonText = decoder.decode(jsonChunk);
                    const json = JSON.parse(jsonText);
                    console.log(
                        "GLB uses DRACO?",
                        json.extensionsUsed?.includes(
                            "KHR_draco_mesh_compression",
                        ),
                    );
                } catch (e) {
                    console.warn("Failed to inspect GLB JSON chunk:", e);
                }

                GLTFloader.parse(
                    arrayBuffer,
                    "",
                    (gltf) => {
                        applyLitMaterialToGLTF(gltf.scene);
                        gltf.scene.name = file.name;
                        gltf.scene.scale.set(100, 100, 100);
                        objects.push(gltf.scene);
                        simplifiedNamesId.push({
                            uuid: gltf.scene.uuid,
                            simplifiedName: file.name.replace(/\D/g, ""),
                        });
                        scene.add(gltf.scene);
                        updateOutliner();
                    },
                    (err) => console.error("GLB load error:", err),
                );
                continue;
            }

            // ----- FBX -----
            if (lower.endsWith(".fbx")) {
                const arrayBuffer = await file.arrayBuffer();
                // turn into a Blob URL for FBXLoader
                const blob = new Blob([arrayBuffer]);
                const url = URL.createObjectURL(blob);

                const loader = new FBXLoader();
                loader.load(
                    url,
                    (fbx) => {
                        applyLitMaterialToGLTF(fbx);
                        fbx.name = file.name;
                        fbx.scale.set(0.1, 0.1, 0.1);
                        objects.push(fbx);
                        simplifiedNamesId.push({
                            uuid: fbx.uuid,
                            simplifiedName: file.name.replace(/\D/g, ""),
                        });
                        scene.add(fbx);
                        updateOutliner();
                        URL.revokeObjectURL(url);
                    },
                    undefined,
                    (err) => console.error("FBX load error:", err),
                );
                continue;
            }

            // ----- JPG / Other Images -----
            if (file.type.startsWith("image/") && (lower.endsWith(".jpg") || lower.endsWith(".png"))) {
                const dataURL = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
                
                // Index image for on-demand loading
                const indexed = await imageManager.addImage(file.name, dataURL);
                imageArray.push(indexed);
                continue;
            }

            console.warn("Unsupported file type:", file.name);
        }
    }

    function applyLitMaterialToGLTF(gltfScene) {
        const material = new THREE.MeshStandardMaterial({
            color: 0x00ff00, // Set your desired color
            wireframe: true, // Default to wireframe off
            depthTest: true,
            depthWrite: true,
            transparent: false
        });

        gltfScene.traverse((child) => {
            if (child.isMesh) {
                child.material = material;
                child.material.wireframe = true; // Ensure wireframe is initially false
                child.renderOrder = 0; // Lower render order for wireframes
                originalWireframeMeshes.push(child);
            }
        });
    }

    async function enumerateDirectoryWithManyFiles(directoryEntry) {
        //Workaround because readEntries only reads 100 files
        let reader = directoryEntry.createReader();
        let resultEntries = [];

        let read = async function () {
            let entries = await traverseDirectoryAsync(reader);
            if (entries.length > 0) {
                resultEntries = resultEntries.concat(entries);
                await read();
            }
        };

        await read();
        return resultEntries;
    }

    function getGrandparent(entry) {
        return new Promise((resolve, reject) => {
            entry.getParent(
                (parent) => {
                    parent.getParent(
                        (grandparent) => {
                            resolve(grandparent.name);
                        },
                        (error) => {
                            reject(error);
                        },
                    );
                },
                (error) => {
                    reject(error);
                },
            );
        });
    }
    //Traverse File Tree Workaround because readEntries only reads 100 files
    function traverseDirectoryAsync(reader) {
        return new Promise((resolve, reject) => {
            reader.readEntries(
                (entries) => {
                    var objectCount = 0;

                    entries.forEach((entry) => {
                        if (entry.isFile && entry.name.endsWith(".fbx")) {
                            entry.file((file) => {
                                objectCount++;
                                const tempCount = objectCount;
                                const reader = new FileReader();
                                reader.readAsArrayBuffer(file);
                                reader.onload = (event) => {
                                    const arrayBuffer = event.target.result;
                                    const loader = new FBXLoader();
                                    const item = loader.parse(arrayBuffer, "");
                                    var currentObject;
                                    getGrandparent(entry)
                                        .then((grandparentName) => {
                                            item.unitName = grandparentName;
                                            item.name = entry.name;
                                            currentObject = {
                                                fileName: entry.name,
                                                unitName: grandparentName,
                                            };
                                            const csvObject = csvGroups.find(
                                                (x) =>
                                                    x.userData
                                                        .simplifiedName ===
                                                    grandParent,
                                            );
                                            var newObject = {
                                                uuid: item.uuid,
                                                simplifiedName: grandparentName,
                                                csvObject: csvObject
                                                    ? csvObject
                                                    : "",
                                            };
                                            simplifiedNamesId.push(newObject);
                                            fbxFiles.push(currentObject);

                                            const fileUploadEvent =
                                                new CustomEvent("file-upload", {
                                                    detail: currentObject,
                                                });
                                            window.dispatchEvent(
                                                fileUploadEvent,
                                            );
                                        })
                                        .catch((error) =>
                                            console.error(
                                                "Error fetching grandparent:",
                                                error,
                                            ),
                                        );

                                    scene.add(item);
                                };
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".glb")
                        ) {
                            glbFiles.push(entry);
                            entry.file((file) => {
                                objectCount++;
                                const tempCount = objectCount;
                                const reader = new FileReader();
                                reader.readAsArrayBuffer(file);
                                reader.onload = (event) => {
                                    const arrayBuffer = event.target.result;
                                    const loader = new GLTFLoader();
                                    const item = loader.parse(arrayBuffer, "");
                                    item.name = entry.name;
                                    simplifiedNamesId.push({
                                        uuid: item.uuid,
                                        simplifiedName: entry.name.replace(
                                            /\D/g,
                                            "",
                                        ),
                                    });
                                    console.log("item name" + item.name);
                                    glbFiles.push(item.name);
                                    scene.add(item);
                                };
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".csv")
                        ) {
                            entry.file((file) => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    processCSVData(e.target.result, file.name);
                                };
                                reader.readAsText(file);
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".jpg")
                        ) {
                            entry.file((file) => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    processVRImage(e.target.result, file.name);
                                };
                                reader.readAsDataURL(file);
                            });
                        } else if (entry.isDirectory) {
                            const subReader = entry.createReader();
                            traverseDirectoryAsync(subReader); // Recursive call
                        }
                    });
                    resolve(entries);
                },
                (error) => reject(error),
            );
        });
    }

    // Function to export a Three.js object to a GLB file
    function exportToGLB(object, filename) {
        // Store original scale
        const originalScale = object.scale.clone();
        
        // Store original wireframe states and temporarily disable wireframe
        const wireframeStates = [];
        // Store original material colors and set to white
        const materialStates = [];
        
        object.traverse((child) => {
            if (child.isMesh && child.material) {
                const materials = Array.isArray(child.material) ? child.material : [child.material];
                materials.forEach((mat) => {
                    wireframeStates.push({ material: mat, wireframe: mat.wireframe });
                    mat.wireframe = false;
                    
                    // Store original material color and set to white
                    if (mat.color) {
                        materialStates.push({ 
                            material: mat, 
                            originalColor: mat.color.clone(),
                            originalEmissive: mat.emissive ? mat.emissive.clone() : new THREE.Color(0x000000)
                        });
                        mat.color.setHex(0xffffff);
                        if (mat.emissive) {
                            mat.emissive.setHex(0x000000);
                        }
                    }
                    
                    mat.needsUpdate = true;
                });
            }
        });
        
        // Temporarily reset scale to 1:1 but preserve flips (negative scale)
        // If scale is 100, set to 1; if scale is -100, set to -1 (preserve the flip)
        const normalizedScale = new THREE.Vector3(
            originalScale.x >= 0 ? 1 : -1,
            originalScale.y >= 0 ? 1 : -1,
            originalScale.z >= 0 ? 1 : -1
        );
        object.scale.copy(normalizedScale);
        object.updateMatrixWorld(true);
        
        const exporter = new GLTFExporter();
        exporter.parse(
            object,
            (result) => {
                // Restore original scale after export
                object.scale.copy(originalScale);
                object.updateMatrixWorld(true);
                
                // Restore original wireframe states
                wireframeStates.forEach(({ material, wireframe }) => {
                    material.wireframe = wireframe;
                    material.needsUpdate = true;
                });
                
                // Restore original material colors
                materialStates.forEach(({ material, originalColor, originalEmissive }) => {
                    material.color.copy(originalColor);
                    if (material.emissive) {
                        material.emissive.copy(originalEmissive);
                    }
                    material.needsUpdate = true;
                });
                
                let blob;
                if (result instanceof ArrayBuffer) {
                    blob = new Blob([result], {
                        type: "application/octet-stream",
                    });
                } else if (typeof result === "object") {
                    blob = new Blob([JSON.stringify(result)], {
                        type: "application/json",
                    });
                } else {
                    console.error("Unexpected result type:", result);
                    return;
                }

                saveBlob(blob, filename);
            },
            (error) => {
                // Restore original scale and wireframe states even if export fails
                object.scale.copy(originalScale);
                object.updateMatrixWorld(true);
                
                wireframeStates.forEach(({ material, wireframe }) => {
                    material.wireframe = wireframe;
                    material.needsUpdate = true;
                });
                
                // Restore original material colors
                materialStates.forEach(({ material, originalColor, originalEmissive }) => {
                    material.color.copy(originalColor);
                    if (material.emissive) {
                        material.emissive.copy(originalEmissive);
                    }
                    material.needsUpdate = true;
                });
                
                console.error("An error occurred during the GLB export", error);
            },
            { binary: true }, // Options object with binary set to true
        );
    }

    // Function to save the Blob as a file
    function saveBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.style.display = "none";
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();

        // Clean up
        setTimeout(() => {
            URL.revokeObjectURL(url);
            document.body.removeChild(link);
        }, 100);
    }

    // Function to export all models (GLB and FBX) in objects array
    function exportAllFBXFilesToGLB() {
        const exportEntireScene = document.getElementById(
            "export-all-scene-checkbox",
        ).checked;
        if (exportEntireScene) {
            // Export the entire scene
            exportToGLB(scene, "scene.glb");
        } else {
            // Export all loaded models
            if (objects.length === 0) {
                alert("error", "No models loaded to export");
                return;
            }
            objects.forEach((object) => {
                if (object && object.name) {
                    const filename = `${object.name.split(".")[0]}.glb`;
                    exportToGLB(object, filename);
                }
            });
        }
    }

    // Add an event listener to the export button
    const exportButton = document.getElementById("export-all-fbx");
    exportButton.addEventListener("click", exportAllFBXFilesToGLB);

    // Function to export CSV with updated rotations
    function exportCSVWithRotations() {
        if (!m_Group || !m_Group.children || m_Group.children.length === 0) {
            alert("error", "Please import a CSV file first to export rotations");
            return;
        }

        let csvContent = ""; // No header

        m_Group.children.forEach((child) => {
            if (child instanceof THREE.Mesh && child.cameraPos) {
                // Get world position and quaternion to account for flipped parents
                const worldPosition = new THREE.Vector3();
                const worldQuaternion = new THREE.Quaternion();
                const worldEuler = new THREE.Euler();
                
                child.getWorldPosition(worldPosition);
                child.getWorldQuaternion(worldQuaternion);
                worldEuler.setFromQuaternion(worldQuaternion, 'XYZ');

                // Format: name,x,-z,y,0,0,rotation_y_in_degrees
                csvContent += `${child.name},${worldPosition.x.toFixed(6)},${(-worldPosition.z).toFixed(6)},${worldPosition.y.toFixed(6)},0,0,${THREE.MathUtils.radToDeg(worldEuler.y).toFixed(6)}\n`;
            }
        });

        // Create and download the CSV file
        const blob = new Blob([csvContent], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${m_Group.name.split(".")[0]}_with_rotations.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert("notify", `Exported ${m_Group.children.length} cones with updated rotations`);
    }

    // Add event listener for CSV export button
    const exportCsvButton = document.getElementById("export-csv-rotations");
    if (exportCsvButton) {
        exportCsvButton.addEventListener("click", exportCSVWithRotations);
    }

    const logScene = document.getElementById("log-scene");
    logScene.addEventListener("click", (e) => {
        console.log(scene);
    });
    const dropZone = document.getElementById("drop-zone");
    dropZone.addEventListener("drop", handleDrop);
    document.body.addEventListener("dragover", (e) => {
        event.preventDefault();
    });

    function createCone(name, position, rotation) {
        const geometry = new THREE.ConeGeometry(20, 40, 32); // Cone with radius 0.5 and height 1
        const material = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            depthTest: true,
            depthWrite: true,
            transparent: false
        }); // Red color, change as needed
        const cone = new THREE.Mesh(geometry, material);
        const dir = new THREE.Vector3(Math.sin(THREE.MathUtils.degToRad(rotation.z)), 0, Math.cos(THREE.MathUtils.degToRad(rotation.z)));
        //normalize the direction vector (convert to vector of length 1)
        dir.normalize();

        // const origin = new THREE.Vector3( position.x, position.y, position.z);
        // const length = 15;
        // const hex = 0xff0000;
        // const arrow = new THREE.ArrowHelper( dir, origin, length, hex, 5, 8);
        // arrow.scale.set(3,3,3)

        // Set position
        cone.position.set(0, 0, 0);

        // Set rotation using Euler angles, converting degrees to radians
        cone.rotation.set(
            THREE.MathUtils.degToRad(0),
            THREE.MathUtils.degToRad(90),
            THREE.MathUtils.degToRad(90),
        );
        cone.updateMatrix();
        cone.geometry.applyMatrix4(cone.matrix); //to bake rotation to cone
        cone.position.set(position.x, position.y, position.z);
        cone.rotation.set(0, THREE.MathUtils.degToRad(rotation.z), 0);
        cone.scale.set(1, 1, 1);
        cone.updateMatrix();
        console.log(cone.rotation);
        cone.renderOrder = 1000; // Higher render order to render on top
        cone.name = name;
        markers.push(cone);
        return cone;
    }
    var showMarkerNames = false;

    // function createCone(name, position, rotation) {
    //     const loader = new GLTFLoader();
    //     const camera = loader.load("./camera.glb", (e) => {
    //         const model = e.scene

    //         model.position.set(position.x, position.y, position.z)
    //         model.renderOrder = 0;
    //         model.name = name;
    //     })
    //     return camera
    // }

    // Create a label div for each marker
    function createLabels() {
        document.getElementById("marker-label-container").innerHTML = "";
        var copiedMarkers;
        copiedMarkers = markers.filter((e) => e.visible);
        copiedMarkers.forEach((marker) => {
            const labelDiv = document.createElement("div");
            labelDiv.style.backgroundColor = "#444444";
            labelDiv.style.padding = "2px 5px";
            labelDiv.style.borderRadius = "6px";
            labelDiv.className = "marker-label";
            labelDiv.innerText = marker.name;

            // Style the label
            labelDiv.style.position = "absolute";
            labelDiv.style.color = "white";
            labelDiv.style.fontSize = "10px";

            document
                .getElementById("marker-label-container")
                .appendChild(labelDiv);
            marker.userData.label = labelDiv; // Store the label in userData
        });
    }

    // Function to update label positions on the screen
    function updateLabelPositions() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const widthHalf = width / 2;
        const heightHalf = height / 2;

        const distances = markers.map((marker) =>
            currentCamera.position.distanceTo(marker.position),
        );
        const minDistance = Math.min(...distances);
        const maxDistance = Math.max(...distances);
        const distanceRange = maxDistance - minDistance || 1;

        // Sort markers by distance from the camera (closest markers first)
        const sortedMarkers = markers
            .sort((a, b) => {
                const distanceA = currentCamera.position.distanceTo(a.position);
                const distanceB = currentCamera.position.distanceTo(b.position);
                return distanceA - distanceB;
            })
            .filter((e) => e.visible);

        sortedMarkers.map((marker, i) => {
            // console.log(marker)
            const labelDiv = marker.userData.label;
            if (!labelDiv) return;

            // Get the 3D position of the marker and project it to 2D
            const vector = new THREE.Vector3();
            vector.setFromMatrixPosition(marker.matrixWorld).project(currentCamera);

            // Convert to 2D screen space
            const x = vector.x * widthHalf + widthHalf;
            const y = -(vector.y * heightHalf) + heightHalf;

            // Update label position and visibility based on camera view
            labelDiv.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            labelDiv.style.display =
                vector.z > -1 && vector.z < 1 ? "block" : "none";

            // Calculate distance and adjust opacity based on the relative distance
            const distance = currentCamera.position.distanceTo(marker.position);
            const normalizedDistance =
                (distance - minDistance + 1) / distanceRange;
            const minOpacity = 0.6;
            labelDiv.style.opacity =
                minOpacity +
                (1 - minOpacity) *
                    (1 - normalizedDistance) ** (maxDistance / minDistance);
            labelDiv.style.zIndex = 1000 - Math.floor(distance); // Higher z-index for closer markers
        });
    }

    function createCSVFromSphereGroups(csvGroups) {
        let csvContent = ""; // CSV header

        csvGroups.forEach((group) => {
            group.children.forEach((child) => {
                if (child instanceof THREE.Mesh) {
                    // Ensure child is a mesh (sphere)
                    const name = child.name;
                    const worldPosition = new THREE.Vector3();
                    const worldQuaternion = new THREE.Quaternion();
                    const worldEuler = new THREE.Euler();
                    const position = child.getWorldPosition(worldPosition);
                    const rotation = child.getWorldQuaternion(worldQuaternion);
                    worldEuler.setFromQuaternion(worldQuaternion);

                    csvContent += `${name},${worldPosition.x},${-worldPosition.y},${worldPosition.z},${worldEuler.x},${worldEuler.y},${worldEuler.z}\n`;
                }
            });

            // Create a downloadable CSV file
            const blob = new Blob([csvContent], { type: "text/csv" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${group.name.split(".")[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
    }

    //Calculate center of all CSV points
    function calculateGroupCenter(group) {
        const positions = group.children.map((child) => child.position);
        const totalPositions = positions.length;

        if (totalPositions === 0) return null;

        const sum = positions.reduce(
            (acc, pos) => {
                acc.x += pos.x;
                acc.y += pos.y;
                acc.z += pos.z;
                return acc;
            },
            { x: 0, y: 0, z: 0 },
        );

        return {
            x: sum.x / totalPositions,
            y: sum.y / totalPositions,
            z: sum.z / totalPositions,
        };
    }

    function translateGroupToOrigin(group) {
        const center = calculateGroupCenter(group);
        group.initPosition = new THREE.Vector3(-center.x, -center.y, -center.z);
        if (!center) return;

        group.position.set(-center.x, -center.y, -center.z);
    }

    function alert(type, message) {
        var el = document.createElement("div");
        el.style.background = "#ffffff88";
        el.style.padding = "20px";
        el.style.borderRadius = "15px";
        el.classList.add("notification");
        var text = document.createElement("p");
        if (type == "error") {
            el.classList.add("alert-error");
        } else if (type == "notify") {
            el.classList.add("alert-notify");
        }
        text.innerText = message;
        text.style.margin = "0px";
        el.appendChild(text);

        document.getElementById("notification-panel").appendChild(el);

        setTimeout((e) => {
            el.remove();
        }, 2000);
    }

    // Function to scale each point relative to the center point of the group
    function scaleGroupRelativeToCenter(group, scaleFactor) {
        m_Group.scale.set(scaleFactor, scaleFactor, scaleFactor);
        if (!m_Group.initPosition) {
            m_Group.initPosition = new THREE.Vector3(
                m_Group.position.x,
                m_Group.position.y,
                m_Group.position.z,
            );
        }
        m_Group.position.set(
            m_Group.initPosition.x * scaleFactor,
            m_Group.initPosition.y * 1,
            m_Group.initPosition.z * scaleFactor,
        );
        var center = group.position;
        group.children.forEach((child) => {
            child.scale.set(1 / scaleFactor, 1 / scaleFactor, 1 / scaleFactor);
        });
    }

    function convertFBXtoGLB(position, rotation) {
        // Assuming FBX is Y-up and GLB is Z-up
        // Convert position
        const convertedPosition = {
            x: position.x,
            y: position.z,
            z: -position.y,
        };

        // Convert rotation (assuming Euler angles)
        const convertedRotation = {
            x: rotation.x,
            y: rotation.z,
            z: -rotation.y,
        };

        return { position: convertedPosition, rotation: convertedRotation };
    }

    // Function to process CSV data and create spheres
    function processCSVData(csvText, name?) {
        const lines = csvText.split("\n"); // Split CSV text into lines
        // Skip the first line if it contains headers, and process the rest

        const group = new THREE.Group();

        for (let i = 0; i < lines.length; i++) {
            const row = lines[i].split(",");
            if (row.length >= 7) {
                const name = row[0];
                const position = {
                    x: parseFloat(row[1]),
                    y: parseFloat(row[3]),
                    z: -parseFloat(row[2]),
                };
                const rotation = {
                    x: parseFloat(row[4]),
                    y: parseFloat(row[5]),
                    z: parseFloat(row[6]),
                };
                const floor = name.includes("_") ? name.split("_")[0] : name; //Get Floor Number
                const arrow = createCone(name, position, rotation);
                arrow.cameraPos = true;
                arrow.floor = floor;

                globalFloors.push({ floor: floor, arrow: arrow }); //Push obj to globalFloors

                group.add(arrow);
                // console.log(arrow);
            }

            if (name) {
                group.name = name;
                group.userData.simplifiedName = name.replace(/\D/g, "");
            }
            scene.add(group);
            m_Group = group;
        }
        createLabels();
        csvGroups.push(group);
        handleFloors();

        //Update main object references
        if (simplifiedNamesId.length > 0) {
            simplifiedNamesId.forEach((e) => {
                if (e.simplifiedName == name.replace(/\D/g, "")) {
                    e.csvObject = group.uuid;
                } else {
                    group.remove();
                }
            });
        }
        const csvUploadEvent = new CustomEvent("file-upload-csv", {
            detail: {
                simplifiedName: group.userData.simplifiedName,
                name: group.name,
            },
        });
        window.dispatchEvent(csvUploadEvent);
        updateOutliner();
        
        // Update CSV points list for navigation
        updateCsvPointsList();
        updateNavigationDisplay();
    }

    function processVRImage(data, name?) {
        const thisImage = { name: name, image: data };
        imageArray.push(thisImage);
    }

    document.getElementById("ui-area").addEventListener("click", (e) => {
        if (!m_Group) {
            alert(
                "error",
                "Please Import some CSV files to use these features",
            );
        }
    });

    document.getElementById("x-flip").addEventListener("click", (e) => {
        // Flip by inverting scale on X axis
        m_Group.scale.x *= -1;
        m_Group.updateMatrixWorld(true);
    });

    document.getElementById("y-flip").addEventListener("click", (e) => {
        // Flip by inverting scale on Y axis
        m_Group.scale.y *= -1;
        m_Group.updateMatrixWorld(true);
    });

    document.getElementById("z-flip").addEventListener("click", (e) => {
        // Flip by inverting scale on Z axis
        m_Group.scale.z *= -1;
        m_Group.updateMatrixWorld(true);
    });

    document.getElementById("y-up").addEventListener("click", (e) => {
        m_Group.children.forEach((e) => {
            const initYPos = e.position.y;
            e.position.y = -initYPos;
        });
    });

    // Model flip event listeners
    document.getElementById("model-x-flip").addEventListener("click", (e) => {
        objects.forEach((obj) => {
            // Flip by inverting scale on X axis
            obj.scale.x *= -1;
            obj.updateMatrixWorld(true);
        });
    });

    document.getElementById("model-y-flip").addEventListener("click", (e) => {
        objects.forEach((obj) => {
            // Flip by inverting scale on Y axis
            obj.scale.y *= -1;
            obj.updateMatrixWorld(true);
        });
    });

    document.getElementById("model-z-flip").addEventListener("click", (e) => {
        objects.forEach((obj) => {
            // Flip by inverting scale on Z axis
            obj.scale.z *= -1;
            obj.updateMatrixWorld(true);
        });
    });

    document.getElementById("center-csv").addEventListener("change", (e) => {
        if (e.target.checked) {
            calculateGroupCenter(m_Group);
            translateGroupToOrigin(m_Group);
            alert("notify", "csv-centered");
            } else {
            m_Group.position.set(0, 0, 0);
            alert("notify", "csv-centered");
        }
    });

    document.getElementById("show-labels").addEventListener("change", (e) => {
        createLabels();
        if (e.target.checked) {
            document.getElementById("marker-label-container").style.display =
                "block";
                } else {
            document.getElementById("marker-label-container").style.display =
                "none";
        }
    });

    document
        .getElementById("show-face-orientation")
        .addEventListener("change", (e) => {
            if (e.target.checked) {
                console.log(glbFiles);
                console.log(markers);
                scene.traverse(function (child) {
                    console.log(child.name);
                    if (
                        child.isMesh &&
                        !(child.userData && child.userData.label) &&
                        !child.name.toLowerCase().includes("sphere")
                    ) {
                        child.material = new THREE.ShaderMaterial({
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }`,
                    fragmentShader: `
                        varying vec3 vNormal;
                        void main() {
                                    float facingRatio = dot(vNormal, vec3(0.0, 0.0, 1.0));
                                    float blueIntensity = 0.5 + 0.5 * facingRatio; // Blue becomes more intense as the normal faces the viewer
                                    float redIntensity = 0.5 - 0.5 * facingRatio; // Red becomes more intense as the normal faces away
                                    gl_FragColor = vec4(redIntensity, 0.0, blueIntensity, 0.5); // Semi-transparent
                                }`,
                            side: THREE.FrontSide,
                            transparent: true,
                        });
                    }
                });
        } else {
                scene.traverse((child) => {
                    if (
                        child.isMesh &&
                        !(child.userData && child.userData.label) &&
                        !child.name.toLowerCase().includes("sphere")
                    ) {
                        child.material = material;
                        child.material.wireframe = true; // Ensure wireframe is initially false
                        originalWireframeMeshes.push(child);
                    }
                });
        }
    });

    document.getElementById("show-labels").addEventListener("change", (e) => {
        createLabels();
        if (e.target.checked) {
            document.getElementById("marker-label-container").style.display =
                "block";
        } else {
            document.getElementById("marker-label-container").style.display =
                "none";
        }
    });

    document
        .getElementById("show-face-orientation")
        .addEventListener("change", (e) => {
            if (e.target.checked) {
                console.log(glbFiles);
                console.log(markers);
                scene.traverse(function (child) {
                    console.log(child.name);
                    if (
                        child.isMesh &&
                        !(child.userData && child.userData.label) &&
                        !child.name.toLowerCase().includes("sphere")
                    ) {
                        child.material = new THREE.ShaderMaterial({
                            vertexShader: `
                                varying vec3 vNormal;
                                void main() {
                                    vNormal = normalize(normalMatrix * normal);
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }`,
                            fragmentShader: `
                                varying vec3 vNormal;
                                void main() {
                                    float facingRatio = dot(vNormal, vec3(0.0, 0.0, 1.0));
                                    float blueIntensity = 0.5 + 0.5 * facingRatio; // Blue becomes more intense as the normal faces the viewer
                                    float redIntensity = 0.5 - 0.5 * facingRatio; // Red becomes more intense as the normal faces away
                                    gl_FragColor = vec4(redIntensity, 0.0, blueIntensity, 0.5); // Semi-transparent
                                }`,
                            side: THREE.FrontSide,
                            transparent: true,
                        });
                    }
                });
            } else {
                scene.traverse((child) => {
                    if (
                        child.isMesh &&
                        !(child.userData && child.userData.label) &&
                        !child.name.toLowerCase().includes("sphere")
                    ) {
                        child.material = material;
                        child.material.wireframe = true; // Ensure wireframe is initially false
                        originalWireframeMeshes.push(child);
                    }
                });
            }
        });

    // Updated buildTree with collapsible parents, auto-collapse for >6 children, and dblclick to toggle visibility
    function buildTree(object) {
        // Create <li> for this node
        const li = document.createElement("li");
        li.className =
            "my-[3px] text-2xs hover:bg-gray-300 cursor-pointer flex flex-col";

        // Container holds toggle (if any), name, and color picker
        const container = document.createElement("div");
        container.className = "flex items-center gap-2";

        // Initialize enabled state if not already
        if (object.userData.isEnabled === undefined) {
            object.userData.isEnabled = true;
        }

        // Double-click to toggle this object and its children
        container.addEventListener("dblclick", (e) => {
            e.stopPropagation();
            const newState = !object.userData.isEnabled;
            toggleVisibility(object, newState);
            styleSubtree(li, newState);
            // Clear or refresh HTML labels overlay when CSV cones visibility changes
            if (typeof createLabels === "function") {
                createLabels();
            }
        });

        // Create toggle button for nodes with children
        const hasChildren = object.children && object.children.length > 0;
        let toggle;
        if (hasChildren) {
            toggle = document.createElement("button");
            // Start collapsed if >6 children, otherwise expanded
            const startCollapsed = object.children.length > 6;
            toggle.textContent = startCollapsed ? "+" : "\u2212";
            toggle.className =
                "toggle-btn w-4 h-4 p-0 m-0 border-none bg-transparent";
            toggle.style.cursor = "pointer";
            container.appendChild(toggle);
        }

        // Name label
        const nameSpan = document.createElement("span");
        nameSpan.textContent = object.name || object.type || "Unnamed";
        container.appendChild(nameSpan);

        // Add rotation input for cones (camera positions)
        if (object.cameraPos) {
            const rotationContainer = document.createElement("div");
            rotationContainer.className = "flex items-center gap-1 ml-2";
            
            const rotationLabel = document.createElement("span");
            rotationLabel.textContent = "Z:";
            rotationLabel.className = "text-xs text-gray-600";
            rotationContainer.appendChild(rotationLabel);
            
            const rotationInput = document.createElement("input");
            rotationInput.type = "number";
            rotationInput.step = "0.1";
            rotationInput.className = "w-16 h-4 text-xs border border-gray-300 rounded px-1";
            rotationInput.value = THREE.MathUtils.radToDeg(object.rotation.y).toFixed(1);
            
            // Update cone rotation when input changes
            rotationInput.addEventListener("input", (e) => {
                const inputValue = parseFloat(e.target.value);
                
                // Validate input
                if (isNaN(inputValue)) {
                    rotationInput.style.borderColor = "red";
                    rotationInput.style.boxShadow = "0 0 5px red";
                    return; // Don't apply invalid rotation
                }
                
                // Clear error styling
                rotationInput.style.borderColor = "";
                rotationInput.style.boxShadow = "";
                
                const newRotation = THREE.MathUtils.degToRad(inputValue);
                object.rotation.y = newRotation;
                
                // Update the cone's visual representation
                object.updateMatrix();
                object.geometry.applyMatrix4(object.matrix);
                object.rotation.set(0, newRotation, 0);
                object.updateMatrix();
                
                // Update labels if they exist
                if (typeof createLabels === "function") {
                    createLabels();
                }
            });
            
            // Update input when cone rotation changes externally
            const updateRotationInput = () => {
                rotationInput.value = THREE.MathUtils.radToDeg(object.rotation.y).toFixed(1);
            };
            
            // Store the update function for external use
            object.userData.updateRotationInput = updateRotationInput;
            
            rotationContainer.appendChild(rotationInput);
            
            // Add offset field
            const offsetLabel = document.createElement("span");
            offsetLabel.textContent = "Offset:";
            offsetLabel.className = "text-xs text-gray-600 ml-2";
            rotationContainer.appendChild(offsetLabel);
            
            const offsetInput = document.createElement("input");
            offsetInput.type = "number";
            offsetInput.step = "0.1";
            offsetInput.className = "w-16 h-4 text-xs border border-gray-300 rounded px-1";
            offsetInput.value = "0.0";
            
            // Initialize offset if not exists
            if (object.userData.originalRotation === undefined) {
                object.userData.originalRotation = object.rotation.y;
                object.userData.offset = 0;
            }
            
            // Update offset when input changes
            offsetInput.addEventListener("input", (e) => {
                const inputValue = parseFloat(e.target.value);
                
                // Validate input
                if (isNaN(inputValue)) {
                    offsetInput.style.borderColor = "red";
                    offsetInput.style.boxShadow = "0 0 5px red";
                    return; // Don't apply invalid offset
                }
                
                // Clear error styling
                offsetInput.style.borderColor = "";
                offsetInput.style.boxShadow = "";
                
                const offset = THREE.MathUtils.degToRad(inputValue);
                object.userData.offset = offset;
                
                // Calculate final rotation: original + offset
                const finalRotation = object.userData.originalRotation + offset;
                object.rotation.y = finalRotation;
                
                // Update the cone's visual representation (simpler approach)
                object.updateMatrix();
                
                // Update the main rotation input to show the final value
                if (object.userData.updateRotationInput) {
                    object.userData.updateRotationInput();
                }
                
                // Update labels if they exist
                if (typeof createLabels === "function") {
                    createLabels();
                }
            });
            
            rotationContainer.appendChild(offsetInput);
            container.appendChild(rotationContainer);
        }

        // Color picker
        const colorPicker = document.createElement("input");
        colorPicker.type = "color";
        colorPicker.style.cursor = "pointer";
        colorPicker.value = "#ff0000";
        colorPicker.className = "w-6 h-6 p-0 m-0 border-none";
        object.userData.colorPicker = colorPicker;
        colorPicker.addEventListener("input", (e) => {
            e.stopPropagation();
            updateObjectColor(object, e.target.value);
        });
        container.appendChild(colorPicker);

        li.appendChild(container);

        // Build children list
        if (hasChildren) {
            const ul = document.createElement("ul");
            ul.className = "ml-4 list-disc";
            // Auto-collapse large lists
            const isCollapsed = object.children.length > 6;
            ul.style.display = isCollapsed ? "none" : "block";

            // Recursively add children
            object.children.forEach((child) => {
                const childLi = buildTree(child);
                ul.appendChild(childLi);
            });
            li.appendChild(ul);

            // Toggle expand/collapse
            toggle.addEventListener("click", (e) => {
                e.stopPropagation();
                const hidden = ul.style.display === "none";
                ul.style.display = hidden ? "block" : "none";
                toggle.textContent = hidden ? "\u2212" : "+";
            });
        } else {
            // Leaf: make draggable
            container.draggable = true;
            container.addEventListener("dragstart", (e) => {
                e.stopPropagation();
                e.dataTransfer.setData("text/plain", object.id);
            });
        }


            if ( (object.name || '').toLowerCase().endsWith('.glb') ) {
                container.addEventListener('mouseenter', ev => {
                    hoverTimerId = setTimeout(() => {
                    showTooltip(ev.clientX, ev.clientY, "Click to refocus");
                    }, 200);      // 3 s
                });

                container.addEventListener('mousemove', ev => {
                    if (tooltip.style.opacity === '1') showTooltip(ev.clientX, ev.clientY, "Click to refocus");
                });

                container.addEventListener('mouseleave', hideTooltip);
                container.addEventListener('click', hideTooltip); // user followed hint
            }

        // Context menu on CSV files: export 360 for the whole group
        if (object.name.toLowerCase().endsWith(".csv")) {
            container.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                if (
                    confirm(`Export all 360Â° images for group ${object.name}?`)
                ) {
                    // Determine group key
                    const key = getGroupId(object.name);
                    // Hide everything
                    scene.children.forEach((o) => (o.visible = false));
                    // Show only objects in this group (matching key)
                    scene.children.forEach((o) => {
                        const k = getGroupId(o.name || "");
                        if (k === key) o.visible = true;
                    });
                    // Also show cones under the CSV group
                    const csvGroup = scene.getObjectByName(object.name);
                    if (csvGroup) csvGroup.visible = true;
                    // Trigger 360 export
                    exportAll360ForGroup(object);
                }
            });
        }

        // Apply initial disabled style if needed
        styleSubtree(li, object.userData.isEnabled);
        li.setAttribute("data-object-id", object.id);
        return li;
    }

    // helper to save the current renderer canvas as a PNG
    function saveDebugImage(label) {
        const link = document.createElement("a");
        link.href = renderer.domElement.toDataURL("image/png");
        link.download = `${label}.png`;
        link.click();
    }

    // Helper function to get unique face identifier
    function getFaceId(mesh, faceIndex) {
        return `${mesh.uuid}-${faceIndex}`;
    }
    
    // Helper function to detect reversed normals relative to camera position
    function detectReversedNormalsFromCamera(cameraPosition) {
        const reversedFaces = [];
        
        objects.forEach(obj => {
            obj.traverse((child) => {
                if (!child.isMesh || !child.geometry) return;
                
                const geometry = child.geometry;
                if (!geometry.attributes.position || !geometry.attributes.normal) return;
                
                const positions = geometry.attributes.position;
                const normals = geometry.attributes.normal;
                const hasIndex = geometry.index !== null;
                
                if (hasIndex) {
                    const index = geometry.index;
                    for (let i = 0; i < index.count; i += 3) {
                        const i0 = index.getX(i) * 3;
                        const i1 = index.getX(i + 1) * 3;
                        const i2 = index.getX(i + 2) * 3;
                        
                        // Get face center
                        const v0 = new THREE.Vector3(
                            positions.array[i0],
                            positions.array[i0 + 1],
                            positions.array[i0 + 2]
                        );
                        const v1 = new THREE.Vector3(
                            positions.array[i1],
                            positions.array[i1 + 1],
                            positions.array[i1 + 2]
                        );
                        const v2 = new THREE.Vector3(
                            positions.array[i2],
                            positions.array[i2 + 1],
                            positions.array[i2 + 2]
                        );
                        
                        // Transform to world space
                        v0.applyMatrix4(child.matrixWorld);
                        v1.applyMatrix4(child.matrixWorld);
                        v2.applyMatrix4(child.matrixWorld);
                        
                        const faceCenter = new THREE.Vector3()
                            .addVectors(v0, v1)
                            .add(v2)
                            .multiplyScalar(1/3);
                        
                        // Get face normal
                        const n0 = new THREE.Vector3(
                            normals.array[i0],
                            normals.array[i0 + 1],
                            normals.array[i0 + 2]
                        );
                        const normalMatrix = new THREE.Matrix3().getNormalMatrix(child.matrixWorld);
                        n0.applyMatrix3(normalMatrix).normalize();
                        
                        // Check if normal points away from camera (reversed)
                        const toCamera = new THREE.Vector3().subVectors(cameraPosition, faceCenter).normalize();
                        const dot = n0.dot(toCamera);
                        
                        // If dot <= 0, normal points away from camera (reversed)
                        if (dot <= 0) {
                            reversedFaces.push({
                                mesh: child,
                                faceIndex: i / 3,
                                faceCenter: faceCenter.clone(),
                                normal: n0.clone(),
                                faceId: getFaceId(child, i / 3)
                            });
                        }
                    }
                } else {
                    // Non-indexed geometry
                    const faceCount = positions.count / 3;
                    for (let i = 0; i < faceCount; i++) {
                        const i0 = i * 9;
                        const i1 = i * 9 + 3;
                        const i2 = i * 9 + 6;
                        
                        const v0 = new THREE.Vector3(
                            positions.array[i0],
                            positions.array[i0 + 1],
                            positions.array[i0 + 2]
                        );
                        const v1 = new THREE.Vector3(
                            positions.array[i1],
                            positions.array[i1 + 1],
                            positions.array[i1 + 2]
                        );
                        const v2 = new THREE.Vector3(
                            positions.array[i2],
                            positions.array[i2 + 1],
                            positions.array[i2 + 2]
                        );
                        
                        v0.applyMatrix4(child.matrixWorld);
                        v1.applyMatrix4(child.matrixWorld);
                        v2.applyMatrix4(child.matrixWorld);
                        
                        const faceCenter = new THREE.Vector3()
                            .addVectors(v0, v1)
                            .add(v2)
                            .multiplyScalar(1/3);
                        
                        const n0 = new THREE.Vector3(
                            normals.array[i0],
                            normals.array[i0 + 1],
                            normals.array[i0 + 2]
                        );
                        const normalMatrix = new THREE.Matrix3().getNormalMatrix(child.matrixWorld);
                        n0.applyMatrix3(normalMatrix).normalize();
                        
                        const toCamera = new THREE.Vector3().subVectors(cameraPosition, faceCenter).normalize();
                        const dot = n0.dot(toCamera);
                        
                        if (dot <= 0) {
                            reversedFaces.push({
                                mesh: child,
                                faceIndex: i,
                                faceCenter: faceCenter.clone(),
                                normal: n0.clone(),
                                faceId: getFaceId(child, i)
                            });
                        }
                    }
                }
            });
        });
        
        return reversedFaces;
    }
    
    // Helper function to encode face ID as RGB color
    function faceIdToColor(faceId) {
        // Use a hash function to convert faceId string to a color
        let hash = 0;
        for (let i = 0; i < faceId.length; i++) {
            hash = faceId.charCodeAt(i) + ((hash << 5) - hash);
        }
        // Convert to RGB (avoid pure black/white for better detection)
        const r = ((hash & 0xFF0000) >> 16) % 240 + 8; // 8-247
        const g = ((hash & 0x00FF00) >> 8) % 240 + 8;
        const b = (hash & 0x0000FF) % 240 + 8;
        return new THREE.Color(r / 255, g / 255, b / 255);
    }
    
    // Helper function to decode color back to face ID (approximate)
    function colorToFaceId(r, g, b) {
        // This is approximate - we'll need to maintain a mapping
        // For now, we'll use a different approach: store face ID -> color mapping
        return null; // Not used directly
    }
    
    // Function to render with face ID encoding (each face gets unique color)
    async function renderFaceIdsAt8K(cone) {
        const origSize = renderer.getSize(new THREE.Vector2());
        const origDPR = renderer.getPixelRatio();
        const origClearColor = renderer.getClearColor(new THREE.Color()).getHex();
        const origClearAlpha = renderer.getClearAlpha();
        const origAutoClear = renderer.autoClear;
        const origToneMapping = renderer.toneMapping;
        const origOutputColorSpace = renderer.outputColorSpace || renderer.outputEncoding;
        
        // Create mapping: faceId -> color and faceId -> mesh UUID
        const faceIdToColorMap = new Map();
        const colorToFaceIdMap = new Map();
        const faceIdToMeshMap = new Map();
        const colorBuckets = new Map(); // quantized color buckets for fast tolerance lookup

        function addToColorBuckets(rInt, gInt, bInt, faceId) {
            const key = `${rInt >> 2},${gInt >> 2},${bInt >> 2}`; // bucket size 4 per channel
            if (!colorBuckets.has(key)) colorBuckets.set(key, []);
            colorBuckets.get(key).push({ r: rInt, g: gInt, b: bInt, faceId });
        }
        let faceIdCounter = 0;
        
        // Build face ID to color mapping
        objects.forEach(obj => {
            obj.traverse((child) => {
                if (!child.isMesh || !child.geometry) return;
                const geometry = child.geometry;
                if (!geometry.attributes.position) return;
                
                const positions = geometry.attributes.position;
                const hasIndex = geometry.index !== null;
                
                if (hasIndex) {
                    const index = geometry.index;
                    for (let i = 0; i < index.count; i += 3) {
                        const faceId = getFaceId(child, i / 3);
                        if (!faceIdToColorMap.has(faceId)) {
                            // Generate unique color for this face ID using hash (full 24-bit space)
                            const color = faceIdToColor(faceId);
                            const rInt = Math.max(1, Math.min(254, Math.round(color.r * 255)));
                            const gInt = Math.max(1, Math.min(254, Math.round(color.g * 255)));
                            const bInt = Math.max(1, Math.min(254, Math.round(color.b * 255)));
                            
                            faceIdToColorMap.set(faceId, new THREE.Color(rInt / 255, gInt / 255, bInt / 255));
                            colorToFaceIdMap.set(`${rInt},${gInt},${bInt}`, faceId);
                            addToColorBuckets(rInt, gInt, bInt, faceId);
                            faceIdToMeshMap.set(faceId, child.uuid);
                            faceIdCounter++;
                        }
                    }
                } else {
                    const faceCount = positions.count / 3;
                    for (let i = 0; i < faceCount; i++) {
                        const faceId = getFaceId(child, i);
                        if (!faceIdToColorMap.has(faceId)) {
                            // Generate unique color for this face ID using hash (full 24-bit space)
                            const color = faceIdToColor(faceId);
                            const rInt = Math.max(1, Math.min(254, Math.round(color.r * 255)));
                            const gInt = Math.max(1, Math.min(254, Math.round(color.g * 255)));
                            const bInt = Math.max(1, Math.min(254, Math.round(color.b * 255)));
                            
                            faceIdToColorMap.set(faceId, new THREE.Color(rInt / 255, gInt / 255, bInt / 255));
                            colorToFaceIdMap.set(`${rInt},${gInt},${bInt}`, faceId);
                            addToColorBuckets(rInt, gInt, bInt, faceId);
                            faceIdToMeshMap.set(faceId, child.uuid);
                            faceIdCounter++;
                        }
                    }
                }
            });
        });
        
        // Store original materials and replace with face ID colors
        // Create a new geometry with duplicated vertices for flat shading
        const originalMaterials = new Map();
        const originalGeometries = new Map();
        // Track geometries that have been processed to handle shared geometries
        const processedGeometries = new Map();
        
        // Update all matrix worlds before processing
        objects.forEach(obj => {
            obj.updateMatrixWorld(true);
        });
        
        objects.forEach(obj => {
            obj.traverse((child) => {
                if (!child.isMesh || !child.geometry || !child.material) return;
                originalMaterials.set(child, child.material);
                
                const geometry = child.geometry;
                if (!geometry.attributes.position) return;
                
                // Store ORIGINAL geometry BEFORE any cloning
                originalGeometries.set(child, geometry);
                
                // Check if this geometry has already been processed (shared geometry)
                // If so, we need to clone it for this mesh to avoid affecting other meshes
                let geometryToUse = geometry;
                if (processedGeometries.has(geometry)) {
                    // Geometry is shared - clone it for this mesh
                    geometryToUse = geometry.clone();
                    child.geometry = geometryToUse;
                    console.log(`Cloned shared geometry for mesh ${child.uuid} in face ID render`);
                }
                processedGeometries.set(geometry, true);
                
                // Ensure matrixWorld is up to date
                child.updateMatrixWorld(true);
                
                const positions = geometryToUse.attributes.position;
                const hasIndex = geometryToUse.index !== null;
                
                // Create new arrays for duplicated vertices (non-indexed)
                const newPositions = [];
                const newNormals = [];
                const newColors = [];
                
                if (hasIndex) {
                    const index = geometry.index;
                    const faceCount = index.count / 3;
                    
                    for (let i = 0; i < faceCount; i++) {
                        const faceId = getFaceId(child, i);
                        const color = faceIdToColorMap.get(faceId) || new THREE.Color(0.5, 0.5, 0.5);
                        
                        const i0 = index.getX(i * 3);
                        const i1 = index.getX(i * 3 + 1);
                        const i2 = index.getX(i * 3 + 2);
                        
                        // Get face vertices
                        const v0 = new THREE.Vector3(
                            positions.array[i0 * 3],
                            positions.array[i0 * 3 + 1],
                            positions.array[i0 * 3 + 2]
                        );
                        const v1 = new THREE.Vector3(
                            positions.array[i1 * 3],
                            positions.array[i1 * 3 + 1],
                            positions.array[i1 * 3 + 2]
                        );
                        const v2 = new THREE.Vector3(
                            positions.array[i2 * 3],
                            positions.array[i2 * 3 + 1],
                            positions.array[i2 * 3 + 2]
                        );
                        
                        // Compute face normal
                        const edge1 = new THREE.Vector3().subVectors(v1, v0);
                        const edge2 = new THREE.Vector3().subVectors(v2, v0);
                        const faceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                        
                        // Duplicate vertices for this face (each face gets its own vertices)
                        // Vertex 0
                        newPositions.push(v0.x, v0.y, v0.z);
                        newNormals.push(faceNormal.x, faceNormal.y, faceNormal.z);
                        newColors.push(color.r, color.g, color.b);
                        
                        // Vertex 1
                        newPositions.push(v1.x, v1.y, v1.z);
                        newNormals.push(faceNormal.x, faceNormal.y, faceNormal.z);
                        newColors.push(color.r, color.g, color.b);
                        
                        // Vertex 2
                        newPositions.push(v2.x, v2.y, v2.z);
                        newNormals.push(faceNormal.x, faceNormal.y, faceNormal.z);
                        newColors.push(color.r, color.g, color.b);
                    }
                } else {
                    // Non-indexed geometry - already has separate vertices per face
                    const faceCount = positions.count / 3;
                    
                    for (let i = 0; i < faceCount; i++) {
                        const faceId = getFaceId(child, i);
                        const color = faceIdToColorMap.get(faceId) || new THREE.Color(0.5, 0.5, 0.5);
                        
                        const baseIdx = i * 9;
                        
                        // Get face vertices
                        const v0 = new THREE.Vector3(
                            positions.array[baseIdx],
                            positions.array[baseIdx + 1],
                            positions.array[baseIdx + 2]
                        );
                        const v1 = new THREE.Vector3(
                            positions.array[baseIdx + 3],
                            positions.array[baseIdx + 4],
                            positions.array[baseIdx + 5]
                        );
                        const v2 = new THREE.Vector3(
                            positions.array[baseIdx + 6],
                            positions.array[baseIdx + 7],
                            positions.array[baseIdx + 8]
                        );
                        
                        // Compute face normal
                        const edge1 = new THREE.Vector3().subVectors(v1, v0);
                        const edge2 = new THREE.Vector3().subVectors(v2, v0);
                        const faceNormal = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                        
                        // Add vertices (already separate, but ensure same color and normal)
                        newPositions.push(v0.x, v0.y, v0.z);
                        newNormals.push(faceNormal.x, faceNormal.y, faceNormal.z);
                        newColors.push(color.r, color.g, color.b);
                        
                        newPositions.push(v1.x, v1.y, v1.z);
                        newNormals.push(faceNormal.x, faceNormal.y, faceNormal.z);
                        newColors.push(color.r, color.g, color.b);
                        
                        newPositions.push(v2.x, v2.y, v2.z);
                        newNormals.push(faceNormal.x, faceNormal.y, faceNormal.z);
                        newColors.push(color.r, color.g, color.b);
                    }
                }
                
                // Create new non-indexed geometry
                // (original geometry already stored above, before cloning)
                const flatGeometry = new THREE.BufferGeometry();
                flatGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                flatGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
                flatGeometry.setAttribute('color', new THREE.Float32BufferAttribute(newColors, 3));
                
                // Replace geometry with flat version
                child.geometry = flatGeometry;
                
                const faceIdMaterial = new THREE.MeshBasicMaterial({
                    vertexColors: true,
                    side: THREE.DoubleSide
                });
                child.material = faceIdMaterial;
            });
        });
        
        // Add lights
        const lights = markers.map((mark) => {
            const light = new THREE.PointLight(0xffffff, 10, 0, 0.8);
            const worldPos = new THREE.Vector3();
            mark.getWorldPosition(worldPos);
            light.position.copy(worldPos);
            scene.add(light);
            return light;
        });
        
        markers.forEach((m) => (m.visible = false));
        
        // Get camera position
        const worldPos = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        cone.getWorldPosition(worldPos);
        cone.getWorldQuaternion(worldQuat);
        
        // Create 8K cube render target
        const cubeRenderTarget8K = new THREE.WebGLCubeRenderTarget(4096, {
            format: THREE.RGBAFormat,
            generateMipmaps: false,
            minFilter: THREE.LinearFilter,
        });
        const cubeCamera8K = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget8K);
        cubeCamera8K.position.copy(worldPos);
        cubeCamera8K.quaternion.copy(worldQuat);
        cubeCamera8K.quaternion.multiply(
            new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2)
        );
        scene.add(cubeCamera8K);
        
        cubeCamera8K.update(renderer, scene);
        
        // Render equirectangular at 8K (8192x4096)
        const eqWidth = 8192;
        const eqHeight = 4096;
        renderer.setPixelRatio(1);
        renderer.setSize(eqWidth, eqHeight);
        renderer.setRenderTarget(null);
        renderer.autoClear = true;
        renderer.toneMapping = THREE.NoToneMapping;
        if (renderer.outputColorSpace !== undefined) {
            renderer.outputColorSpace = THREE.LinearSRGBColorSpace;
        } else {
            renderer.outputEncoding = THREE.LinearEncoding;
        }
        renderer.setClearColor(0x000000, 1);
        renderer.clear(true, true, true);
        
        // Update equirectangular material to use 8K cubemap
        const originalEnvMap = eqMaterial.uniforms.envMap.value;
        eqMaterial.uniforms.envMap.value = cubeRenderTarget8K.texture;
        eqMaterial.needsUpdate = true;
        
        renderer.render(eqScene, eqCam);
        
        // Read pixels from WebGL canvas
        const idCanvas = renderer.domElement;
        const gl = renderer.getContext();
        const pixels = new Uint8Array(eqWidth * eqHeight * 4);
        gl.readPixels(0, 0, eqWidth, eqHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        
        // Flip Y axis (WebGL has origin at bottom-left, ImageData has origin at top-left)
        const flippedPixels = new Uint8Array(eqWidth * eqHeight * 4);
        for (let y = 0; y < eqHeight; y++) {
            const srcRow = (eqHeight - 1 - y) * eqWidth * 4;
            const dstRow = y * eqWidth * 4;
            flippedPixels.set(pixels.subarray(srcRow, srcRow + eqWidth * 4), dstRow);
        }
        
        const idImageData = new ImageData(
            new Uint8ClampedArray(flippedPixels),
            eqWidth,
            eqHeight
        );
        
        // Restore materials and geometries
        originalMaterials.forEach((originalMaterial, mesh) => {
            mesh.material = originalMaterial;
        });
        originalGeometries.forEach((originalGeometry, mesh) => {
            mesh.geometry = originalGeometry;
        });
        
        // Restore equirectangular material
        eqMaterial.uniforms.envMap.value = originalEnvMap;
        eqMaterial.needsUpdate = true;
        
        lights.forEach((l) => scene.remove(l));
        markers.forEach((m) => (m.visible = true));
        
        // Cleanup 8K cube camera
        scene.remove(cubeCamera8K);
        cubeRenderTarget8K.dispose();
        
        // Restore renderer state
        renderer.setPixelRatio(origDPR);
        renderer.setSize(origSize.x, origSize.y, true);
        renderer.setClearColor(origClearColor, origClearAlpha);
        renderer.autoClear = origAutoClear;
        renderer.toneMapping = origToneMapping;
        if (renderer.outputColorSpace !== undefined) {
            renderer.outputColorSpace = origOutputColorSpace;
        } else {
            renderer.outputEncoding = origOutputColorSpace;
        }
        
        // Show preview in render window
        showRenderPreview(idImageData, (cone.name || 'Face ID Render') + ' - Face IDs');
        
        return { imageData: idImageData, colorToFaceIdMap, colorBuckets, faceIdToColorMap, faceIdToMeshMap, width: eqWidth, height: eqHeight };
    }
    
    // Function to render normals at 8K resolution
    async function render360SnapshotForConeAt8K(cone, showNormals = false) {
        const origSize = renderer.getSize(new THREE.Vector2());
        const origDPR = renderer.getPixelRatio();
        const origClearColor = renderer.getClearColor(new THREE.Color()).getHex();
        const origClearAlpha = renderer.getClearAlpha();
        const origAutoClear = renderer.autoClear;
        
        // Add lights
        const lights = markers.map((mark) => {
            const light = new THREE.PointLight(0xffffff, 10, 0, 0.8);
            const worldPos = new THREE.Vector3();
            mark.getWorldPosition(worldPos);
            light.position.copy(worldPos);
            scene.add(light);
            return light;
        });
        
        markers.forEach((m) => (m.visible = false));
        
        // Get camera position
        const worldPos = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        cone.getWorldPosition(worldPos);
        cone.getWorldQuaternion(worldQuat);
        
        let prevOverride = scene.overrideMaterial;
        let originalMaterials = new Map();
        let originalGeometries = new Map();
        
        if (showNormals) {
            // Store original materials and geometries, then replace with face-orientation materials
            // Use duplicated vertices to prevent color interpolation (flat shading)
            // Track geometries that have been processed to handle shared geometries
            const processedGeometries = new Map();
            
            // Update all matrix worlds before processing
            objects.forEach(obj => {
                obj.updateMatrixWorld(true);
            });
            
            objects.forEach(obj => {
                obj.traverse((child) => {
                    if (child.isMesh && child.material && child.geometry) {
                        originalMaterials.set(child, child.material);
                        
                        const geometry = child.geometry;
                        if (!geometry.attributes.position) return;
                        
                        // Store ORIGINAL geometry BEFORE any cloning
                        originalGeometries.set(child, geometry);
                        
                        // Check if this geometry has already been processed (shared geometry)
                        // If so, we need to clone it for this mesh to avoid affecting other meshes
                        let geometryToUse = geometry;
                        if (processedGeometries.has(geometry)) {
                            // Geometry is shared - clone it for this mesh
                            geometryToUse = geometry.clone();
                            child.geometry = geometryToUse;
                            console.log(`Cloned shared geometry for mesh ${child.uuid}`);
                        }
                        processedGeometries.set(geometry, true);
                        
                        // Ensure matrixWorld is up to date
                        child.updateMatrixWorld(true);
                        
                        const positions = geometryToUse.attributes.position;
                        const hasIndex = geometryToUse.index !== null;
                        
                        // Create new arrays for duplicated vertices (non-indexed for flat shading)
                        const newPositions = [];
                        const newNormals = [];
                        const newColors = [];
                        
                        if (hasIndex) {
                            const index = geometryToUse.index;
                            const faceCount = index.count / 3;
                            
                            for (let i = 0; i < faceCount; i++) {
                                const i0 = index.getX(i * 3);
                                const i1 = index.getX(i * 3 + 1);
                                const i2 = index.getX(i * 3 + 2);
                                
                                // Get face vertices in local space
                                const v0Local = new THREE.Vector3(
                                    positions.array[i0 * 3],
                                    positions.array[i0 * 3 + 1],
                                    positions.array[i0 * 3 + 2]
                                );
                                const v1Local = new THREE.Vector3(
                                    positions.array[i1 * 3],
                                    positions.array[i1 * 3 + 1],
                                    positions.array[i1 * 3 + 2]
                                );
                                const v2Local = new THREE.Vector3(
                                    positions.array[i2 * 3],
                                    positions.array[i2 * 3 + 1],
                                    positions.array[i2 * 3 + 2]
                                );
                                
                                // Transform to world space for orientation check only
                                const v0 = v0Local.clone().applyMatrix4(child.matrixWorld);
                                const v1 = v1Local.clone().applyMatrix4(child.matrixWorld);
                                const v2 = v2Local.clone().applyMatrix4(child.matrixWorld);
                                
                                // Compute face center and flat normal in world space
                                const faceCenter = new THREE.Vector3()
                                    .addVectors(v0, v1)
                                    .add(v2)
                                    .multiplyScalar(1/3);
                                
                                // Compute flat face normal in world space
                                const edge1 = new THREE.Vector3().subVectors(v1, v0);
                                const edge2 = new THREE.Vector3().subVectors(v2, v0);
                                const faceNormalWorld = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                                
                                // Determine face orientation relative to camera
                                const toCamera = new THREE.Vector3().subVectors(worldPos, faceCenter).normalize();
                                const dot = faceNormalWorld.dot(toCamera);
                                
                                // Assign color based on orientation (same for all vertices of this face)
                                let faceColor;
                                if (dot > 0.0) {
                                    faceColor = [0.0, 0.0, 1.0]; // Blue (front-facing)
                                } else {
                                    faceColor = [1.0, 0.0, 0.0]; // Red (back-facing)
                                }
                                
                                // Compute local space normal for the geometry
                                const edge1Local = new THREE.Vector3().subVectors(v1Local, v0Local);
                                const edge2Local = new THREE.Vector3().subVectors(v2Local, v0Local);
                                const faceNormalLocal = new THREE.Vector3().crossVectors(edge1Local, edge2Local).normalize();
                                
                                // Store vertices in LOCAL space (mesh transform will be applied during render)
                                newPositions.push(v0Local.x, v0Local.y, v0Local.z);
                                newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                                newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                                
                                newPositions.push(v1Local.x, v1Local.y, v1Local.z);
                                newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                                newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                                
                                newPositions.push(v2Local.x, v2Local.y, v2Local.z);
                                newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                                newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                            }
                        } else {
                            // Non-indexed geometry - already has separate vertices per face
                            const faceCount = positions.count / 3;
                            
                            for (let i = 0; i < faceCount; i++) {
                                const baseIdx = i * 9;
                                
                                // Get face vertices in local space
                                const v0Local = new THREE.Vector3(
                                    positions.array[baseIdx],
                                    positions.array[baseIdx + 1],
                                    positions.array[baseIdx + 2]
                                );
                                const v1Local = new THREE.Vector3(
                                    positions.array[baseIdx + 3],
                                    positions.array[baseIdx + 4],
                                    positions.array[baseIdx + 5]
                                );
                                const v2Local = new THREE.Vector3(
                                    positions.array[baseIdx + 6],
                                    positions.array[baseIdx + 7],
                                    positions.array[baseIdx + 8]
                                );
                                
                                // Transform to world space for orientation check only
                                const v0 = v0Local.clone().applyMatrix4(child.matrixWorld);
                                const v1 = v1Local.clone().applyMatrix4(child.matrixWorld);
                                const v2 = v2Local.clone().applyMatrix4(child.matrixWorld);
                                
                                // Compute face center and flat normal in world space
                                const faceCenter = new THREE.Vector3()
                                    .addVectors(v0, v1)
                                    .add(v2)
                                    .multiplyScalar(1/3);
                                
                                // Compute flat face normal in world space
                                const edge1 = new THREE.Vector3().subVectors(v1, v0);
                                const edge2 = new THREE.Vector3().subVectors(v2, v0);
                                const faceNormalWorld = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                                
                                // Determine face orientation relative to camera
                                const toCamera = new THREE.Vector3().subVectors(worldPos, faceCenter).normalize();
                                const dot = faceNormalWorld.dot(toCamera);
                                
                                // Assign color based on orientation (same for all vertices of this face)
                                let faceColor;
                                if (dot > 0.0) {
                                    faceColor = [0.0, 0.0, 1.0]; // Blue (front-facing)
                                } else {
                                    faceColor = [1.0, 0.0, 0.0]; // Red (back-facing)
                                }
                                
                                // Compute local space normal for the geometry
                                const edge1Local = new THREE.Vector3().subVectors(v1Local, v0Local);
                                const edge2Local = new THREE.Vector3().subVectors(v2Local, v0Local);
                                const faceNormalLocal = new THREE.Vector3().crossVectors(edge1Local, edge2Local).normalize();
                                
                                // Store vertices in LOCAL space (mesh transform will be applied during render)
                                newPositions.push(v0Local.x, v0Local.y, v0Local.z);
                                newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                                newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                                
                                newPositions.push(v1Local.x, v1Local.y, v1Local.z);
                                newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                                newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                                
                                newPositions.push(v2Local.x, v2Local.y, v2Local.z);
                                newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                                newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                            }
                        }
                        
                        // Create new non-indexed geometry with flat shading
                        // (original geometry already stored above, before cloning)
                        const flatGeometry = new THREE.BufferGeometry();
                        flatGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                        flatGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
                        flatGeometry.setAttribute('color', new THREE.Float32BufferAttribute(newColors, 3));
                        
                        // Replace geometry with flat version
                        child.geometry = flatGeometry;
                        
                        const faceOrientationMaterial = new THREE.MeshBasicMaterial({
                            vertexColors: true,
                            side: THREE.DoubleSide
                        });
                        child.material = faceOrientationMaterial;
                    }
                });
            });
        } else {
            const whiteMat = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                shininess: 30,
            });
            whiteMat.dithering = true;
            scene.overrideMaterial = whiteMat;
        }
        
        // Create 8K cube render target
        const cubeRenderTarget8K = new THREE.WebGLCubeRenderTarget(4096, {
            format: THREE.RGBAFormat,
            generateMipmaps: false,
            minFilter: THREE.LinearFilter,
        });
        const cubeCamera8K = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget8K);
        cubeCamera8K.position.copy(worldPos);
        cubeCamera8K.quaternion.copy(worldQuat);
        cubeCamera8K.quaternion.multiply(
            new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 2)
        );
        
        cubeCamera8K.update(renderer, scene);
        
        // Restore materials and geometries
        if (showNormals) {
            originalMaterials.forEach((originalMaterial, mesh) => {
                mesh.material = originalMaterial;
            });
            originalGeometries.forEach((originalGeometry, mesh) => {
                mesh.geometry = originalGeometry;
            });
        } else {
            scene.overrideMaterial = prevOverride;
        }
        
        markers.forEach((m) => (m.visible = true));
        
        // Render equirectangular at 8K (8192x4096)
        const eqWidth = 8192;
        const eqHeight = 4096;
        renderer.setPixelRatio(1);
        renderer.setSize(eqWidth, eqHeight);
        renderer.setRenderTarget(null);
        renderer.autoClear = true;
        renderer.setClearColor(0x000000, 1);
        renderer.clear(true, true, true);
        
        // Update equirectangular material to use 8K cubemap
        const originalEnvMap = eqMaterial.uniforms.envMap.value;
        eqMaterial.uniforms.envMap.value = cubeRenderTarget8K.texture;
        eqMaterial.needsUpdate = true;
        
        renderer.render(eqScene, eqCam);
        
        // Read pixels from WebGL canvas
        const gl = renderer.getContext();
        const pixels = new Uint8Array(eqWidth * eqHeight * 4);
        gl.readPixels(0, 0, eqWidth, eqHeight, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        
        // Flip Y axis (WebGL has origin at bottom-left, ImageData has origin at top-left)
        const flippedPixels = new Uint8Array(eqWidth * eqHeight * 4);
        for (let y = 0; y < eqHeight; y++) {
            const srcRow = (eqHeight - 1 - y) * eqWidth * 4;
            const dstRow = y * eqWidth * 4;
            flippedPixels.set(pixels.subarray(srcRow, srcRow + eqWidth * 4), dstRow);
        }
        
        const imageData = new ImageData(
            new Uint8ClampedArray(flippedPixels),
            eqWidth,
            eqHeight
        );
        
        // Restore equirectangular material
        eqMaterial.uniforms.envMap.value = originalEnvMap;
        eqMaterial.needsUpdate = true;
        
        lights.forEach((l) => scene.remove(l));
        
        // Cleanup 8K cube camera
        scene.remove(cubeCamera8K);
        cubeRenderTarget8K.dispose();
        
        // Restore renderer state
        renderer.setPixelRatio(origDPR);
        renderer.setSize(origSize.x, origSize.y, true);
        renderer.setClearColor(origClearColor, origClearAlpha);
        renderer.autoClear = origAutoClear;
        
        // Show preview in render window
        showRenderPreview(imageData, cone.name || '8K Render');
        
        return { imageData, width: eqWidth, height: eqHeight };
    }
    
    // Store renders for first 3 cameras for export
    let renderExports = [];
    let exportLogsEnabled = false;
    
    function updateSelectCurrentButtonVisibility() {
        const btn = document.getElementById("select-reversed-faces-current") as HTMLButtonElement;
        if (btn) {
            btn.style.display = currentSelectedCone ? "block" : "none";
        }
    }
    
    // Function to export render images and debug info as zip
    async function exportRenderZip(cameraIndex, coneName, idRender, normalRender, redFaces, faceIdToMeshInfo) {
        const zip = new JSZip();
        const folder = zip.folder(`camera_${cameraIndex}_${coneName}`);
        
        // Convert ImageData to PNG for ID render
        const idCanvas = document.createElement('canvas');
        idCanvas.width = idRender.width;
        idCanvas.height = idRender.height;
        const idCtx = idCanvas.getContext('2d');
        if (idCtx) {
            idCtx.putImageData(idRender.imageData, 0, 0);
            const idBlob = await new Promise((resolve) => {
                idCanvas.toBlob((blob) => resolve(blob), 'image/png');
            });
            if (idBlob) {
                folder.file('face-id-render.png', idBlob);
            }
        }
        
        // Convert ImageData to PNG for normals render
        const normalCanvas = document.createElement('canvas');
        normalCanvas.width = normalRender.width;
        normalCanvas.height = normalRender.height;
        const normalCtx = normalCanvas.getContext('2d');
        if (normalCtx) {
            normalCtx.putImageData(normalRender.imageData, 0, 0);
            const normalBlob = await new Promise((resolve) => {
                normalCanvas.toBlob((blob) => resolve(blob), 'image/png');
            });
            if (normalBlob) {
                folder.file('normals-render.png', normalBlob);
            }
        }
        
        // Export viewport
        renderer.render(scene, currentCamera);
        const viewportDataURL = renderer.domElement.toDataURL('image/png');
        const viewportBlob = await (await fetch(viewportDataURL)).blob();
        folder.file('viewport.png', viewportBlob);
        
        // Export debug info as JSON
        const debugInfo = {
            cameraIndex: cameraIndex,
            coneName: coneName,
            redFacesCount: redFaces.size,
            redFaceIds: Array.from(redFaces).slice(0, 100), // First 100 face IDs
            faceIdToMeshInfo: faceIdToMeshInfo ? Array.from(faceIdToMeshInfo.entries()).map(([faceId, info]) => ({
                faceId: faceId,
                meshName: info.meshName,
                meshUuid: info.meshUuid,
                parentName: info.parentName,
                faceIndex: info.faceIndex,
                totalFaces: info.totalFaces,
                isSphere: info.isSphere
            })) : [],
            renderDimensions: {
                idRender: { width: idRender.width, height: idRender.height },
                normalRender: { width: normalRender.width, height: normalRender.height }
            }
        };
        folder.file('debug-info.json', JSON.stringify(debugInfo, null, 2));
        
        // Generate and download zip
        const zipBlob = await zip.generateAsync({ type: 'blob' });
        saveBlob(zipBlob, `render-export-camera-${cameraIndex}-${coneName}.zip`);
        console.log(`Exported zip for camera ${cameraIndex}: render-export-camera-${cameraIndex}-${coneName}.zip`);
    }
    
    // Function to select all reversed faces from all cameras using 8K render comparison
    async function selectAllReversedFaces() {
        if (markers.length === 0) {
            console.log("No cameras found. Please import cameras first.");
            return;
        }
        
        if (objects.length === 0) {
            console.log("No models found. Please import a model first.");
            return;
        }
        
        const allReversedFaces = new Set();
        
        // Clear existing highlights and start fresh
        selectedReversedFaceIds.clear();
        updateSelectedReversedFacesHighlights();
        
        // Reset stored renders
        renderExports = [];
        
        console.log(`Starting to check ${markers.length} cameras for reversed faces using 8K render comparison...`);
        
        // Iterate through all visible camera markers
        for (let i = 0; i < markers.length; i++) {
            const cone = markers[i];
            if (cone.cameraPos && cone.parent && cone.parent.visible) {
                console.log(`Processing camera ${i + 1}/${markers.length} (${cone.name})...`);
                
                // Yield control to allow viewport updates between cameras
                await new Promise(resolve => requestAnimationFrame(resolve));
                
                // Step 1: Render face IDs at 8K
                console.log("  Rendering face IDs...");
                const idRender = await renderFaceIdsAt8K(cone);
                
                // Yield after render to allow viewport update
                await new Promise(resolve => requestAnimationFrame(resolve));
                
                // Step 2: Render normals at 8K
                console.log("  Rendering normals...");
                const normalRenderResult = await render360SnapshotForConeAt8K(cone, true);
                const normalImageData = normalRenderResult.imageData;
                
                // Yield after render to allow viewport update
                await new Promise(resolve => requestAnimationFrame(resolve));
                
                // Camera world position for visibility checks
                const cameraWorldPos = new THREE.Vector3();
                cone.getWorldPosition(cameraWorldPos);
                
                // Cache mesh info for later debugging/export
                const meshInfoByUuid = new Map();
                objects.forEach(obj => {
                    obj.traverse((mesh) => {
                        if (mesh.isMesh && mesh.geometry) {
                            const meshName = mesh.name || "unnamed";
                            const parentName = mesh.parent?.name || "unnamed parent";
                            const isSphere = meshName.toLowerCase().includes("sphere") || parentName.toLowerCase().includes("sphere") || obj.name?.toLowerCase().includes("sphere");
                            const faceCount = mesh.geometry.index ? mesh.geometry.index.count / 3 : (mesh.geometry.attributes.position?.count || 0) / 3;
                            meshInfoByUuid.set(mesh.uuid, { meshName, parentName, isSphere, faceCount });
                        }
                    });
                });
                
                // Step 3: Compare renders to find red faces
                console.log("  Comparing renders...");
                const idData = idRender.imageData.data;
                const normalData = normalImageData.data;
                const width = idRender.width;
                const height = idRender.height;
                
                // Sample pixels (check every Nth pixel for performance)
                const sampleRate = 4; // Check every 4th pixel
                const redFaces = new Set();
                
                // Build red mask on sampled grid
                const widthS = Math.ceil(width / sampleRate);
                const heightS = Math.ceil(height / sampleRate);
                const redMask = new Uint8Array(widthS * heightS);
                const isRed = (rr, gg, bb) => rr > 200 && gg < 50 && bb < 50;
                
                for (let yS = 0; yS < heightS; yS++) {
                    const y = yS * sampleRate;
                    if (y >= height) continue;
                    for (let xS = 0; xS < widthS; xS++) {
                        const x = xS * sampleRate;
                        if (x >= width) continue;
                        const idx = (y * width + x) * 4;
                        const r = normalData[idx];
                        const g = normalData[idx + 1];
                        const b = normalData[idx + 2];
                        if (!isRed(r, g, b)) continue;
                        // 4-neighbor strength
                        let redNeighbors = 0;
                        if (x > 0) {
                            const nIdx = (y * width + (x - 1)) * 4;
                            if (isRed(normalData[nIdx], normalData[nIdx + 1], normalData[nIdx + 2])) redNeighbors++;
                        }
                        if (x + 1 < width) {
                            const nIdx = (y * width + (x + 1)) * 4;
                            if (isRed(normalData[nIdx], normalData[nIdx + 1], normalData[nIdx + 2])) redNeighbors++;
                        }
                        if (y > 0) {
                            const nIdx = ((y - 1) * width + x) * 4;
                            if (isRed(normalData[nIdx], normalData[nIdx + 1], normalData[nIdx + 2])) redNeighbors++;
                        }
                        if (y + 1 < height) {
                            const nIdx = ((y + 1) * width + x) * 4;
                            if (isRed(normalData[nIdx], normalData[nIdx + 1], normalData[nIdx + 2])) redNeighbors++;
                        }
                        if (redNeighbors < 3) continue;
                        redMask[yS * widthS + xS] = 1;
                    }
                }
                
                // Connected components on the sampled mask with shape metrics
                const compIds = new Int32Array(widthS * heightS);
                compIds.fill(-1);
                const compMetrics = []; // {size, minX, maxX, minY, maxY, perimeter}
                let compCounter = 0;
                const stack = [];
                
                // Helper to check if pixel is on edge (has non-red neighbor)
                const isEdgePixel = (xS, yS) => {
                    if (xS === 0 || xS === widthS - 1 || yS === 0 || yS === heightS - 1) return true;
                    const neighbors = [
                        (yS - 1) * widthS + xS, // up
                        (yS + 1) * widthS + xS, // down
                        yS * widthS + (xS - 1), // left
                        yS * widthS + (xS + 1)  // right
                    ];
                    for (const n of neighbors) {
                        if (!redMask[n]) return true;
                    }
                    return false;
                };
                
                for (let yS = 0; yS < heightS; yS++) {
                    for (let xS = 0; xS < widthS; xS++) {
                        const idxS = yS * widthS + xS;
                        if (!redMask[idxS] || compIds[idxS] !== -1) continue;
                        
                        let size = 0;
                        let minX = xS, maxX = xS, minY = yS, maxY = yS;
                        let perimeter = 0;
                        
                        stack.length = 0;
                        stack.push(idxS);
                        compIds[idxS] = compCounter;
                        
                        while (stack.length) {
                            const cur = stack.pop();
                            size++;
                            const cx = cur % widthS;
                            const cy = (cur / widthS) | 0;
                            
                            // Update bounding box
                            if (cx < minX) minX = cx;
                            if (cx > maxX) maxX = cx;
                            if (cy < minY) minY = cy;
                            if (cy > maxY) maxY = cy;
                            
                            // Count perimeter
                            if (isEdgePixel(cx, cy)) perimeter++;
                            
                            const neighbors = [
                                cur - 1,
                                cur + 1,
                                cur - widthS,
                                cur + widthS
                            ];
                            if (cx === 0) neighbors[0] = -1;
                            if (cx === widthS - 1) neighbors[1] = -1;
                            if (cy === 0) neighbors[2] = -1;
                            if (cy === heightS - 1) neighbors[3] = -1;
                            for (const n of neighbors) {
                                if (n < 0) continue;
                                if (!redMask[n]) continue;
                                if (compIds[n] !== -1) continue;
                                compIds[n] = compCounter;
                                stack.push(n);
                            }
                        }
                        
                        const width = maxX - minX + 1;
                        const height = maxY - minY + 1;
                        const bboxArea = width * height;
                        const aspectRatio = Math.max(width / Math.max(height, 1), height / Math.max(width, 1));
                        const compactness = size / Math.max(bboxArea, 1); // 1.0 = perfect rectangle, lower = sparse
                        const perimeterToArea = perimeter / Math.max(size, 1);
                        
                        compMetrics[compCounter] = {
                            size,
                            minX, maxX, minY, maxY,
                            width, height,
                            perimeter,
                            aspectRatio,
                            compactness,
                            perimeterToArea
                        };
                        compCounter++;
                    }
                }
                
                // Filter thresholds
                const minRedRegionSize = 20; // minimum pixel count
                const minWidth = 2; // minimum bounding box width (in sampled pixels)
                const minHeight = 2; // minimum bounding box height (in sampled pixels)
                const maxAspectRatio = 8; // filter very thin lines (width/height or height/width)
                const minCompactness = 0.3; // filter very sparse regions (low = thin/scattered)
                const maxPerimeterToArea = 1.5; // filter high edge-to-area ratio (specks/thin lines)
                
                // Process only sufficiently large and compact red regions
                const chunkSize = 100; // rows before yielding
                let processedRows = 0;
                
                for (let yS = 0; yS < heightS; yS++) {
                    const y = yS * sampleRate;
                    if (y >= height) continue;
                    for (let xS = 0; xS < widthS; xS++) {
                        const idxS = yS * widthS + xS;
                        if (!redMask[idxS]) continue;
                        const compId = compIds[idxS];
                        if (compId === -1) continue;
                        
                        const metrics = compMetrics[compId];
                        // Apply all filters
                        if (metrics.size < minRedRegionSize) continue;
                        if (metrics.width < minWidth || metrics.height < minHeight) continue;
                        if (metrics.aspectRatio > maxAspectRatio) continue;
                        if (metrics.compactness < minCompactness) continue;
                        if (metrics.perimeterToArea > maxPerimeterToArea) continue;
                        
                        const x = xS * sampleRate;
                        if (x >= width) continue;
                        const idx = (y * width + x) * 4;
                        const idR = idData[idx];
                        const idG = idData[idx + 1];
                        const idB = idData[idx + 2];
                        
                        const idBrightness = (idR + idG + idB) / 3;
                        if (idBrightness < 10) continue;
                        
                        const exactColorKey = `${Math.floor(idR)},${Math.floor(idG)},${Math.floor(idB)}`;
                        let faceId = idRender.colorToFaceIdMap.get(exactColorKey);
                        let matchType = 'exact';
                        let matchDistance = 0;
                        
                        if (!faceId) {
                            const tolerance = 4;
                            let bestMatch = null;
                            let bestDistance = Infinity;
                            const bucketKeyBase = { r: idR >> 2, g: idG >> 2, b: idB >> 2 };
                            const bucketsToCheck = [];
                            for (let dr = -1; dr <= 1; dr++) {
                                for (let dg = -1; dg <= 1; dg++) {
                                    for (let db = -1; db <= 1; db++) {
                                        bucketsToCheck.push(`${bucketKeyBase.r + dr},${bucketKeyBase.g + dg},${bucketKeyBase.b + db}`);
                                    }
                                }
                            }
                            const colorBuckets = idRender.colorBuckets;
                            for (const key of bucketsToCheck) {
                                const bucket = colorBuckets?.get(key);
                                if (!bucket) continue;
                                for (const entry of bucket) {
                                    const distance = Math.abs(idR - entry.r) + Math.abs(idG - entry.g) + Math.abs(idB - entry.b);
                                    if (distance < bestDistance &&
                                        Math.abs(idR - entry.r) <= tolerance &&
                                        Math.abs(idG - entry.g) <= tolerance &&
                                        Math.abs(idB - entry.b) <= tolerance) {
                                        bestDistance = distance;
                                        bestMatch = entry.faceId;
                                    }
                                }
                            }
                            
                            if (bestMatch) {
                                faceId = bestMatch;
                                matchType = 'tolerance';
                                matchDistance = bestDistance;
                            }
                        }
                        
                        if (faceId) {
                            const expectedColor = idRender.faceIdToColorMap?.get(faceId);
                            if (expectedColor) {
                                const expectedR = Math.floor(expectedColor.r * 255);
                                const expectedG = Math.floor(expectedColor.g * 255);
                                const expectedB = Math.floor(expectedColor.b * 255);
                                const colorDiff = Math.abs(idR - expectedR) + Math.abs(idG - expectedG) + Math.abs(idB - expectedB);
                                
                                if (matchType === 'tolerance' && colorDiff > 6) {
                                    if (redFaces.size === 0 && x % 500 === 0 && y % 500 === 0) {
                                        console.warn(`  Skipped potential color collision: faceId ${faceId}, expected rgb(${expectedR}, ${expectedG}, ${expectedB}), got rgb(${idR}, ${idG}, ${idB}), diff: ${colorDiff}`);
                                    }
                                    continue;
                                }
                            }
                            
                            redFaces.add(faceId);
                            if (redFaces.size <= 5) {
                                console.log(`  Found red face ID: ${faceId}, at pixel (${x}, ${y}), ID color: rgb(${idR}, ${idG}, ${idB}), match: ${matchType}, distance: ${matchDistance}`);
                            }
                        } else {
                            if (redFaces.size < 3 && x % 100 === 0 && y % 100 === 0) {
                                console.warn(`  Red pixel at (${x}, ${y}) but no matching face ID. ID color: rgb(${idR}, ${idG}, ${idB}), brightness: ${idBrightness.toFixed(1)}`);
                            }
                        }
                    }
                    
                    processedRows++;
                    if (processedRows >= chunkSize) {
                        processedRows = 0;
                        await new Promise(resolve => requestAnimationFrame(resolve));
                    }
                }
                
                // Add found faces to the global set and update highlights in real-time
                redFaces.forEach(faceId => {
                    allReversedFaces.add(faceId);
                    selectedReversedFaceIds.add(faceId);
                });
                
                console.log(`  Camera ${i + 1}/${markers.length} (${cone.name}): Found ${redFaces.size} reversed faces`);
                
                // Try to identify which meshes these faces belong to
                let faceIdToMeshInfo = new Map();
                if (redFaces.size > 0) {
                    // Build faceId -> mesh info using cached mappings for all red faces
                    redFaces.forEach(faceId => {
                        const meshUuid = idRender.faceIdToMeshMap?.get(faceId);
                        if (!meshUuid) return;
                        const meshInfo = meshInfoByUuid.get(meshUuid);
                        if (!meshInfo) return;
                        const faceIndex = parseInt(faceId.split('-').pop());
                        faceIdToMeshInfo.set(faceId, {
                            faceId,
                            meshName: meshInfo.meshName,
                            meshUuid,
                            parentName: meshInfo.parentName,
                            faceIndex,
                            totalFaces: meshInfo.faceCount,
                            isSphere: meshInfo.isSphere
                        });
                    });
                    
                    // Log a small sample for visibility
                    const sampleFaceIds = Array.from(redFaces).slice(0, 10);
                    console.log(`  Sample face IDs:`, sampleFaceIds);
                    console.log(`  Face IDs belong to meshes:`, Array.from(faceIdToMeshInfo.entries()).slice(0, 10));
                }
                
                // Export zip for first 3 cameras (if enabled)
                if (exportLogsEnabled && i < 3) {
                    await exportRenderZip(
                        i + 1,
                        cone.name,
                        {
                            imageData: idRender.imageData,
                            width: idRender.width,
                            height: idRender.height
                        },
                        {
                            imageData: normalImageData,
                            width: normalRenderResult.width,
                            height: normalRenderResult.height
                        },
                        redFaces,
                        faceIdToMeshInfo
                    );
                }
                
                // Update highlights to show faces found so far
                updateSelectedReversedFacesHighlights();
                
                // Yield after processing each camera to allow viewport updates
                await new Promise(resolve => requestAnimationFrame(resolve));
            }
        }
        
        // Log results
        console.log("=== All Reversed Faces (Red Faces) ===");
        console.log(`Total unique reversed faces found across all cameras: ${allReversedFaces.size}`);
        console.log("Face identifiers:", Array.from(allReversedFaces).sort().slice(0, 20), "...");
        console.log("========================================");
        
        // Final update of highlights (already done incrementally, but ensure it's up to date)
        updateSelectedReversedFacesHighlights();
        
        return allReversedFaces;
    }
    
    // Function to create highlight meshes for selected reversed faces
    function updateSelectedReversedFacesHighlights() {
        // Clear existing highlights
        selectedReversedFacesGroup.children.slice().forEach(child => {
            selectedReversedFacesGroup.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
        
        // Update flip button visibility
        const flipBtn = document.getElementById("flip-selected-normals");
        if (flipBtn) {
            flipBtn.style.display = selectedReversedFaceIds.size > 0 ? "block" : "none";
        }
        
        if (selectedReversedFaceIds.size === 0) {
            console.log("No selected reversed faces to highlight");
            return;
        }
        
        console.log(`Updating highlights for ${selectedReversedFaceIds.size} selected reversed faces`);
        console.log("Sample face IDs in set:", Array.from(selectedReversedFaceIds).slice(0, 5));
        
        // Group faces by mesh
        const facesByMesh = new Map();
        let totalFacesChecked = 0;
        let totalFacesMatched = 0;
        
        // Find all faces that match the selected face IDs
        objects.forEach(obj => {
            obj.traverse((child) => {
                if (!child.isMesh || !child.geometry) return;
                
                const geometry = child.geometry;
                if (!geometry.attributes.position || !geometry.attributes.normal) return;
                
                const positions = geometry.attributes.position;
                const hasIndex = geometry.index !== null;
                const faceIndices = [];
                
                if (hasIndex) {
                    const index = geometry.index;
                    const faceCount = index.count / 3;
                    totalFacesChecked += faceCount;
                    for (let i = 0; i < index.count; i += 3) {
                        const faceIdx = i / 3;
                        const faceId = getFaceId(child, faceIdx);
                        // Debug: log first few face IDs to see if they match
                        if (faceIdx < 3) {
                            console.log(`Face ${faceIdx} ID: ${faceId}, in set: ${selectedReversedFaceIds.has(faceId)}`);
                        }
                        if (selectedReversedFaceIds.has(faceId)) {
                            faceIndices.push(faceIdx);
                            totalFacesMatched++;
                        }
                    }
                } else {
                    const faceCount = positions.count / 3;
                    totalFacesChecked += faceCount;
                    for (let i = 0; i < faceCount; i++) {
                        const faceId = getFaceId(child, i);
                        // Debug: log first few face IDs
                        if (i < 3) {
                            console.log(`Face ${i} ID: ${faceId}, in set: ${selectedReversedFaceIds.has(faceId)}`);
                        }
                        if (selectedReversedFaceIds.has(faceId)) {
                            faceIndices.push(i);
                            totalFacesMatched++;
                        }
                    }
                }
                
                if (faceIndices.length > 0) {
                    if (!facesByMesh.has(child)) {
                        facesByMesh.set(child, []);
                    }
                    facesByMesh.get(child).push(...faceIndices);
                }
            });
        });
        
        console.log(`Checked ${totalFacesChecked} total faces, matched ${totalFacesMatched} faces`);
        console.log(`Found ${facesByMesh.size} meshes with selected faces`);
        
        // Create highlight meshes
        let totalHighlightFaces = 0;
        facesByMesh.forEach((faceIndices, mesh) => {
            try {
                // Verify face indices are actually in the selected set
                const verifiedFaceIndices = faceIndices.filter(faceIdx => {
                    const faceId = getFaceId(mesh, faceIdx);
                    return selectedReversedFaceIds.has(faceId);
                });
                
                if (verifiedFaceIndices.length === 0) {
                    console.warn(`Mesh ${mesh.uuid} had ${faceIndices.length} face indices but none matched after verification`);
                    return;
                }
                
                totalHighlightFaces += verifiedFaceIndices.length;
                const highlightGeometry = extractFacesToGeometry(mesh, verifiedFaceIndices);
                const redMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff0000,
                    side: THREE.DoubleSide,
                    depthTest: true,
                    depthWrite: true,
                    transparent: true,
                    opacity: 0.8
                });
                
                const highlightMesh = new THREE.Mesh(highlightGeometry, redMaterial);
                highlightMesh.userData.parentMesh = mesh;
                highlightMesh.userData.faceIndices = verifiedFaceIndices;
                highlightMesh.renderOrder = 100; // Render on top
                
                // Match parent mesh transform
                mesh.updateMatrixWorld(true);
                mesh.matrixWorld.decompose(
                    highlightMesh.position,
                    highlightMesh.quaternion,
                    highlightMesh.scale
                );
                highlightMesh.updateMatrixWorld(true);
                
                selectedReversedFacesGroup.add(highlightMesh);
            } catch (error) {
                console.error("Error creating highlight mesh:", error);
            }
        });
        
        console.log(`Created ${selectedReversedFacesGroup.children.length} highlight meshes with ${totalHighlightFaces} total faces`);
    }
    
    // Helper function to project 3D position to 2D equirectangular coordinates
    function projectToEquirectangular(worldPos, cameraPos, width, height) {
        // Direction from camera to face center
        const dir = new THREE.Vector3().subVectors(worldPos, cameraPos).normalize();
        
        // Convert to spherical coordinates
        const phi = Math.atan2(dir.z, dir.x); // azimuth [-Ï€, Ï€]
        const theta = Math.acos(dir.y); // elevation [0, Ï€]
        
        // Convert to UV coordinates [0, 1]
        const u = (phi + Math.PI) / (2 * Math.PI); // [0, 1]
        const v = theta / Math.PI; // [0, 1]
        
        // Convert to pixel coordinates
        const x = u * width;
        const y = v * height;
        
        return { x, y, u, v };
    }
    
    // Helper function to extract faces into geometry
    function extractFacesToGeometry(mesh, faceIndices) {
        const geometry = mesh.geometry;
        const extractedGeometry = new THREE.BufferGeometry();
        const positions = [];
        const normals = [];
        
        const posAttr = geometry.attributes.position;
        const normAttr = geometry.attributes.normal;
        const hasIndex = geometry.index !== null;
        
        if (hasIndex) {
            const index = geometry.index;
            faceIndices.forEach(faceIdx => {
                const baseIdx = faceIdx * 3;
                for (let i = 0; i < 3; i++) {
                    const vertexIdx = index.getX(baseIdx + i);
                    const posIdx = vertexIdx * 3;
                    const normIdx = vertexIdx * 3;
                    
                    positions.push(
                        posAttr.array[posIdx],
                        posAttr.array[posIdx + 1],
                        posAttr.array[posIdx + 2]
                    );
                    normals.push(
                        normAttr.array[normIdx],
                        normAttr.array[normIdx + 1],
                        normAttr.array[normIdx + 2]
                    );
                }
            });
        } else {
            faceIndices.forEach(faceIdx => {
                const baseIdx = faceIdx * 9;
                for (let i = 0; i < 9; i++) {
                    positions.push(posAttr.array[baseIdx + i]);
                    normals.push(normAttr.array[baseIdx + i]);
                }
            });
        }
        
        extractedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        extractedGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
        
        return extractedGeometry;
    }
    
    // Function to flip normals of selected faces
    function flipSelectedNormals() {
        if (selectedReversedFaceIds.size === 0) {
            console.log("No faces selected to flip");
            return;
        }
        
        console.log(`Flipping normals for ${selectedReversedFaceIds.size} selected faces`);
        let totalFacesFlipped = 0;
        
        // Group faces by mesh
        const facesByMesh = new Map();
        
        // Find all faces that match the selected face IDs
        objects.forEach(obj => {
            obj.traverse((child) => {
                if (!child.isMesh || !child.geometry) return;
                
                const geometry = child.geometry;
                if (!geometry.attributes.position || !geometry.attributes.normal) return;
                
                const hasIndex = geometry.index !== null;
                const faceIndices = [];
                
                if (hasIndex) {
                    const index = geometry.index;
                    const faceCount = index.count / 3;
                    for (let i = 0; i < faceCount; i++) {
                        const faceId = getFaceId(child, i);
                        if (selectedReversedFaceIds.has(faceId)) {
                            faceIndices.push(i);
                        }
                    }
                } else {
                    const positions = geometry.attributes.position;
                    const faceCount = positions.count / 3;
                    for (let i = 0; i < faceCount; i++) {
                        const faceId = getFaceId(child, i);
                        if (selectedReversedFaceIds.has(faceId)) {
                            faceIndices.push(i);
                        }
                    }
                }
                
                if (faceIndices.length > 0) {
                    facesByMesh.set(child, faceIndices);
                }
            });
        });
        
        // Flip faces for each mesh
        facesByMesh.forEach((faceIndices, mesh) => {
            const geometry = mesh.geometry;
            const hasIndex = geometry.index !== null;
            
            if (hasIndex) {
                // For indexed geometry, swap two indices to reverse winding order
                const index = geometry.index;
                const indexArray = index.array;
                
                faceIndices.forEach(faceIdx => {
                    const baseIdx = faceIdx * 3;
                    // Swap indices at baseIdx+1 and baseIdx+2 to reverse winding
                    const temp = indexArray[baseIdx + 1];
                    indexArray[baseIdx + 1] = indexArray[baseIdx + 2];
                    indexArray[baseIdx + 2] = temp;
                    totalFacesFlipped++;
                });
                
                index.needsUpdate = true;
            } else {
                // For non-indexed geometry, swap vertex positions and normals
                const positions = geometry.attributes.position;
                const normals = geometry.attributes.normal;
                const posArray = positions.array;
                const normArray = normals.array;
                
                faceIndices.forEach(faceIdx => {
                    const basePosIdx = faceIdx * 9;
                    const baseNormIdx = faceIdx * 9;
                    
                    // Swap vertices 1 and 2 (indices 3-5 and 6-8)
                    // Swap positions
                    for (let i = 0; i < 3; i++) {
                        const temp = posArray[basePosIdx + 3 + i];
                        posArray[basePosIdx + 3 + i] = posArray[basePosIdx + 6 + i];
                        posArray[basePosIdx + 6 + i] = temp;
                    }
                    
                    // Swap normals
                    for (let i = 0; i < 3; i++) {
                        const temp = normArray[baseNormIdx + 3 + i];
                        normArray[baseNormIdx + 3 + i] = normArray[baseNormIdx + 6 + i];
                        normArray[baseNormIdx + 6 + i] = temp;
                    }
                    
                    totalFacesFlipped++;
                });
                
                positions.needsUpdate = true;
                normals.needsUpdate = true;
            }
            
            // Recompute normals to ensure they're correct
            geometry.computeVertexNormals();
        });
        
        console.log(`Flipped normals for ${totalFacesFlipped} faces across ${facesByMesh.size} meshes`);
        
        // Clear selection and update highlights
        selectedReversedFaceIds.clear();
        updateSelectedReversedFacesHighlights();
        
        // Update button visibility
        const flipBtn = document.getElementById("flip-selected-normals");
        if (flipBtn) {
            flipBtn.style.display = "none";
        }
    }
    
    // Function to flatten and combine all meshes (except spheres) into one mesh
    function flattenAndCombineMeshes() {
        if (objects.length === 0) {
            console.log("No objects to flatten");
            return;
        }
        
        console.log("Flattening and combining meshes...");
        
        // Update all matrix worlds
        objects.forEach(obj => {
            obj.updateMatrixWorld(true);
        });
        
        const meshesToCombine = [];
        const sphereObjects = [];
        const combinedPositions = [];
        const combinedNormals = [];
        const combinedColors = [];
        const combinedUvs = [];
        const combinedIndices = [];
        let vertexOffset = 0;
        
        // Helper to check if a mesh is a sphere
        const isSphereMesh = (mesh, parentObj) => {
            const meshName = mesh.name || "";
            const parentName = mesh.parent?.name || "";
            const objName = parentObj.name || "";
            return meshName.toLowerCase().includes("sphere") || 
                   parentName.toLowerCase().includes("sphere") || 
                   objName.toLowerCase().includes("sphere");
        };
        
        // Track which objects contain meshes to combine vs spheres
        const objectsToRemove = [];
        
        // Collect all meshes and separate spheres
        // We'll combine non-sphere meshes and keep sphere meshes in their original objects
        objects.forEach(obj => {
            const sphereMeshesInObj = [];
            const nonSphereMeshesInObj = [];
            
            obj.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    if (isSphereMesh(child, obj)) {
                        sphereMeshesInObj.push(child);
                    } else {
                        nonSphereMeshesInObj.push(child);
                    }
                }
            });
            
            // If object has non-sphere meshes, add them to combine list and mark object for removal
            if (nonSphereMeshesInObj.length > 0) {
                nonSphereMeshesInObj.forEach(mesh => {
                    meshesToCombine.push(mesh);
                });
                objectsToRemove.push(obj);
                
                // If object also has sphere meshes, create a new group for just the spheres
                if (sphereMeshesInObj.length > 0) {
                    const sphereGroup = new THREE.Group();
                    sphereGroup.name = obj.name ? `${obj.name}_Spheres` : "SphereGroup";
                    // Copy transform from original object
                    sphereGroup.position.copy(obj.position);
                    sphereGroup.rotation.copy(obj.rotation);
                    sphereGroup.scale.copy(obj.scale);
                    
                    // Add sphere meshes to the group (they keep their relative transforms)
                    sphereMeshesInObj.forEach(mesh => {
                        const meshParent = mesh.parent;
                        mesh.parent.remove(mesh);
                        sphereGroup.add(mesh);
                    });
                    
                    sphereObjects.push(sphereGroup);
                }
            } else if (sphereMeshesInObj.length > 0) {
                // Object only contains spheres, keep it separate
                sphereObjects.push(obj);
            }
        });
        
        console.log(`Found ${meshesToCombine.length} meshes to combine, ${sphereObjects.length} sphere objects to keep separate`);
        console.log(`Will remove ${objectsToRemove.length} objects from scene`);
        
        // Debug: log mesh names to see what we're working with
        if (meshesToCombine.length === 0) {
            console.warn("No meshes to combine! All meshes might be spheres or objects are empty.");
            console.log("Debugging: Listing all meshes in objects:");
            objects.forEach((obj, idx) => {
                console.log(`Object ${idx}: ${obj.name || 'unnamed'}`);
                obj.traverse((child) => {
                    if (child.isMesh && child.geometry) {
                        const meshName = child.name || "unnamed";
                        const parentName = child.parent?.name || "unnamed parent";
                        const objName = obj.name || "unnamed obj";
                        const isSphere = isSphereMesh(child, obj);
                        console.log(`  - Mesh: ${meshName}, parent: ${parentName}, obj: ${objName}, isSphere: ${isSphere}`);
                    }
                });
            });
            return;
        }
        
        // Process each mesh to combine
        meshesToCombine.forEach(mesh => {
            const geometry = mesh.geometry;
            if (!geometry.attributes.position) return;
            
            // Ensure matrixWorld is up to date
            mesh.updateMatrixWorld(true);
            const matrixWorld = mesh.matrixWorld.clone();
            const normalMatrix = new THREE.Matrix3().getNormalMatrix(matrixWorld);
            
            const positions = geometry.attributes.position;
            const normals = geometry.attributes.normal;
            const colors = geometry.attributes.color;
            const uvs = geometry.attributes.uv;
            const hasIndex = geometry.index !== null;
            
            if (hasIndex) {
                const index = geometry.index;
                const vertexCount = positions.count;
                const indexCount = index.count;
                
                // Transform vertices to world space
                for (let i = 0; i < vertexCount; i++) {
                    const posIdx = i * 3;
                    const v = new THREE.Vector3(
                        positions.array[posIdx],
                        positions.array[posIdx + 1],
                        positions.array[posIdx + 2]
                    );
                    v.applyMatrix4(matrixWorld);
                    combinedPositions.push(v.x, v.y, v.z);
                    
                    // Transform normals
                    if (normals) {
                        const n = new THREE.Vector3(
                            normals.array[posIdx],
                            normals.array[posIdx + 1],
                            normals.array[posIdx + 2]
                        );
                        n.applyMatrix3(normalMatrix).normalize();
                        combinedNormals.push(n.x, n.y, n.z);
                    } else {
                        combinedNormals.push(0, 1, 0); // Default normal
                    }
                    
                    // Copy colors if available
                    if (colors) {
                        const colorIdx = i * 3;
                        combinedColors.push(
                            colors.array[colorIdx],
                            colors.array[colorIdx + 1],
                            colors.array[colorIdx + 2]
                        );
                    }
                    
                    // Copy UVs if available
                    if (uvs) {
                        const uvIdx = i * 2;
                        combinedUvs.push(
                            uvs.array[uvIdx],
                            uvs.array[uvIdx + 1]
                        );
                    }
                }
                
                // Copy indices with vertex offset
                for (let i = 0; i < indexCount; i++) {
                    const originalIndex = index.getX(i);
                    combinedIndices.push(vertexOffset + originalIndex);
                }
                
                vertexOffset += vertexCount;
            } else {
                // Non-indexed geometry
                const vertexCount = positions.count;
                
                for (let i = 0; i < vertexCount; i++) {
                    const posIdx = i * 3;
                    const v = new THREE.Vector3(
                        positions.array[posIdx],
                        positions.array[posIdx + 1],
                        positions.array[posIdx + 2]
                    );
                    v.applyMatrix4(matrixWorld);
                    combinedPositions.push(v.x, v.y, v.z);
                    
                    if (normals) {
                        const n = new THREE.Vector3(
                            normals.array[posIdx],
                            normals.array[posIdx + 1],
                            normals.array[posIdx + 2]
                        );
                        n.applyMatrix3(normalMatrix).normalize();
                        combinedNormals.push(n.x, n.y, n.z);
                    } else {
                        combinedNormals.push(0, 1, 0);
                    }
                    
                    if (colors) {
                        const colorIdx = i * 3;
                        combinedColors.push(
                            colors.array[colorIdx],
                            colors.array[colorIdx + 1],
                            colors.array[colorIdx + 2]
                        );
                    }
                    
                    if (uvs) {
                        const uvIdx = i * 2;
                        combinedUvs.push(
                            uvs.array[uvIdx],
                            uvs.array[uvIdx + 1]
                        );
                    }
                }
                
                vertexOffset += vertexCount;
            }
        });
        
        // Create combined geometry
        const combinedGeometry = new THREE.BufferGeometry();
        combinedGeometry.setAttribute('position', new THREE.Float32BufferAttribute(combinedPositions, 3));
        combinedGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(combinedNormals, 3));
        
        if (combinedColors.length > 0) {
            combinedGeometry.setAttribute('color', new THREE.Float32BufferAttribute(combinedColors, 3));
        }
        
        if (combinedUvs.length > 0) {
            combinedGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(combinedUvs, 2));
        }
        
        // Set indices if we have indexed geometry
        if (combinedIndices.length > 0) {
            combinedGeometry.setIndex(combinedIndices);
        }
        
        // Compute bounding box and sphere
        combinedGeometry.computeBoundingBox();
        combinedGeometry.computeBoundingSphere();
        
        // Create a single mesh with the combined geometry
        // Use the first mesh's material as a default, or create a basic material
        let combinedMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
        if (meshesToCombine.length > 0 && meshesToCombine[0].material) {
            const firstMaterial = meshesToCombine[0].material;
            if (Array.isArray(firstMaterial)) {
                combinedMaterial = firstMaterial[0].clone();
            } else {
                combinedMaterial = firstMaterial.clone();
            }
        }
        
        const combinedMesh = new THREE.Mesh(combinedGeometry, combinedMaterial);
        combinedMesh.name = "CombinedMesh";
        combinedMesh.position.set(0, 0, 0);
        combinedMesh.rotation.set(0, 0, 0);
        combinedMesh.scale.set(1, 1, 1);
        
        // Helper function to dispose of geometry and materials
        const disposeObject = (obj) => {
            obj.traverse((child) => {
                if (child.isMesh) {
                    const mesh = child;
                    if (mesh.geometry) {
                        mesh.geometry.dispose();
                    }
                    if (mesh.material) {
                        if (Array.isArray(mesh.material)) {
                            mesh.material.forEach(mat => mat.dispose());
                        } else {
                            mesh.material.dispose();
                        }
                    }
                }
            });
        };
        
        // Remove and dispose of old objects that are being combined
        objectsToRemove.forEach(obj => {
            disposeObject(obj);
            scene.remove(obj);
        });
        
        // Create new objects array
        const newObjects = [];
        
        // Add combined mesh
        if (combinedPositions.length > 0) {
            const combinedGroup = new THREE.Group();
            combinedGroup.name = "CombinedMeshes";
            combinedGroup.add(combinedMesh);
            scene.add(combinedGroup);
            newObjects.push(combinedGroup);
            console.log(`Created combined mesh with ${combinedPositions.length / 3} vertices, ${combinedIndices.length > 0 ? combinedIndices.length / 3 : combinedPositions.length / 9} faces`);
        } else {
            console.error("No vertices in combined geometry! Something went wrong.");
            return;
        }
        
        // Add sphere objects back (they were already in the scene, just re-add to objects array)
        sphereObjects.forEach(obj => {
            // Make sure they're still in the scene
            if (!scene.children.includes(obj)) {
                scene.add(obj);
            }
            newObjects.push(obj);
        });
        
        // Update objects array - completely replace it
        objects.length = 0;
        objects.push(...newObjects);
        
        console.log(`Flattened and combined ${meshesToCombine.length} meshes into 1 mesh, kept ${sphereObjects.length} sphere objects separate`);
        console.log(`New objects array has ${objects.length} objects`);
        
        // Force a render update
        if (renderer) {
            renderer.render(scene, camera);
        }
    }

async function render360SnapshotForCone(cone, allCones = markers, showNormals = false) {
    // 1) backup renderer state
    const origSize       = renderer.getSize(new THREE.Vector2());
    const origDPR        = renderer.getPixelRatio();
    const origClearColor = renderer.getClearColor(new THREE.Color()).getHex();
    const origClearAlpha = renderer.getClearAlpha();
    const origAutoClear  = renderer.autoClear;



    // 2) add a light at every cone in the group - use world positions
    const lights = markers.map((mark) => {
        const light = new THREE.PointLight(0xffffff, 10, 0, 0.8);
        const worldPos = new THREE.Vector3();
        mark.getWorldPosition(worldPos);
        light.position.copy(worldPos);
        scene.add(light);
        return light;
    });

    // Hide everything but the cones
    // scene.children.forEach(o => o.visible = false);
    // markers.forEach(m => {
    //   m.visible = true;
    //   // keep their original materials
    // });
    cone.visible = true

    markers.forEach((m) => (m.visible = false));

    // Capture cube map - use world position and quaternion to handle flipped parents
    const worldPos = new THREE.Vector3();
    const worldQuat = new THREE.Quaternion();
    cone.getWorldPosition(worldPos);
    cone.getWorldQuaternion(worldQuat);
    
    let prevOverride = scene.overrideMaterial;
    let originalMaterials = new Map();
    let originalGeometries = new Map();
    
    if (showNormals) {
        // Store original materials and geometries, then replace with face-orientation materials
        // Use duplicated vertices to prevent color interpolation (flat shading)
        // Track geometries that have been processed to handle shared geometries
        const processedGeometries = new Map();
        
        // Update all matrix worlds before processing
        objects.forEach(obj => {
            obj.updateMatrixWorld(true);
        });
        
        objects.forEach(obj => {
            obj.traverse((child) => {
                if (child.isMesh && child.material && child.geometry) {
                    originalMaterials.set(child, child.material);
                    
                    const geometry = child.geometry;
                    if (!geometry.attributes.position) return;
                    
                    // Store ORIGINAL geometry BEFORE any cloning
                    originalGeometries.set(child, geometry);
                    
                    // Check if this geometry has already been processed (shared geometry)
                    // If so, we need to clone it for this mesh to avoid affecting other meshes
                    let geometryToUse = geometry;
                    if (processedGeometries.has(geometry)) {
                        // Geometry is shared - clone it for this mesh
                        geometryToUse = geometry.clone();
                        child.geometry = geometryToUse;
                        console.log(`Cloned shared geometry for mesh ${child.uuid} in render360SnapshotForCone`);
                    }
                    processedGeometries.set(geometry, true);
                    
                    // Ensure matrixWorld is up to date
                    child.updateMatrixWorld(true);
                    
                    const positions = geometryToUse.attributes.position;
                    const hasIndex = geometryToUse.index !== null;
                    
                    // Create new arrays for duplicated vertices (non-indexed for flat shading)
                    const newPositions = [];
                    const newNormals = [];
                    const newColors = [];
                    
                    if (hasIndex) {
                        const index = geometryToUse.index;
                        const faceCount = index.count / 3;
                        
                        for (let i = 0; i < faceCount; i++) {
                            const i0 = index.getX(i * 3);
                            const i1 = index.getX(i * 3 + 1);
                            const i2 = index.getX(i * 3 + 2);
                            
                            // Get face vertices in local space
                            const v0Local = new THREE.Vector3(
                                positions.array[i0 * 3],
                                positions.array[i0 * 3 + 1],
                                positions.array[i0 * 3 + 2]
                            );
                            const v1Local = new THREE.Vector3(
                                positions.array[i1 * 3],
                                positions.array[i1 * 3 + 1],
                                positions.array[i1 * 3 + 2]
                            );
                            const v2Local = new THREE.Vector3(
                                positions.array[i2 * 3],
                                positions.array[i2 * 3 + 1],
                                positions.array[i2 * 3 + 2]
                            );
                            
                            // Transform to world space for orientation check only
                            const v0 = v0Local.clone().applyMatrix4(child.matrixWorld);
                            const v1 = v1Local.clone().applyMatrix4(child.matrixWorld);
                            const v2 = v2Local.clone().applyMatrix4(child.matrixWorld);
                            
                            // Compute face center and flat normal in world space
                            const faceCenter = new THREE.Vector3()
                                .addVectors(v0, v1)
                                .add(v2)
                                .multiplyScalar(1/3);
                            
                            // Compute flat face normal in world space
                            const edge1 = new THREE.Vector3().subVectors(v1, v0);
                            const edge2 = new THREE.Vector3().subVectors(v2, v0);
                            const faceNormalWorld = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                            
                            // Determine face orientation relative to camera
                            const toCamera = new THREE.Vector3().subVectors(worldPos, faceCenter).normalize();
                            const dot = faceNormalWorld.dot(toCamera);
                            
                            // Assign color based on orientation (same for all vertices of this face)
                            let faceColor;
                            if (dot > 0.0) {
                                faceColor = [0.0, 0.0, 1.0]; // Blue (front-facing)
                            } else {
                                faceColor = [1.0, 0.0, 0.0]; // Red (back-facing)
                            }
                            
                            // Compute local space normal for the geometry
                            const edge1Local = new THREE.Vector3().subVectors(v1Local, v0Local);
                            const edge2Local = new THREE.Vector3().subVectors(v2Local, v0Local);
                            const faceNormalLocal = new THREE.Vector3().crossVectors(edge1Local, edge2Local).normalize();
                            
                            // Store vertices in LOCAL space (mesh transform will be applied during render)
                            newPositions.push(v0Local.x, v0Local.y, v0Local.z);
                            newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                            newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                            
                            newPositions.push(v1Local.x, v1Local.y, v1Local.z);
                            newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                            newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                            
                            newPositions.push(v2Local.x, v2Local.y, v2Local.z);
                            newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                            newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                        }
                    } else {
                        // Non-indexed geometry - already has separate vertices per face
                        const faceCount = positions.count / 3;
                        
                        for (let i = 0; i < faceCount; i++) {
                            const baseIdx = i * 9;
                            
                            // Get face vertices in local space
                            const v0Local = new THREE.Vector3(
                                positions.array[baseIdx],
                                positions.array[baseIdx + 1],
                                positions.array[baseIdx + 2]
                            );
                            const v1Local = new THREE.Vector3(
                                positions.array[baseIdx + 3],
                                positions.array[baseIdx + 4],
                                positions.array[baseIdx + 5]
                            );
                            const v2Local = new THREE.Vector3(
                                positions.array[baseIdx + 6],
                                positions.array[baseIdx + 7],
                                positions.array[baseIdx + 8]
                            );
                            
                            // Transform to world space for orientation check only
                            const v0 = v0Local.clone().applyMatrix4(child.matrixWorld);
                            const v1 = v1Local.clone().applyMatrix4(child.matrixWorld);
                            const v2 = v2Local.clone().applyMatrix4(child.matrixWorld);
                            
                            // Compute face center and flat normal in world space
                            const faceCenter = new THREE.Vector3()
                                .addVectors(v0, v1)
                                .add(v2)
                                .multiplyScalar(1/3);
                            
                            // Compute flat face normal in world space
                            const edge1 = new THREE.Vector3().subVectors(v1, v0);
                            const edge2 = new THREE.Vector3().subVectors(v2, v0);
                            const faceNormalWorld = new THREE.Vector3().crossVectors(edge1, edge2).normalize();
                            
                            // Determine face orientation relative to camera
                            const toCamera = new THREE.Vector3().subVectors(worldPos, faceCenter).normalize();
                            const dot = faceNormalWorld.dot(toCamera);
                            
                            // Assign color based on orientation (same for all vertices of this face)
                            let faceColor;
                            if (dot > 0.0) {
                                faceColor = [0.0, 0.0, 1.0]; // Blue (front-facing)
                            } else {
                                faceColor = [1.0, 0.0, 0.0]; // Red (back-facing)
                            }
                            
                            // Compute local space normal for the geometry
                            const edge1Local = new THREE.Vector3().subVectors(v1Local, v0Local);
                            const edge2Local = new THREE.Vector3().subVectors(v2Local, v0Local);
                            const faceNormalLocal = new THREE.Vector3().crossVectors(edge1Local, edge2Local).normalize();
                            
                            // Store vertices in LOCAL space (mesh transform will be applied during render)
                            newPositions.push(v0Local.x, v0Local.y, v0Local.z);
                            newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                            newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                            
                            newPositions.push(v1Local.x, v1Local.y, v1Local.z);
                            newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                            newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                            
                            newPositions.push(v2Local.x, v2Local.y, v2Local.z);
                            newNormals.push(faceNormalLocal.x, faceNormalLocal.y, faceNormalLocal.z);
                            newColors.push(faceColor[0], faceColor[1], faceColor[2]);
                        }
                    }
                    
                    // Create new non-indexed geometry with flat shading
                    // (original geometry already stored above, before cloning)
                    const flatGeometry = new THREE.BufferGeometry();
                    flatGeometry.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
                    flatGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(newNormals, 3));
                    flatGeometry.setAttribute('color', new THREE.Float32BufferAttribute(newColors, 3));
                    
                    // Replace geometry with flat version
                    child.geometry = flatGeometry;
                    
                    const faceOrientationMaterial = new THREE.MeshBasicMaterial({
                        vertexColors: true,
                        side: THREE.DoubleSide
                    });
                    child.material = faceOrientationMaterial;
                }
            });
        });
    } else {
        const whiteMat = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            shininess: 30,
        });
        whiteMat.dithering = true;
        scene.overrideMaterial = whiteMat;
    }
    
    cubeCamera.position.copy(worldPos);
    cubeCamera.quaternion.copy(worldQuat);
    cubeCamera.quaternion.multiply(
      new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0,1,0),
        Math.PI/2
      )
    );
    
    // Detect reversed normals relative to camera position (only if not in normals mode)
    let reversedFaces = [];
    let reversedFacesGroup = new THREE.Group();
    let reversedFaceData = [];
    
    if (!showNormals) {
        reversedFaces = detectReversedNormalsFromCamera(worldPos);
        
        // Create a temporary group for reversed face highlights
        // Group faces by mesh for efficient rendering
        const facesByMesh = new Map();
        reversedFaces.forEach(faceData => {
            if (!facesByMesh.has(faceData.mesh)) {
                facesByMesh.set(faceData.mesh, []);
            }
            facesByMesh.get(faceData.mesh).push(faceData.faceIndex);
        });
        
        // Create highlight meshes for reversed faces
        facesByMesh.forEach((faceIndices, mesh) => {
            const highlightGeometry = extractFacesToGeometry(mesh, faceIndices);
            const redMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                side: THREE.DoubleSide,
                depthTest: true,
                depthWrite: false,
                transparent: true,
                opacity: 0.8
            });
            
            const highlightMesh = new THREE.Mesh(highlightGeometry, redMaterial);
            highlightMesh.userData.parentMesh = mesh;
            highlightMesh.userData.faceIndices = faceIndices;
            
            // Match parent mesh transform
            mesh.updateMatrixWorld(true);
            mesh.matrixWorld.decompose(
                highlightMesh.position,
                highlightMesh.quaternion,
                highlightMesh.scale
            );
            highlightMesh.updateMatrixWorld(true);
            
            reversedFacesGroup.add(highlightMesh);
            
            // Store face center positions for 2D projection
            faceIndices.forEach(faceIdx => {
                const faceData = reversedFaces.find(f => f.mesh === mesh && f.faceIndex === faceIdx);
                if (faceData) {
                    reversedFaceData.push(faceData);
                }
            });
        });
        
        // Add reversed faces group to scene temporarily
        scene.add(reversedFacesGroup);
    }
    
    renderer.autoClear = true
    cubeCamera.update(renderer, scene);

    // Restore materials and geometries
    if (showNormals) {
        originalMaterials.forEach((originalMaterial, mesh) => {
            mesh.material = originalMaterial;
        });
        originalGeometries.forEach((originalGeometry, mesh) => {
            mesh.geometry = originalGeometry;
        });
        originalMaterials.clear();
    } else {
    scene.overrideMaterial = prevOverride;
    }
    
    markers.forEach((m) => (m.visible = true));

    // 6) equirectangular pass (optimized for performance)
    // Equirectangular pass
    const eqWidth = 1024;
    const eqHeight = 512;
    renderer.setPixelRatio(1);
    renderer.setSize(eqWidth, eqHeight);
    renderer.setRenderTarget(null);
    renderer.autoClear = true;
    renderer.setClearColor(0x000000, 1);
    renderer.clear(true, true, true);
    renderer.render(eqScene, eqCam);

    // Source canvas
    const srcCanvas = renderer.domElement;

    const dataURL = srcCanvas.toDataURL("image/jpeg", 0.6); // Reduced quality for better performance
    
    // Project reversed face centers to 2D equirectangular coordinates
    const facePositions2D = reversedFaceData.map(faceData => {
        const proj = projectToEquirectangular(faceData.faceCenter, worldPos, eqWidth, eqHeight);
        return {
            x: proj.x,
            y: proj.y,
            u: proj.u,
            v: proj.v,
            faceCenter: faceData.faceCenter,
            normal: faceData.normal,
            mesh: faceData.mesh,
            faceIndex: faceData.faceIndex
        };
    });
    
    // Remove reversed faces group from scene (if it was created)
    if (reversedFacesGroup.children.length > 0) {
        scene.remove(reversedFacesGroup);
        reversedFacesGroup.children.forEach(child => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }

    // 8) re-enable wireframes
    originalWireframeMeshes.forEach(m => {
      m.material.wireframe = true;
      m.material.needsUpdate = true;
    });

    lights.forEach((l) => scene.remove(l));

    // 7) restore renderer state
    renderer.setPixelRatio(origDPR);
    renderer.setSize(origSize.x, origSize.y, true);
    renderer.setClearColor(origClearColor, origClearAlpha);
    renderer.autoClear = origAutoClear;

    // 9) Show preview in render window (always show preview when render completes)
    // Use setTimeout to ensure DOM is ready and to avoid conflicts with calling code
    setTimeout(() => {
        const panel = document.getElementById("vr-image-panel");
        const img = document.getElementById("vr-img") as HTMLImageElement;
        const widget = document.getElementById('vr-widget') as HTMLDivElement;
        
        if (panel && img && widget) {
            console.log('Setting up render preview...', { dataURLLength: dataURL.length, coneName: cone.name });
            
            // Ensure image element is visible and properly styled
            img.style.display = 'block';
            img.style.width = '100%';
            img.style.height = '100%';
            img.style.objectFit = 'contain';
            
            // Set image source and wait for it to load
            img.onload = function() {
                console.log('Render preview image loaded successfully in vr-img');
            };
            img.onerror = function(e) {
                console.error('Error loading render preview image:', e);
            };
            
            // Set the image source - this should trigger the onload
            img.src = dataURL;
            
            // Set up VR image rotation
            setVRImage(dataURL, cone.name || 'Render Preview');
            
            // Show widget and panel - ensure they're visible
            widget.style.display = 'block';
            panel.style.display = 'block';
            panel.classList.remove("hidden");
            
            // Hide overlay for generated views
            const vrOverlayCanvas = document.getElementById('vr-overlay-canvas') as HTMLCanvasElement;
            if (vrOverlayCanvas) {
                vrOverlayCanvas.style.display = 'none';
            }
            
            console.log('Render preview setup complete for:', cone.name || 'Render Preview');
        } else {
            console.warn('VR panel elements not found:', { panel: !!panel, img: !!img, widget: !!widget });
        }
    }, 0);

    // 10) return a JPEG data-URL and face positions
    return {
        dataURL: dataURL,
        facePositions: facePositions2D
    };
}

    /**
     * exportAll360ForGroup: exports one group's CSV+cones into a zip folder (or downloads directly)
     * @param {Object3D} groupObj - the CSV group object
     * @param {JSZip} [zipFolder] - optional JSZip folder for multi-group export
     */
    async function exportAll360ForGroup(groupObj, zipFolder) {
        const isRootCall = !zipFolder;
        // Capture original renderer state
        const origSize = renderer.getSize(new THREE.Vector2());
        const origDPR = renderer.getPixelRatio();
        const origClearColor = renderer
            .getClearColor(new THREE.Color())
            .getHex();
        const origClearAlpha = renderer.getClearAlpha();
        const origAutoClear = renderer.autoClear;
        const origPhysLights = renderer.physicallyCorrectLights;
        const origToneMapping = renderer.toneMapping;
        const origToneExp = renderer.toneMappingExposure;
        const origDither = renderer.dither;

        // Prepare ZIP target
        const zip = zipFolder || new JSZip();

        // Derive prefix from CSV name
        const base = groupObj.name.toLowerCase().replace(/\.csv$/, "");
        const prefix = base.split("_").slice(-5).join("_");
        console.log(
            `Starting export for group: ${groupObj.name}, prefix: ${prefix}`,
        );

        // Find cones
        const cones = groupObj.children.filter((ch) => ch.cameraPos);
        console.log(`Found ${cones.length} cones for group ${prefix}`);

        // Add lights once - use world positions to handle flipped parents
        const lights = cones.map((cone) => {
            const light = new THREE.PointLight(0xffffff, 20, 0, 0.8);
            const worldPos = new THREE.Vector3();
            cone.getWorldPosition(worldPos);
            light.position.copy(worldPos);
            scene.add(light);
            return light;
        });

        // Helper to yield control
        const tick = () => new Promise((r) => setTimeout(r, 0));

        // Single loop: render once per cone, then zip original + flipped
        for (let i = 0; i < cones.length; i++) {
            const cone = cones[i];
            const instanceName = `${prefix}_${cone.name}`.toLowerCase();
            console.log(
                `â–¶ [${groupObj.name}] Processing cone ${i + 1}/${cones.length}: ${instanceName}`,
            );

            // Hide cones and override material
            markers.forEach((m) => (m.visible = false));
            const whiteMat = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                shininess: 30,
            });
            whiteMat.dithering = true;
            const prevOverride = scene.overrideMaterial;
            
            scene.overrideMaterial = whiteMat;

            // Capture cube map - use world position and quaternion to handle flipped parents
            const worldPos = new THREE.Vector3();
            const worldQuat = new THREE.Quaternion();
            cone.getWorldPosition(worldPos);
            cone.getWorldQuaternion(worldQuat);
            
            cubeCamera.position.copy(worldPos);
            console.log(worldQuat)
            cubeCamera.quaternion.copy(worldQuat);
               // add a 90Â° clockwise offset about world-Y
               cubeCamera.quaternion.multiply(
                 new THREE.Quaternion().setFromAxisAngle(
                   new THREE.Vector3(0,1,0),
                   -Math.PI/2
                 )
               );
            
            cubeCamera.update(renderer, scene);

            // Restore material
            scene.overrideMaterial = prevOverride;
            
            markers.forEach((m) => (m.visible = true));

            // Equirectangular pass
            renderer.setPixelRatio(1);
            renderer.setSize(2048, 1024);
            renderer.setRenderTarget(null);
            renderer.autoClear = true;
            renderer.setClearColor(0x000000, 1);
            renderer.clear(true, true, true);
            renderer.render(eqScene, eqCam);

            // Source canvas
            const srcCanvas = renderer.domElement;

            // ZIP original
            console.log(`  Capturing original: ${instanceName}.jpg`);
            const origDataURL = srcCanvas.toDataURL("image/jpeg", 0.6); // Reduced quality for better performance
            zip.file(`${instanceName}.jpg`, origDataURL.split(",")[1], {
                base64: true,
            });

            // Prepare flipped name
            const flipParts = prefix.split("_");
            if (flipParts.length >= 3) flipParts[2] += "f";
            const flippedName =
                `${flipParts.join("_")}_${cone.name}`.toLowerCase();

            // ZIP flipped
            console.log(`  Capturing flipped: ${flippedName}.jpg`);
            const off = document.createElement("canvas");
            off.width = srcCanvas.width;
            off.height = srcCanvas.height;
            const ctx = off.getContext("2d");
            ctx.translate(off.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(srcCanvas, 0, 0);
            const flipDataURL = off.toDataURL("image/jpeg", 0.8);
            zip.file(`${flippedName}.jpg`, flipDataURL.split(",")[1], {
                base64: true,
            });

            // Yield periodically
            if (i % 5 === 4) await tick();
        }

        // Duplicate s1â†’s2
        Object.keys(zip.files).forEach((fn) => {
            if (/s1/i.test(fn)) {
                const newName = fn.replace(/s1/gi, "s2");
                console.log(`â†ª Duplicating ${fn} to ${newName}`);
                const data = zip.files[fn]._data;
                zip.file(newName, data, { base64: true });
            }
        });

        // Cleanup lights
        lights.forEach((l) => scene.remove(l));
        console.log(`Completed export for group ${prefix}`);

        // If root call, finalize and download ZIP
        if (isRootCall) {
            console.log("Generating ZIP...");
            const blob = await zip.generateAsync(
                { type: "blob", streamFiles: true },
                (meta) => {
                    console.log(`  ZIP progress: ${meta.percent.toFixed(1)}%`);
                },
            );
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `${base}-360s-batches.zip`;
            a.click();
            console.log("Download triggered");
        }

        // Restore renderer state
        renderer.setPixelRatio(origDPR);
        renderer.setSize(origSize.x, origSize.y);
        renderer.setClearColor(origClearColor, origClearAlpha);
        renderer.autoClear = origAutoClear;
        renderer.physicallyCorrectLights = origPhysLights;
        renderer.toneMapping = origToneMapping;
        renderer.toneMappingExposure = origToneExp;
        renderer.dither = origDither;

        // Re-enable wireframes
        scene.traverse((o) => {
            if (o.isMesh && o.material) {
                const mats = Array.isArray(o.material)
                    ? o.material
                    : [o.material];
                mats.forEach((m) => {
                    m.wireframe = true;
                    m.needsUpdate = true;
                });
            }
        });
        console.log("Renderer and wireframes restored.");
    }

    // Recursively toggle visibility in the Three.js scene
    function toggleVisibility(object, visible) {
        object.visible = visible;
        object.userData.isEnabled = visible;
        if (object.children) {
            object.children.forEach((child) =>
                toggleVisibility(child, visible),
            );
        }
    }
    
    // Function to select reversed faces for a single camera (currentSelectedCone)
    async function selectReversedFacesForCamera(cone) {
        if (!cone || !cone.cameraPos || !cone.parent || !cone.parent.visible) {
            console.log("No valid camera selected.");
            return;
        }
        
        // Clear previous highlights
        selectedReversedFaceIds.clear();
        updateSelectedReversedFacesHighlights();
        
        console.log(`Processing single camera (${cone.name}) for reversed faces...`);
        
        // Render face IDs
        const idRender = await renderFaceIdsAt8K(cone);
        await new Promise(resolve => requestAnimationFrame(resolve));
        
        // Render normals
        const normalRenderResult = await render360SnapshotForConeAt8K(cone, true);
        const normalImageData = normalRenderResult.imageData;
        await new Promise(resolve => requestAnimationFrame(resolve));
        
        // Cache mesh info
        const meshInfoByUuid = new Map();
        objects.forEach(obj => {
            obj.traverse((mesh) => {
                if (mesh.isMesh && mesh.geometry) {
                    const meshName = mesh.name || "unnamed";
                    const parentName = mesh.parent?.name || "unnamed parent";
                    const isSphere = meshName.toLowerCase().includes("sphere") || parentName.toLowerCase().includes("sphere") || obj.name?.toLowerCase().includes("sphere");
                    const faceCount = mesh.geometry.index ? mesh.geometry.index.count / 3 : (mesh.geometry.attributes.position?.count || 0) / 3;
                    meshInfoByUuid.set(mesh.uuid, { meshName, parentName, isSphere, faceCount });
                }
            });
        });
        
        // Compare renders
        const idData = idRender.imageData.data;
        const normalData = normalImageData.data;
        const width = idRender.width;
        const height = idRender.height;
        const sampleRate = 4;
        const redFaces = new Set();
        
        const widthS = Math.ceil(width / sampleRate);
        const heightS = Math.ceil(height / sampleRate);
        const redMask = new Uint8Array(widthS * heightS);
        const isRed = (rr, gg, bb) => rr > 200 && gg < 50 && bb < 50;
        
        // Build mask
        for (let yS = 0; yS < heightS; yS++) {
            const y = yS * sampleRate;
            if (y >= height) continue;
            for (let xS = 0; xS < widthS; xS++) {
                const x = xS * sampleRate;
                if (x >= width) continue;
                const idx = (y * width + x) * 4;
                const r = normalData[idx];
                const g = normalData[idx + 1];
                const b = normalData[idx + 2];
                if (!isRed(r, g, b)) continue;
                let redNeighbors = 0;
                if (x > 0) {
                    const nIdx = (y * width + (x - 1)) * 4;
                    if (isRed(normalData[nIdx], normalData[nIdx + 1], normalData[nIdx + 2])) redNeighbors++;
                }
                if (x + 1 < width) {
                    const nIdx = (y * width + (x + 1)) * 4;
                    if (isRed(normalData[nIdx], normalData[nIdx + 1], normalData[nIdx + 2])) redNeighbors++;
                }
                if (y > 0) {
                    const nIdx = ((y - 1) * width + x) * 4;
                    if (isRed(normalData[nIdx], normalData[nIdx + 1], normalData[nIdx + 2])) redNeighbors++;
                }
                if (y + 1 < height) {
                    const nIdx = ((y + 1) * width + x) * 4;
                    if (isRed(normalData[nIdx], normalData[nIdx + 1], normalData[nIdx + 2])) redNeighbors++;
                }
                if (redNeighbors < 3) continue;
                redMask[yS * widthS + xS] = 1;
            }
        }
        
        // Connected components with shape metrics
        const compIds = new Int32Array(widthS * heightS);
        compIds.fill(-1);
        const compMetrics = []; // {size, minX, maxX, minY, maxY, perimeter}
        let compCounter = 0;
        const stack = [];
        
        // Helper to check if pixel is on edge (has non-red neighbor)
        const isEdgePixel = (xS, yS) => {
            if (xS === 0 || xS === widthS - 1 || yS === 0 || yS === heightS - 1) return true;
            const neighbors = [
                (yS - 1) * widthS + xS, // up
                (yS + 1) * widthS + xS, // down
                yS * widthS + (xS - 1), // left
                yS * widthS + (xS + 1)  // right
            ];
            for (const n of neighbors) {
                if (!redMask[n]) return true;
            }
            return false;
        };
        
        for (let yS = 0; yS < heightS; yS++) {
            for (let xS = 0; xS < widthS; xS++) {
                const idxS = yS * widthS + xS;
                if (!redMask[idxS] || compIds[idxS] !== -1) continue;
                
                let size = 0;
                let minX = xS, maxX = xS, minY = yS, maxY = yS;
                let perimeter = 0;
                
                stack.length = 0;
                stack.push(idxS);
                compIds[idxS] = compCounter;
                
                while (stack.length) {
                    const cur = stack.pop();
                    size++;
                    const cx = cur % widthS;
                    const cy = (cur / widthS) | 0;
                    
                    // Update bounding box
                    if (cx < minX) minX = cx;
                    if (cx > maxX) maxX = cx;
                    if (cy < minY) minY = cy;
                    if (cy > maxY) maxY = cy;
                    
                    // Count perimeter
                    if (isEdgePixel(cx, cy)) perimeter++;
                    
                    const neighbors = [
                        cur - 1,
                        cur + 1,
                        cur - widthS,
                        cur + widthS
                    ];
                    if (cx === 0) neighbors[0] = -1;
                    if (cx === widthS - 1) neighbors[1] = -1;
                    if (cy === 0) neighbors[2] = -1;
                    if (cy === heightS - 1) neighbors[3] = -1;
                    for (const n of neighbors) {
                        if (n < 0) continue;
                        if (!redMask[n]) continue;
                        if (compIds[n] !== -1) continue;
                        compIds[n] = compCounter;
                        stack.push(n);
                    }
                }
                
                const width = maxX - minX + 1;
                const height = maxY - minY + 1;
                const bboxArea = width * height;
                const aspectRatio = Math.max(width / Math.max(height, 1), height / Math.max(width, 1));
                const compactness = size / Math.max(bboxArea, 1); // 1.0 = perfect rectangle, lower = sparse
                const perimeterToArea = perimeter / Math.max(size, 1);
                
                compMetrics[compCounter] = {
                    size,
                    minX, maxX, minY, maxY,
                    width, height,
                    perimeter,
                    aspectRatio,
                    compactness,
                    perimeterToArea
                };
                compCounter++;
            }
        }
        
        // Filter thresholds
        const minRedRegionSize = 20; // minimum pixel count
        const minWidth = 2; // minimum bounding box width (in sampled pixels)
        const minHeight = 2; // minimum bounding box height (in sampled pixels)
        const maxAspectRatio = 8; // filter very thin lines (width/height or height/width)
        const minCompactness = 0.3; // filter very sparse regions (low = thin/scattered)
        const maxPerimeterToArea = 1.5; // filter high edge-to-area ratio (specks/thin lines)
        
        const chunkSize = 100;
        let processedRows = 0;
        for (let yS = 0; yS < heightS; yS++) {
            const y = yS * sampleRate;
            if (y >= height) continue;
            for (let xS = 0; xS < widthS; xS++) {
                const idxS = yS * widthS + xS;
                if (!redMask[idxS]) continue;
                const compId = compIds[idxS];
                if (compId === -1) continue;
                
                const metrics = compMetrics[compId];
                // Apply all filters
                if (metrics.size < minRedRegionSize) continue;
                if (metrics.width < minWidth || metrics.height < minHeight) continue;
                if (metrics.aspectRatio > maxAspectRatio) continue;
                if (metrics.compactness < minCompactness) continue;
                if (metrics.perimeterToArea > maxPerimeterToArea) continue;
                
                const x = xS * sampleRate;
                if (x >= width) continue;
                const idx = (y * width + x) * 4;
                const idR = idData[idx];
                const idG = idData[idx + 1];
                const idB = idData[idx + 2];
                
                const idBrightness = (idR + idG + idB) / 3;
                if (idBrightness < 10) continue;
                
                const exactColorKey = `${Math.floor(idR)},${Math.floor(idG)},${Math.floor(idB)}`;
                let faceId = idRender.colorToFaceIdMap.get(exactColorKey);
                let matchType = 'exact';
                let matchDistance = 0;
                
                if (!faceId) {
                    const tolerance = 4;
                    let bestMatch = null;
                    let bestDistance = Infinity;
                    const bucketKeyBase = { r: idR >> 2, g: idG >> 2, b: idB >> 2 };
                    const bucketsToCheck = [];
                    for (let dr = -1; dr <= 1; dr++) {
                        for (let dg = -1; dg <= 1; dg++) {
                            for (let db = -1; db <= 1; db++) {
                                bucketsToCheck.push(`${bucketKeyBase.r + dr},${bucketKeyBase.g + dg},${bucketKeyBase.b + db}`);
                            }
                        }
                    }
                    const colorBuckets = idRender.colorBuckets;
                    for (const key of bucketsToCheck) {
                        const bucket = colorBuckets?.get(key);
                        if (!bucket) continue;
                        for (const entry of bucket) {
                            const distance = Math.abs(idR - entry.r) + Math.abs(idG - entry.g) + Math.abs(idB - entry.b);
                            if (distance < bestDistance &&
                                Math.abs(idR - entry.r) <= tolerance &&
                                Math.abs(idG - entry.g) <= tolerance &&
                                Math.abs(idB - entry.b) <= tolerance) {
                                bestDistance = distance;
                                bestMatch = entry.faceId;
                            }
                        }
                    }
                    
                    if (bestMatch) {
                        faceId = bestMatch;
                        matchType = 'tolerance';
                        matchDistance = bestDistance;
                    }
                }
                
                if (faceId) {
                    const expectedColor = idRender.faceIdToColorMap?.get(faceId);
                    if (expectedColor) {
                        const expectedR = Math.floor(expectedColor.r * 255);
                        const expectedG = Math.floor(expectedColor.g * 255);
                        const expectedB = Math.floor(expectedColor.b * 255);
                        const colorDiff = Math.abs(idR - expectedR) + Math.abs(idG - expectedG) + Math.abs(idB - expectedB);
                        if (matchType === 'tolerance' && colorDiff > 6) {
                            continue;
                        }
                    }
                    
                    redFaces.add(faceId);
                }
            }
            
            processedRows++;
            if (processedRows >= chunkSize) {
                processedRows = 0;
                await new Promise(resolve => requestAnimationFrame(resolve));
            }
        }
        
        // Build faceIdToMeshInfo
        const faceIdToMeshInfo = new Map();
        redFaces.forEach(faceId => {
            const meshUuid = idRender.faceIdToMeshMap?.get(faceId);
            if (!meshUuid) return;
            const meshInfo = meshInfoByUuid.get(meshUuid);
            if (!meshInfo) return;
            const faceIndex = parseInt(faceId.split('-').pop());
            faceIdToMeshInfo.set(faceId, {
                faceId,
                meshName: meshInfo.meshName,
                meshUuid,
                parentName: meshInfo.parentName,
                faceIndex,
                totalFaces: meshInfo.faceCount,
                isSphere: meshInfo.isSphere
            });
        });
        
        // Update global selections
        redFaces.forEach(faceId => {
            selectedReversedFaceIds.add(faceId);
        });
        updateSelectedReversedFacesHighlights();
        
        console.log(`Camera (${cone.name}): Found ${redFaces.size} reversed faces`);
        
        // Export if enabled and within first 3 cameras
        if (exportLogsEnabled) {
            const cameraIndex = Math.max(0, markers.findIndex(m => m === cone));
            if (cameraIndex > -1 && cameraIndex < 3) {
                await exportRenderZip(
                    cameraIndex + 1,
                    cone.name,
                    { imageData: idRender.imageData, width: idRender.width, height: idRender.height },
                    { imageData: normalImageData, width: normalRenderResult.width, height: normalRenderResult.height },
                    redFaces,
                    faceIdToMeshInfo
                );
            }
        }
    }

    // Apply or remove visual "disabled" style on a <li> subtree
    function styleSubtree(liElement, enabled) {
        const applyStyle = (el) => {
            el.style.opacity = enabled ? "1" : "0.5";
            el.style.textDecoration = enabled ? "" : "line-through";
        };
        applyStyle(liElement.querySelector("div"));
        // Also style all descendant <div> containers
        liElement
            .querySelectorAll("li > div")
            .forEach((div) => applyStyle(div));
    }

    function updateObjectColor(object, color) {
        // Update material color if this object is a Mesh.
        if (object.isMesh && object.material && object.material.color) {
            object.material.color.set(color);
            object.material.needsUpdate = true;
        }
        // If a color picker was stored on this object, update it.
        if (object.userData && object.userData.colorPicker) {
            object.userData.colorPicker.value = color;
        }
        // Recursively update all children.
        if (object.children && object.children.length > 0) {
            object.children.forEach((child) => updateObjectColor(child, color));
        }
    }

    // Utility to extract a grouping key from object names (segments 3â€“6)
    function getGroupId(name) {
        const segments = name.split("_");
        if (segments.length >= 6) {
            // take segments[2], [3], [4], [5]
            return segments.slice(2, 6).join("_");
        }
        return null;
    }

    const tooltip = document.getElementById('hover-tooltip');
    let  hoverTimerId  = null;
    let hoverObject  = null; 

    /**
     * Show tooltip next to the mouse.
     * @param {number}  x   screen-space X
     * @param {number}  y   screen-space Y
     * @param {string=} msg text to display (defaults to previous / "Double-click to refocus")
     */
    function showTooltip(x, y, msg) {
        if (msg !== undefined) tooltip.textContent = msg;
        tooltip.style.left  = (x + 14) + 'px';
        tooltip.style.top   = (y + 14) + 'px';
        tooltip.style.opacity = 1;
    }
    /** hide tooltip & cancel timer */
    function hideTooltip() {
        clearTimeout(hoverTimerId);
        hoverTimerId = null;
        tooltip.style.opacity = 0;
    }

    // Updated updateOutliner with grouping logic
    function updateOutliner() {
        const outliner = document.getElementById("outliner");
        if (!outliner) return;
        outliner.innerHTML = "";

        // 2) Outliner rows already have the object id stored:
        outliner.addEventListener("click", (e) => {
        const target = e.target as HTMLElement;
        const li = target.closest("li[data-object-id]") as HTMLElement;
        if (!li) return;
        const obj = scene.getObjectById(+li.dataset.objectId);
        if (obj)  fitCameraToObject(camera, orbitalControls, obj);
        });

        // -- build map of groups --
        const groupsMap = new Map();
        const standalone = [];
        scene.children.forEach((obj) => {
            const nm = obj.name || "";
            const lo = nm.toLowerCase();
            const key = getGroupId(nm);
            if ((lo.endsWith(".csv") || lo.endsWith(".glb")) && key) {
                if (!groupsMap.has(key)) groupsMap.set(key, []);
                groupsMap.get(key).push(obj);
            } else {
                standalone.push(obj);
            }
        });

        // -- status line --
        let statusEl = null;
        if (groupsMap.size > 1) {
            statusEl = document.createElement("div");
            statusEl.className = "mb-1 text-xs text-gray-700";
            statusEl.textContent = "Ready to export groupsâ€¦";
            outliner.appendChild(statusEl);
        }

        // -- "Export All" button --
        if (groupsMap.size > 1) {
            // Export All Groups button
            const btn = document.createElement("button");
            btn.textContent = "Export All Groups 360Â°";
            btn.className = "mb-2 p-1 bg-blue-500 text-white text-xs rounded";
            btn.addEventListener('click', async () => {
                btn.disabled = true;
                statusEl.textContent = 'Starting export of all groupsâ€¦';
                await new Promise(r=>setTimeout(r,0));

                // 1) Single master zip
                const rootZip = new JSZip();
                let idx = 1;
                const total = groupsMap.size;

                // 2) Loop over each group once
                for (const objs of groupsMap.values()) {
                    const csvObj = objs.find(o => o.name.toLowerCase().endsWith('.csv'));
                    if (!csvObj) continue;

                    const key = getGroupId(csvObj.name);
                    statusEl.textContent = `Processing group "${key}" (${idx}/${total})â€¦`;
                    console.log(`â†’ [${idx}/${total}] exporting group ${key}`);
                    await new Promise(r=>setTimeout(r,0));

                    // 3) Create a sub-folder in the master zip
                    const folder = rootZip.folder(key);
                    // This writes *only* this group's panoramas into that folder
                    await exportAll360ForGroup(csvObj, folder);

                    idx++;
                }

                // 4) Finalize and download
                statusEl.textContent = 'Finalizing ZIPâ€¦';
                console.log('All groups done, generating combined ZIP');
                const blob = await rootZip.generateAsync({
                    type: 'blob',
                    streamFiles: true,
                }, meta => console.log(`ZIP ${meta.percent.toFixed(1)}%`));

                const a = document.createElement('a');
                a.href     = URL.createObjectURL(blob);
                a.download = 'all-groups-360s.zip';
                a.click();
                console.log('Combined ZIP download triggered');

                statusEl.textContent = 'âœ… All groups exported!';
                btn.disabled = false;
            });

            outliner.appendChild(btn);
        }

        // -- now render the tree as before --
        const ul = document.createElement("ul");
        // Build grouped nodes
        groupsMap.forEach((objs, key) => {
            const parentLi = document.createElement("li");
            parentLi.className =
                "group-node my-[3px] text-2xs hover:bg-gray-300 cursor-pointer flex flex-col";

            // Container for name and events
            const container = document.createElement("div");
            container.className = "flex items-center gap-2";
            container.textContent = `Group: ${key}`;

            // Double-click toggles visibility
            container.addEventListener("dblclick", (e) => {
                e.stopPropagation();
                const newState = !objs[0].visible;
                objs.forEach((o) => (o.visible = newState));
                objs.forEach((o) => {
                    if (o.userData.csvObject) {
                        const csvObj = scene.getObjectByProperty(
                            "uuid",
                            o.userData.csvObject,
                        );
                        if (csvObj) csvObj.visible = newState;
                    }
                });
                createLabels();
                styleSubtree(parentLi, newState);
            });

            parentLi.appendChild(container);

            // Children
            const childUl = document.createElement("ul");
            childUl.className = "ml-4 list-disc";
            objs.forEach((childObj) => {
                childUl.appendChild(buildTree(childObj));
            });
            parentLi.appendChild(childUl);
            ul.appendChild(parentLi);
        });

        // Standalone
        standalone.forEach((obj) => {
            ul.appendChild(buildTree(obj));
        });

        outliner.appendChild(ul);
    }

    const refDropzone = document.getElementById("reference-dropzone");
    const alignDropzone = document.getElementById("align-dropzone");
    const alignButton = document.getElementById("align-button");
    const alignmentPopup = document.getElementById("alignment-popup");

    // Prevent default behavior for dragover events.
    [refDropzone, alignDropzone].forEach((zone) => {
        zone.addEventListener("dragover", (e) => {
            e.preventDefault();
            console.log(e);
        });
    });

    // Handle drop on Reference zone.
    refDropzone.addEventListener("drop", (e) => {
        e.preventDefault();
        console.log("Dropped");
        console.log(e);
        if (referenceSelection.length >= 2) return;
        const objId = parseInt(e.dataTransfer.getData("text/plain"));
        const obj = scene.getObjectById(objId);
        if (!obj) return;
        // Optionally, check that this object comes from a CSV-derived group (e.g. via a flag)
        referenceSelection.push(obj);
        console.log(referenceSelection);
        updateDropzoneUI(refDropzone, referenceSelection);
        checkAlignmentReady();
    });

    // Handle drop on Align zone.
    alignDropzone.addEventListener("drop", (e) => {
        e.preventDefault();
        console.log(e);
        if (alignSelection.length >= 2) return;
        const objId = parseInt(e.dataTransfer.getData("text/plain"));
        const obj = scene.getObjectById(objId);
        if (!obj) return;
        alignSelection.push(obj);
        console.log(alignSelection);
        updateDropzoneUI(alignDropzone, alignSelection);
        checkAlignmentReady();
    });

    // Helper to update the dropzone display.
    function updateDropzoneUI(zone, selectionArray) {
        zone.innerHTML = "";
        selectionArray.forEach((obj) => {
            const span = document.createElement("span");
            span.textContent = obj.name;
            span.className = "block text-center text-blue-700";
            zone.appendChild(span);
        });
        if (selectionArray.length === 0) {
            zone.textContent = "Drop 2 items here";
        }
    }

    // Check if both zones have 2 items and show the Align button.
    function checkAlignmentReady() {
        if (referenceSelection.length === 2 && alignSelection.length === 2) {
            alignButton.classList.remove("hidden");
        }
    }

    alignButton.addEventListener("click", () => {
        alignGroups(referenceSelection, alignSelection);
        // Clear selections and hide popup
        referenceSelection = [];
        alignSelection = [];
        refDropzone.innerHTML = "Drop 2 items here";
        alignDropzone.innerHTML = "Drop 2 items here";
        alignButton.classList.add("hidden");
        alignmentPopup.classList.add("hidden");
    });

    // Alignment function: splits the transformation between the two groups.
    function alignGroups(refMarkers, alignMarkers) {
        // Assume the CSV-derived group is the parent of a marker.
        const groupA = refMarkers[0].parent;
        const groupB = alignMarkers[0].parent;

        // Helper to get an object's world position.
        const getPosition = (obj) => {
            const pos = new THREE.Vector3();
            obj.getWorldPosition(pos);
            return pos;
        };

        // Get the world positions of the two markers for each group.
        const p1 = getPosition(refMarkers[0]);
        const p2 = getPosition(refMarkers[1]);
        const q1 = getPosition(alignMarkers[0]);
        const q2 = getPosition(alignMarkers[1]);

        // Compute each group's anchor (midpoint of its two markers).
        const midA = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
        const midB = new THREE.Vector3().addVectors(q1, q2).multiplyScalar(0.5);

        // Compute the global target anchor (average of the two midpoints).
        const midAvg = new THREE.Vector3()
            .addVectors(midA, midB)
            .multiplyScalar(0.5);

        // Compute rotation angles based on projection to the XZ plane.
        const getXZ = (vec) => new THREE.Vector2(vec.x, vec.z);
        const angleA = Math.atan2(
            getXZ(p2).y - getXZ(p1).y,
            getXZ(p2).x - getXZ(p1).x,
        );
        const angleB = Math.atan2(
            getXZ(q2).y - getXZ(q1).y,
            getXZ(q2).x - getXZ(q1).x,
        );
        const deltaAngle = angleB - angleA;

        // For each group, compute how much to translate so that its anchor becomes midAvg.
        const offsetA = new THREE.Vector3().subVectors(midAvg, midA);
        const offsetB = new THREE.Vector3().subVectors(midAvg, midB);

        // Apply the translation to each group.
        groupA.position.add(offsetA);
        groupB.position.add(offsetB);

        // Helper function to rotate a group about a given world point.
        function rotateGroupAboutPoint(group, point, angle) {
            group.position.sub(point);
            group.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
            group.position.add(point);
            group.rotation.y += angle;
        }

        // Rotate groupA about midAvg by half the deltaAngle.
        rotateGroupAboutPoint(groupA, midAvg, deltaAngle / 2);
        // Rotate groupB about midAvg by the negative half deltaAngle.
        rotateGroupAboutPoint(groupB, midAvg, -deltaAngle / 2);

        console.log(
            "Aligned groups using marker anchors:",
            groupA.name,
            groupB.name,
        );
    }

    document
        .getElementById("open-align-popup")
        ?.addEventListener("click", () => {
            alignmentPopup.classList.remove("hidden");
        });

    document.getElementById("scale-slider").addEventListener("input", (e) => {
        scaleGroupRelativeToCenter(m_Group, e.target.value);
    });

    document
        .getElementById("cone-size-slider")
        .addEventListener("input", (e) => {
            markers.forEach((i) => {
                console.log(e);
                i.scale.set(e.target.value, e.target.value, e.target.value);
                console.log(i.scale);
            });
        });

    window.addEventListener("export-csv", (e) => {
        createCSVFromSphereGroups([m_Group]);
    });

    window.addEventListener("object-switch", (e) => {
        csvGroups.forEach((e) => {
            e.visible = false;
        });
        fbxFiles.forEach((e) => {
            e.visible = false;
        });
        simplifiedNamesId.forEach((i) => {
            if (i.simplifiedName == e.detail) {
                // console.log(i.csvObject);
                scene.getObjectByProperty("uuid", i.uuid).visible = true;
                if (i.csvObject) {
                    const csvObj = scene.getObjectByProperty(
                        "uuid",
                        i.csvObject,
                    );
                    csvObj.visible = true;
                    csvObj.children.forEach((j) => {
                        j.visible = true;
                    });
                    m_Group = scene.getObjectByProperty("uuid", i.csvObject);
                }
            } else {
                scene.getObjectByProperty("uuid", i.uuid).visible = false;
                if (i.csvObject) {
                    const csvObj = scene.getObjectByProperty(
                        "uuid",
                        i.csvObject,
                    );
                    csvObj.visible = false;
                    csvObj.children.forEach((j) => {
                        j.visible = false;
                    });
                }
            }
        });
    });
    
    // Select Reversed Faces button with dropdown
    const selectReversedFacesBtn = document.getElementById("select-reversed-faces");
    const selectReversedFacesDropdown = document.getElementById("select-reversed-faces-dropdown");
    const selectReversedFacesSingleBtn = document.getElementById("select-reversed-faces-single");
    const selectReversedFacesBatchBtn = document.getElementById("select-reversed-faces-batch");
    const selectReversedFacesCurrentBtn = document.getElementById("select-reversed-faces-current");
    const flipSelectedNormalsBtn = document.getElementById("flip-selected-normals");
    
    // Dropdown toggle
    if (selectReversedFacesBtn && selectReversedFacesDropdown) {
        selectReversedFacesBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            selectReversedFacesDropdown.classList.toggle("hidden");
        });
        
        // Close dropdown when clicking outside
        document.addEventListener("click", (e) => {
            if (!selectReversedFacesBtn.contains(e.target as Node) && 
                !selectReversedFacesDropdown.contains(e.target as Node)) {
                selectReversedFacesDropdown.classList.add("hidden");
            }
        });
    }
    
    if (selectReversedFacesSingleBtn) {
        selectReversedFacesSingleBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            selectReversedFacesDropdown.classList.add("hidden");
            await selectAllReversedFaces();
        });
    }
    
    if (selectReversedFacesBatchBtn) {
        selectReversedFacesBatchBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            selectReversedFacesDropdown.classList.add("hidden");
            openBatchProcessModal();
        });
    }
    
    if (selectReversedFacesCurrentBtn) {
        selectReversedFacesCurrentBtn.style.display = currentSelectedCone ? "block" : "none";
        selectReversedFacesCurrentBtn.addEventListener("click", async () => {
            if (!currentSelectedCone) {
                console.warn("No camera selected.");
                return;
            }
            await selectReversedFacesForCamera(currentSelectedCone);
        });
    }
    if (flipSelectedNormalsBtn) {
        flipSelectedNormalsBtn.style.display = selectedReversedFaceIds.size > 0 ? "block" : "none";
        flipSelectedNormalsBtn.addEventListener("click", () => {
            flipSelectedNormals();
        });
    }
    
    const flattenCombineMeshesBtn = document.getElementById("flatten-combine-meshes");
    if (flattenCombineMeshesBtn) {
        flattenCombineMeshesBtn.addEventListener("click", () => {
            flattenAndCombineMeshes();
        });
    }

    // Toggle export logs & screengrabs
    const toggleExportLogs = document.getElementById("toggle-export-logs");
    if (toggleExportLogs) {
        exportLogsEnabled = !!(toggleExportLogs as HTMLInputElement).checked;
        toggleExportLogs.addEventListener("change", (e) => {
            const target = e.target as HTMLInputElement;
            exportLogsEnabled = !!target.checked;
            console.log(`Export logs & screengrabs: ${exportLogsEnabled ? "ON" : "OFF"}`);
        });
    }

    // Batch Processing Modal
    const batchProcessModal = document.getElementById("batch-process-modal");
    const batchFileDropZone = document.getElementById("batch-file-drop-zone");
    const batchFileInput = document.getElementById("batch-file-input") as HTMLInputElement;
    const batchFileList = document.getElementById("batch-file-list");
    const batchProcessCancel = document.getElementById("batch-process-cancel");
    const batchProcessStart = document.getElementById("batch-process-start");
    const batchProcessProgress = document.getElementById("batch-process-progress");
    const batchProcessProgressBar = document.getElementById("batch-process-progress-bar");
    const batchProcessStatus = document.getElementById("batch-process-status");
    const batchProcessCurrentFile = document.getElementById("batch-process-current-file");
    
    interface BatchFile {
        file: File;
        type: 'glb' | 'csv';
        paired?: boolean;
    }
    
    let batchFiles: BatchFile[] = [];
    
    function openBatchProcessModal() {
        if (batchProcessModal) {
            batchProcessModal.classList.remove("hidden");
            batchFiles = [];
            updateBatchFileList();
        }
    }
    
    function closeBatchProcessModal() {
        if (batchProcessModal) {
            batchProcessModal.classList.add("hidden");
            batchFiles = [];
            if (batchProcessProgress) batchProcessProgress.classList.add("hidden");
        }
    }
    
    // Close modal when clicking backdrop
    if (batchProcessModal) {
        batchProcessModal.addEventListener('click', (e) => {
            if (e.target === batchProcessModal) {
                closeBatchProcessModal();
            }
        });
    }
    
    function extractIdentifier(filename: string): string {
        // Remove extension
        const baseName = filename.replace(/\.(glb|csv)$/i, '').toLowerCase();
        
        // Remove common prefixes
        let identifier = baseName
            .replace(/^csv_camera_/i, '')
            .replace(/^model_360-collision_/i, '')
            .replace(/^model_/i, '')
            .replace(/-collision_/i, '_')
            .replace(/-collision$/i, '');
        
        // Look for camera/room identifier patterns like: a_s_1b_c1_s1 or a_s_1b_c1_0
        // Extract the core identifier (first 4 underscore-separated parts)
        const parts = identifier.split('_').filter(p => p.length > 0);
        
        // Try to find a pattern that looks like a camera identifier
        // Common pattern: letter_number_letter_number (e.g., "a_s_1b_c1")
        if (parts.length >= 4) {
            // Check if first 4 parts form a valid identifier pattern
            const coreParts = parts.slice(0, 4);
            // Verify it's not just numbers or single letters
            const hasValidPattern = coreParts.some(p => /^[a-z]\d+[a-z]?$|^\d+[a-z]$/i.test(p)) || 
                                   coreParts.every(p => /^[a-z0-9]+$/i.test(p));
            
            if (hasValidPattern) {
                identifier = coreParts.join('_');
            } else if (parts.length >= 3) {
                // Fallback to first 3 parts
                identifier = parts.slice(0, 3).join('_');
            }
        } else if (parts.length >= 3) {
            // Use first 3 parts if we have at least 3
            identifier = parts.slice(0, 3).join('_');
        }
        
        return identifier;
    }
    
    function updateBatchFileList() {
        if (!batchFileList) return;
        
        if (batchFiles.length === 0) {
            batchFileList.innerHTML = '<p class="text-sm text-gray-400 text-center">No files added yet</p>';
            if (batchProcessStart) (batchProcessStart as HTMLButtonElement).disabled = true;
            return;
        }
        
        // Group files by identifier (smart matching)
        const identifierGroups = new Map<string, { glbs: File[]; csvs: File[] }>();
        
        // Also track exact base name matches
        const exactGroups = new Map<string, { glb?: File; csv?: File }>();
        
        batchFiles.forEach(({ file, type }) => {
            const baseName = file.name.replace(/\.(glb|csv)$/i, '');
            const identifier = extractIdentifier(file.name);
            
            // Add to exact group
            if (!exactGroups.has(baseName)) {
                exactGroups.set(baseName, {});
            }
            const exactGroup = exactGroups.get(baseName)!;
            if (type === 'glb') {
                exactGroup.glb = file;
            } else {
                exactGroup.csv = file;
            }
            
            // Add to identifier group
            if (!identifierGroups.has(identifier)) {
                identifierGroups.set(identifier, { glbs: [], csvs: [] });
            }
            const idGroup = identifierGroups.get(identifier)!;
            if (type === 'glb') {
                idGroup.glbs.push(file);
            } else {
                idGroup.csvs.push(file);
            }
        });
        
        // Build final groups: prioritize exact matches, then identifier matches
        const finalGroups = new Map<string, { glb?: File; csv?: File; displayName: string }>();
        const usedFiles = new Set<File>();
        
        // First, add exact matches
        exactGroups.forEach((group, baseName) => {
            if (group.glb && group.csv) {
                usedFiles.add(group.glb);
                usedFiles.add(group.csv);
                finalGroups.set(baseName, {
                    glb: group.glb,
                    csv: group.csv,
                    displayName: baseName
                });
            }
        });
        
        // Then, add identifier-based matches for unpaired files
        identifierGroups.forEach((group, identifier) => {
            // Find unpaired GLB and CSV files
            const unpairedGlbs = group.glbs.filter(f => !usedFiles.has(f));
            const unpairedCsvs = group.csvs.filter(f => !usedFiles.has(f));
            
            // Pair them up
            const pairsToCreate = Math.min(unpairedGlbs.length, unpairedCsvs.length);
            for (let i = 0; i < pairsToCreate; i++) {
                const glb = unpairedGlbs[i];
                const csv = unpairedCsvs[i];
                const glbBase = glb.name.replace(/\.glb$/i, '');
                const csvBase = csv.name.replace(/\.csv$/i, '');
                const displayName = identifier; // Use identifier as display name
                
                usedFiles.add(glb);
                usedFiles.add(csv);
                
                // Use identifier as key, but check if we already have this identifier
                const key = `${identifier}_${i}`;
                finalGroups.set(key, {
                    glb,
                    csv,
                    displayName
                });
            }
            
            // Add remaining unpaired files
            for (let i = pairsToCreate; i < unpairedGlbs.length; i++) {
                const glb = unpairedGlbs[i];
                const baseName = glb.name.replace(/\.glb$/i, '');
                if (!finalGroups.has(baseName)) {
                    finalGroups.set(baseName, {
                        glb,
                        displayName: baseName
                    });
                }
            }
            
            for (let i = pairsToCreate; i < unpairedCsvs.length; i++) {
                const csv = unpairedCsvs[i];
                const baseName = csv.name.replace(/\.csv$/i, '');
                if (!finalGroups.has(baseName)) {
                    finalGroups.set(baseName, {
                        csv,
                        displayName: baseName
                    });
                }
            }
        });
        
        let html = '<div class="space-y-2">';
        finalGroups.forEach((group, key) => {
            const isPaired = !!(group.glb && group.csv);
            html += `
                <div class="flex items-center justify-between p-2 border rounded ${isPaired ? 'bg-green-50 border-green-300' : 'bg-yellow-50 border-yellow-300'}">
                    <div class="flex-1">
                        <p class="text-sm font-medium">${group.displayName}</p>
                        <div class="text-xs text-gray-500 mt-1">
                            ${group.glb ? `âœ“ GLB: ${group.glb.name}` : 'âœ— GLB'} | ${group.csv ? `âœ“ CSV: ${group.csv.name}` : 'âœ— CSV'}
                        </div>
                    </div>
                </div>
            `;
        });
        html += '</div>';
        
        batchFileList.innerHTML = html;
        
        // Enable batch process button if at least one pair is complete
        const hasCompletePairs = Array.from(finalGroups.values()).some(group => group.glb && group.csv);
        if (batchProcessStart) {
            (batchProcessStart as HTMLButtonElement).disabled = !hasCompletePairs;
        }
    }
    
    function addBatchFiles(files: FileList | File[]) {
        const fileArray = Array.from(files);
        fileArray.forEach(file => {
            const lower = file.name.toLowerCase();
            if (lower.endsWith('.glb')) {
                batchFiles.push({ file, type: 'glb' });
            } else if (lower.endsWith('.csv')) {
                batchFiles.push({ file, type: 'csv' });
            }
        });
        updateBatchFileList();
    }
    
    // Drag and drop handlers for batch modal (separate from main drop zone)
    if (batchFileDropZone) {
        batchFileDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            batchFileDropZone.classList.add('border-purple-500', 'bg-purple-50');
        });
        
        batchFileDropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            batchFileDropZone.classList.remove('border-purple-500', 'bg-purple-50');
        });
        
        batchFileDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            batchFileDropZone.classList.remove('border-purple-500', 'bg-purple-50');
            
            if (e.dataTransfer?.files) {
                addBatchFiles(e.dataTransfer.files);
            }
        });
    }
    
    if (batchFileInput) {
        batchFileInput.addEventListener('change', (e) => {
            const target = e.target as HTMLInputElement;
            if (target.files) {
                addBatchFiles(target.files);
            }
        });
    }
    
    if (batchProcessCancel) {
        batchProcessCancel.addEventListener('click', closeBatchProcessModal);
    }
    
    if (batchProcessStart) {
        batchProcessStart.addEventListener('click', async () => {
            await startBatchProcessing();
        });
    }
    
    async function startBatchProcessing() {
        if (batchFiles.length === 0) return;
        
        // Use the same pairing logic as updateBatchFileList
        const identifierGroups = new Map<string, { glbs: File[]; csvs: File[] }>();
        const exactGroups = new Map<string, { glb?: File; csv?: File }>();
        
        batchFiles.forEach(({ file, type }) => {
            const baseName = file.name.replace(/\.(glb|csv)$/i, '');
            const identifier = extractIdentifier(file.name);
            
            // Add to exact group
            if (!exactGroups.has(baseName)) {
                exactGroups.set(baseName, {});
            }
            const exactGroup = exactGroups.get(baseName)!;
            if (type === 'glb') {
                exactGroup.glb = file;
            } else {
                exactGroup.csv = file;
            }
            
            // Add to identifier group
            if (!identifierGroups.has(identifier)) {
                identifierGroups.set(identifier, { glbs: [], csvs: [] });
            }
            const idGroup = identifierGroups.get(identifier)!;
            if (type === 'glb') {
                idGroup.glbs.push(file);
            } else {
                idGroup.csvs.push(file);
            }
        });
        
        // Build pairs: prioritize exact matches, then identifier matches
        const pairs: Array<{ baseName: string; glb: File; csv: File }> = [];
        const usedFiles = new Set<File>();
        
        // First, add exact matches
        exactGroups.forEach((group, baseName) => {
            if (group.glb && group.csv) {
                usedFiles.add(group.glb);
                usedFiles.add(group.csv);
                pairs.push({
                    baseName,
                    glb: group.glb,
                    csv: group.csv
                });
            }
        });
        
        // Then, add identifier-based matches for unpaired files
        identifierGroups.forEach((group, identifier) => {
            const unpairedGlbs = group.glbs.filter(f => !usedFiles.has(f));
            const unpairedCsvs = group.csvs.filter(f => !usedFiles.has(f));
            
            const pairsToCreate = Math.min(unpairedGlbs.length, unpairedCsvs.length);
            for (let i = 0; i < pairsToCreate; i++) {
                const glb = unpairedGlbs[i];
                const csv = unpairedCsvs[i];
                usedFiles.add(glb);
                usedFiles.add(csv);
                pairs.push({
                    baseName: identifier,
                    glb,
                    csv
                });
            }
        });
        
        if (pairs.length === 0) {
            alert('No complete file pairs found. Each GLB file needs a matching CSV file.');
            return;
        }
        
        // Show progress
        if (batchProcessProgress) batchProcessProgress.classList.remove("hidden");
        if (batchProcessStart) (batchProcessStart as HTMLButtonElement).disabled = true;
        
        // Process each pair
        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i];
            
            if (batchProcessStatus) {
                batchProcessStatus.textContent = `${i + 1}/${pairs.length}`;
            }
            if (batchProcessProgressBar) {
                batchProcessProgressBar.style.width = `${((i + 1) / pairs.length) * 100}%`;
            }
            if (batchProcessCurrentFile) {
                batchProcessCurrentFile.textContent = `Processing: ${pair.baseName}`;
            }
            
            try {
                // Clear scene
                await clearScene();
                
                // Load model
                console.log(`Loading model: ${pair.glb.name}`);
                await loadModelFile(pair.glb);
                
                // Wait a bit for model to load
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Load CSV
                console.log(`Loading CSV: ${pair.csv.name}`);
                await loadCSVFile(pair.csv);
                
                // Wait a bit for CSV to process
                await new Promise(resolve => setTimeout(resolve, 500));
                
                // Run Select Reversed Faces
                console.log(`Processing reversed faces for: ${pair.baseName}`);
                await selectAllReversedFaces();
                
                // Wait for processing to complete
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                // Flip the selected reversed faces
                if (selectedReversedFaceIds.size > 0) {
                    console.log(`Flipping ${selectedReversedFaceIds.size} reversed faces for: ${pair.baseName}`);
                    flipSelectedNormals();
                    // Wait a bit for flip to complete
                    await new Promise(resolve => setTimeout(resolve, 500));
                } else {
                    console.log(`No reversed faces found for: ${pair.baseName}`);
                }
                
                // Export to GLB
                console.log(`Exporting GLB: ${pair.glb.name}`);
                await exportCurrentModelToGLB(pair.glb);
                
                console.log(`Completed: ${pair.baseName}`);
            } catch (error) {
                console.error(`Error processing ${pair.baseName}:`, error);
                alert(`Error processing ${pair.baseName}: ${error}`);
            }
        }
        
        // Hide progress and close modal
        if (batchProcessProgress) batchProcessProgress.classList.add("hidden");
        closeBatchProcessModal();
        alert(`Batch processing complete! Processed ${pairs.length} file pair(s).`);
    }
    
    async function clearScene() {
        // Remove all objects from scene
        while (objects.length > 0) {
            const obj = objects.pop();
            if (obj) {
                scene.remove(obj);
                obj.traverse((child) => {
                    if (child.isMesh) {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(mat => mat.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });
            }
        }
        
        // Clear CSV groups
        csvGroups.forEach(group => {
            scene.remove(group);
            group.traverse((child) => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => mat.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
            });
        });
        csvGroups.length = 0;
        
        // Clear markers
        markers.forEach(marker => scene.remove(marker));
        markers.length = 0;
        
        // Clear arrays
        simplifiedNamesId.length = 0;
        globalFloors = [];
        
        // Reset selected faces
        selectedReversedFaceIds.clear();
        
        // Force render
        renderer.render(scene, camera);
    }
    
    async function loadModelFile(file: File): Promise<void> {
        return new Promise((resolve, reject) => {
            if (file.name.toLowerCase().endsWith('.glb')) {
                file.arrayBuffer().then(arrayBuffer => {
                    GLTFloader.parse(
                        arrayBuffer,
                        "",
                        (gltf) => {
                            applyLitMaterialToGLTF(gltf.scene);
                            gltf.scene.name = file.name;
                            gltf.scene.scale.set(100, 100, 100);
                            objects.push(gltf.scene);
                            simplifiedNamesId.push({
                                uuid: gltf.scene.uuid,
                                simplifiedName: file.name.replace(/\D/g, ""),
                            });
                            scene.add(gltf.scene);
                            updateOutliner();
                            resolve();
                        },
                        (err) => {
                            console.error("GLB load error:", err);
                            reject(err);
                        }
                    );
                }).catch(reject);
            } else {
                reject(new Error("Unsupported file type"));
            }
        });
    }
    
    async function loadCSVFile(file: File): Promise<void> {
        return new Promise((resolve, reject) => {
            if (file.name.toLowerCase().endsWith('.csv')) {
                file.text().then(text => {
                    globalFloors = [];
                    processCSVData(text, file.name);
                    resolve();
                }).catch(reject);
            } else {
                reject(new Error("Unsupported file type"));
            }
        });
    }
    
    async function exportCurrentModelToGLB(glbFile: File): Promise<void> {
        return new Promise((resolve, reject) => {
            if (objects.length === 0) {
                reject(new Error("No model to export"));
                return;
            }
            
            // Export the first object (or combine all objects)
            const objectToExport = objects[0];
            // Use the original GLB filename
            const filename = glbFile.name.replace(/\.glb$/i, '') + '.glb';
            
            exportToGLB(objectToExport, filename);
            
            // Wait a bit for export to complete
            setTimeout(() => {
                resolve();
            }, 500);
        });
    }

    //Gizmo controls
    document.getElementById("camera-top").addEventListener("click", (e) => {
        camera.position.set(0, 400, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    });

    document.getElementById("camera-bottom").addEventListener("click", (e) => {
        camera.position.set(0, -400, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 180, 0));
    });

    document.getElementById("camera-left").addEventListener("click", (e) => {
        camera.position.set(-200, 0, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    });

    document.getElementById("camera-right").addEventListener("click", (e) => {
        camera.position.set(200, 0, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    });

    window.addEventListener("resize", onWindowResize, false);

    function onWindowResize() {
        // Update perspective camera
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        
        // Update orthographic camera
        orthoCamera.left = window.innerWidth / -0.1;
        orthoCamera.right = window.innerWidth / 0.1;
        orthoCamera.top = window.innerHeight / 0.1;
        orthoCamera.bottom = window.innerHeight / -0.1;
        orthoCamera.updateProjectionMatrix();
        
        updateLabelPositions(); // Fix label drift on window resize
    }
</script>

<style>
    html {
        min-height: 100vh;
        width: 100%;
        margin: 0%;
    }

    body {
        /* min-height: 100vh;
        width: 100%;
        margin: 0%; */
        max-width: 100vw;
        display: flex;
        flex-wrap: wrap;
        min-height: 90vh;
        margin: 0%;
    }

    .ui-area {
        position: fixed;
        height: min-content;
    }

    .notification-panel {
        position: fixed;
        display: flex;
        flex-direction: column;
        right: 0%;
        width: 250px;
        grid-column: auto;
        gap: 10px;
    }

    .notification {
        padding: 0.5em;
        background-color: azure;
    }

    #tag,
    #tag * {
        display: flex;
        position: fixed;
        background-color: #cccccccc;
        padding: 0em 0.5em;
        text-align: left;
        line-height: 0.5em;
        font-family: monospace;
        font-weight: 100;
        justify-content: center;
        min-width: max-content;
        pointer-events: none;
        /* transform: translate(-50%); */
        /* min-height: 50px; */
        height: fit-content;
        border-radius: 6px;
        /* font-family: sans-serif; */
    }
    #label {
        display: flex;
        text-align: center;
        justify-content: center;
        margin: 0%;
        height: 100%;
        font-family: sans-serif;
    }
</style>
