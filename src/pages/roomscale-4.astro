---
import ObjectList from "../components/object-list.tsx";
// import * as DECODER from "../scripts/decoder/draco_decoder.js";
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Three.js - Three Sides of a Cube</title>
    </head>
    <body id="drop-zone" class="overflow-hidden">
        <div
            class="ui-area transition-all bg-zinc-100 p-1 rounded-sm text-xs"
            id="ui-area"
        >
            <div class="flex">
                <a
                    href="/"
                    class="flex w-fit border-2 border-zinc-300 pl-2 pr-2 p-1 mb-3 transition-all duration-75 drop-shadow-sm text-center rounded-md content-center hover:bg-neutral-100 hover:drop-shadow-lg"
                >
                    <div class="align-center content-center">
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            fill="none"
                            viewBox="0 0 24 24"
                            stroke-width="1.5"
                            stroke="currentColor"
                            class="size-5"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                d="m2.25 12 8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25"
                            ></path>
                        </svg>
                    </div>
                    <p class="ml-2 text-center">Home</p>
                </a>
                <button
                    id="clear-all-data"
                    class="flex transition-all duration-75 drop-shadow-sm bg-red-600 text-white p-2 ml-2 mb-3 rounded-md hover:drop-shadow-xl hover:bg-red-500 hover:text-white"
                >
                    Clear All Data
                </button>
                <button
                    id="next-csv-point"
                    class="flex transition-all duration-75 drop-shadow-sm bg-blue-600 text-white p-2 ml-2 mb-3 rounded-md hover:drop-shadow-xl hover:bg-blue-500 hover:text-white"
                >
                    Next Point
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="16"
                        height="16"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        class="ml-2"
                    >
                        <path d="M9 18l6-6-6-6" stroke-width="2"></path>
                    </svg>
                </button>
            </div>

            <hr class="border-b border-zinc-200 mb-3" />
            <button
                class="bg-zinc-300 text-lime-600 font-mono p-0.5 rounded-md w-full drop-shadow-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                id="log-scene">... Log Scene ...</button
            >

            <div class="flex space-x-1 mt-3">
                <p class="font-medium">Flip:</p>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="x-flip"
                >
                    X-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="y-flip"
                >
                    Y-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="z-flip"
                >
                    Z-Axis
                </button>
                <button
                    class="bg-zinc-300 p-1 pt-0 pb-0 rounded-sm transition-all duration-75 drop-shadow-sm hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                    id="y-up"
                >
                    -Y Coords
                </button>
            </div>

            <div class="rounded-md bg-white max-w-60 p-3 mt-3 space-y-2">
                <div>
                    <label for="center-csv">Center</label>
                    <input type="checkbox" id="center-csv" name="center-csv" />
                </div>
                <div>
                    <label for="show-labels">Show Labels</label>
                    <input
                        type="checkbox"
                        id="show-labels"
                        name="show-labels"
                        checked
                    />
                </div>
                <div>
                    <label for="show-face-orientation"
                        >Show Face Orientation</label
                    >
                    <input
                        type="checkbox"
                        id="show-face-orientation"
                        name="show-face-orientation"
                        checked
                    />
                </div>
                <div>
                    <label for="scale-slider">Cone Size</label>
                    <input
                        type="range"
                        class="accent-gray-400 hover:accent-lime-600 active:accent-lime-800 transition-all duration-75"
                        id="cone-size-slider"
                        name="cone-size-slider"
                        min='0"'
                        max="50"
                        step="1"
                        value="1"
                    />
                </div>
                <div>
                    <label for="scale-slider">Scale</label>
                    <input
                        type="range"
                        class="accent-gray-400 hover:accent-lime-600 active:accent-lime-800 transition-all duration-75"
                        id="scale-slider"
                        name="scale-slider"
                        min="-5"
                        max="5"
                        step="0.1"
                        value="1"
                    />
                </div>
            </div>

            <!-- <ObjectList client:load /> -->

            <button
                id="export-all-fbx"
                class="flex transition-all duration-75 drop-shadow-sm bg-zinc-600 text-lime-100 p-2 mt-3 rounded-md hover:drop-shadow-xl hover:bg-zinc-500 hover:text-lime-400"
                style="margin-bottom: 10px"
            >
                Export All To GLB
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    class="ml-2 rotate-180"
                >
                    <path
                        d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
                        stroke-width="2"></path>
                    <polyline points="7 10 12 15 17 10" stroke-width="2"
                    ></polyline>
                    <line x1="12" x2="12" y1="15" y2="3" stroke-width="2"
                    ></line>
                </svg></button
            >

            <label style="margin-left: 10px; font-family: monospace;">
                <input type="checkbox" id="export-all-scene-checkbox" />
                Export Entire Scene
            </label>

            <button
                id="export-csv-rotations"
                class="flex transition-all duration-75 drop-shadow-sm bg-green-600 text-white p-2 mt-3 rounded-md hover:drop-shadow-xl hover:bg-green-500 hover:text-white"
                style="margin-bottom: 10px"
            >
                Export CSV with Rotations
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-linecap="round"
                    stroke-linejoin="round"
                    class="ml-2"
                >
                    <path
                        d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
                        stroke-width="2"></path>
                    <polyline points="7 10 12 15 17 10" stroke-width="2"
                    ></polyline>
                    <line x1="12" x2="12" y1="15" y2="3" stroke-width="2"
                    ></line>
                </svg></button
            >

            <div class="rounded-md bg-zinc-300 max-w-52 p-5 pl-2 pr-2 mt-3">
                <h2 class="font-bold">Floors:</h2>
                <div class="flex flex-col" id="show-floors">
                    <p>Import a Camera CSV to start</p>
                </div>
            </div>

            <div class="rounded-md bg-green-100 max-w-52 p-3 mt-3">
                <h2 class="font-bold text-xs">Image Storage:</h2>
                <div class="text-xs" id="image-cache-stats">
                    <p>Total: 0 images</p>
                    <p>Cached: 0/20</p>
                    <p>Hit Rate: <span style="color: green">100%</span></p>
                    <p>Avg Load: 0ms</p>
                </div>
                
                <div id="loading-progress" class="mt-2 hidden">
                    <div class="bg-gray-200 rounded-full h-2">
                        <div id="progress-bar" class="bg-green-500 h-2 rounded-full" style="width: 0%"></div>
                    </div>
                    <p class="text-xs mt-1" id="progress-text">Indexing images...</p>
                </div>
            </div>
        </div>

        <main class="fixed flex right-0 pointer-events-none">
            <div
                id="vr-image-panel"
                class="relative right-0 w-[400px] h-[200px] resize overflow-auto border border-gray-400 min-w-[150px] min-h-[150px] pointer-events-auto"
                style="resize: both;"
            >
                <img
                    id="vr-img"
                    src=""
                    style="width:100%; height:100%; object-fit: contain;"
                    alt="VR view"
                />

                <!-- Overlay canvas for rendered view -->
                <canvas
                    id="vr-overlay-canvas"
                    class="absolute top-0 left-0 w-full h-full pointer-events-none"
                    style="opacity: 0.3; object-fit: contain; display: none;"
                ></canvas>

                <!-- Draggable overlay for rotation interaction -->
                <div
                    id="vr-drag-overlay"
                    class="absolute top-0 left-0 w-full h-full cursor-grab hidden"
                    style="z-index: 8;"
                ></div>

                <!-- Flipped tag indicator -->
                <div
                    id="vr-flipped-tag"
                    class="absolute top-2 left-2 bg-red-600 text-white px-2 py-1 text-xs font-bold rounded hidden"
                >
                    FLIPPED
                </div>

                <!-- Rotation display -->
                <div
                    id="vr-rotation-display"
                    class="absolute bottom-2 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-70 text-white px-2 py-1 text-xs rounded hidden"
                >
                    Rotation: 0.0°
                </div>

                <!-- bottom-left resize handle -->
                <div
                    id="vr-resize-handle"
                    class="absolute bottom-0 left-0 w-4 h-4 bg-white bg-opacity-50 rounded-tr-md"
                    style="cursor: sw-resize;"
                >
                </div>
            </div>

            <div class="flex flex-col pointer-events-auto">
                <div
                    class="right-0 max-w-2xl h-50 bg-neutral-100 text-xs"
                    id="gizmo"
                >
                    <button
                        id="camera-top"
                        class="bg-zinc-300 w-full p-5 pt-0 pb-0 rounded-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                        id="x-flip"
                    >
                        Top
                    </button>
                    <div class="flex">
                        <button
                            id="camera-left"
                            class="bg-zinc-300 p-5 pr-1 pl-1 rounded-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                            id="x-flip"
                        >
                            L
                        </button>
                        <div class="h-36 w-44" id="orthoView"></div>
                        <button
                            id="camera-right"
                            class="bg-zinc-300 p-5 pl-1 pr-1 rounded-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                            id="x-flip"
                        >
                            R
                        </button>
                    </div>

                    <button
                        id="camera-bottom"
                        class="bg-zinc-300 w-full p-5 pt-0 pb-0 rounded-sm transition-all duration-75 hover:text-lime-700 hover:bg-zinc-200 hover:drop-shadow-lg active:bg-zinc-300"
                        id="x-flip"
                    >
                        Bottom
                    </button>
                    <button id="open-align-popup"> Align Points </button>
                </div>

                <div
                    id="outliner"
                    class="pointer-events-auto mt-2 max-h-5xl overflow-y-auto bg-gray-200 pl-2 text-[10px]"
                >
                </div>
                <!-- Alignment Popup: hidden by default -->
                <div
                    id="alignment-popup"
                    class="fixed left-4 top-1/2 transform -translate-y-1/2 bg-white border border-gray-300 rounded-md shadow-lg p-4 hidden z-50"
                >
                    <div class="mb-2">
                        <h3 class="font-bold text-sm mb-1">Reference Points</h3>
                        <div
                            id="reference-dropzone"
                            class="w-40 h-20 border-2 border-dashed border-gray-400 flex flex-col items-center justify-center text-xs"
                        >
                            Drop 2 items here
                        </div>
                    </div>
                    <div class="mb-2">
                        <h3 class="font-bold text-sm mb-1">Align Points</h3>
                        <div
                            id="align-dropzone"
                            class="w-40 h-20 border-2 border-dashed border-gray-400 flex flex-col items-center justify-center text-xs"
                        >
                            Drop 2 items here
                        </div>
                    </div>
                    <button
                        id="align-button"
                        class="w-full bg-blue-500 text-white py-1 rounded-md text-xs hidden"
                    >
                        Align
                    </button>
                </div>
            </div>
        </main>

        <div class="notification-panel" id="notification-panel"></div>

        <div id="tag" class="z-[101]">
            <h3 id="label">-</h3>
        </div>
    </body>
    <div
        id="marker-label-container"
        class="overflow-hidden pointer-events-none z-[100]"
    >
    </div>
    <div id="hover-tooltip"
     style="position:fixed; padding:4px 8px; font:11px/1 monospace;
            color:#fff; background:#000d; border-radius:4px;
            pointer-events:none; opacity:0; transition:opacity .15s">
    Click to focus
    </div>
</html>

<script>
    import * as THREE from "../scripts/three";
    import { OrbitControls } from "../scripts/three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "../scripts/three/examples/jsm/loaders/GLTFLoader.js";
    import { FBXLoader } from "../scripts/three/examples/jsm/loaders/FBXLoader";
    import { GLTFExporter } from "../scripts/three/examples/jsm/exporters/GLTFExporter.js";
    import { DRACOLoader } from "../scripts/three/examples/jsm/loaders/DRACOLoader.js";
    import JSZip from "jszip";
    import gsap from "gsap";

    //Resizing image previewer
    const panel = document.getElementById("vr-image-panel");
    const handle = document.getElementById("vr-resize-handle");

    let isResizing = false;
    let startX, startY, startWidth, startHeight;

    handle.addEventListener("mousedown", function (e) {
        e.preventDefault();
        isResizing = true;

        // record starting mouse coords and panel size
        startX = e.clientX;
        startY = e.clientY;
        const rect = panel.getBoundingClientRect();
        startWidth = rect.width;
        startHeight = rect.height;

        window.addEventListener("mousemove", resizePanel);
        window.addEventListener("mouseup", stopResize);
    });

    // // 1) Spawn the worker (once, at module load)
    // const compressor = new Worker("compressor.worker.js");

    // // Map to hold pending promises
    // const pending = new Map();

    // // 2) Handle responses from Worker
    // compressor.onmessage = (e) => {
    //     const { id, buffer } = e.data;
    //     const { resolve } = pending.get(id);
    //     pending.delete(id);
    //     resolve(buffer); // hand back the raw JPEG bytes
    // };

    // // 3) Helper to offload JPEG encode
    // function encodeJPEGOffthread(canvas, quality = 0.8) {
    //     return new Promise(async (resolve, reject) => {
    //         try {
    //             // Create a small unique ID for this request
    //             const id = crypto.randomUUID();
    //             // Snapshot to an ImageBitmap (transferable)
    //             const bitmap = await createImageBitmap(canvas);
    //             // Store promise callbacks
    //             pending.set(id, { resolve, reject });
    //             // Post to worker
    //             compressor.postMessage({ id, imageBitmap: bitmap, quality }, [
    //                 bitmap,
    //             ]);
    //         } catch (err) {
    //             reject(err);
    //         }
    //     });
    // }

    function clearAllData() {
        // 1) Remove all dynamic scene children except axes & lights
        scene.children.slice().forEach((child) => {
            const t = child.type;
            const n = child.name;
            if (
                t !== "AxesHelper" &&
                t !== "AmbientLight" &&
                t !== "DirectionalLight" &&
                n !== "X-Axis" &&
                n !== "Y-Axis" &&
                n !== "Z-Axis"
            ) {
                scene.remove(child);
            }
        });

        // 2) Reset your tracking arrays and clear image storage
        objects.length = 0;
        markers.length = 0;
        VRSpheres.length = 0;
        imageArray.length = 0;
        imageManager.clear(); // Clear persistent image storage
        VRRef.length = 0;
        simplifiedNamesId.length = 0;
        csvGroups.length = 0;
        fbxFiles.length = 0;
        glbFiles.length = 0;
        globalFloors.length = 0;

        // 3) Clear HTML overlays and canvas pool
        document.getElementById("marker-label-container").innerHTML = "";
        document.getElementById("outliner").innerHTML = "";
        document.getElementById("alignment-popup").classList.add("hidden");
        canvasPool.cleanup(); // Clean up canvas pool

        console.log("Scene and data cleared.");
    }

    // Re-wire your button
    document
        .getElementById("clear-all-data")
        .addEventListener("click", clearAllData);

    // Wire up the button
    document
        .getElementById("clear-all-data")
        .addEventListener("click", clearAllData);

    // Wire up the navigation button
    document
        .getElementById("next-csv-point")
        .addEventListener("click", () => navigateToNextCsvPoint().catch(console.error));

    function resizePanel(e) {
        if (!isResizing) return;

        // horizontal drag (to the left) increases width
        const deltaX = startX - e.clientX;
        let newWidth = startWidth + deltaX;
        const minW = 150;
        if (newWidth < minW) newWidth = minW;

        // enforce 2:1 ratio → height = width / 2
        let newHeight = newWidth / 2;
        const minH = minW / 2;
        if (newHeight < minH) {
            newHeight = minH;
            newWidth = newHeight * 2;
        }

        panel.style.width = `${newWidth}px`;
        panel.style.height = `${newHeight}px`;
    }

    function stopResize() {
        if (!isResizing) return;
        isResizing = false;
        window.removeEventListener("mousemove", resizePanel);
        window.removeEventListener("mouseup", stopResize);
    }

    // Initialize the GLTFLoader
    const GLTFloader = new GLTFLoader();
    const FBXloader = new FBXLoader();
    const dracoLoader = new DRACOLoader();
    // Set the path to the Draco decoder
    // dracoLoader.setDecoderConfig({ type: 'js' });
    dracoLoader.setDecoderPath("/draco/decoder/");
    dracoLoader.preload();
    GLTFloader.setDRACOLoader(dracoLoader);

    var arrowAsset;
    GLTFloader.load("/Arrow.glb", (e) => {
        // Preload Arrow asset
        console.log("Arrow asset loaded");
        arrowAsset = e;
    });

    const scene = new THREE.Scene();
    
    // Persistent image storage system for random access
    class ImageManager {
        imageIndex: Map<string, any>;
        compressionCache: Map<string, any>;
        maxImageSize: number;
        maxCacheSize: number;
        compressionQueue: Set<string>;
        stats: {
            totalImages: number;
            cacheHits: number;
            cacheMisses: number;
            compressionTime: number;
        };

        constructor(maxImageSize = 1024) {
            this.imageIndex = new Map(); // Lightweight index of all images
            this.compressionCache = new Map(); // Recently compressed images
            this.maxImageSize = maxImageSize;
            this.maxCacheSize = 20; // Only cache 20 compressed images
            this.compressionQueue = new Set(); // Track what's being compressed
            this.stats = {
                totalImages: 0,
                cacheHits: 0,
                cacheMisses: 0,
                compressionTime: 0
            };
        }

        async compressImage(originalData, filename, targetSize = 'medium', quality = 0.7) {
            const startTime = performance.now();
            
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Define size targets for different quality levels
                    const sizeTargets = {
                        thumbnail: 256,   // For previews/lists
                        medium: 1024,     // For normal viewing
                        large: 2048       // For detailed viewing
                    };
                    
                    const maxSize = sizeTargets[targetSize] || this.maxImageSize;
                    
                    // Calculate new dimensions while maintaining aspect ratio
                    let { width, height } = img;
                    if (width > maxSize || height > maxSize) {
                        const ratio = Math.min(maxSize / width, maxSize / height);
                        width = Math.round(width * ratio);
                        height = Math.round(height * ratio);
                    }
                    
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);
                    
                    // Convert to JPEG for smaller file size
                    const compressedData = canvas.toDataURL('image/jpeg', quality);
                    
                    const endTime = performance.now();
                    this.stats.compressionTime += (endTime - startTime);
                    
                    resolve({
                        name: filename,
                        image: compressedData,
                        originalSize: { width: img.width, height: img.height },
                        compressedSize: { width, height },
                        quality: targetSize,
                        compressionTime: endTime - startTime
                    });
                };
                img.src = originalData;
            });
        }

        async addImage(filename, originalImageData) {
            const key = filename.toLowerCase();
            
            // Store in lightweight index (no compression yet)
            this.imageIndex.set(key, {
                name: filename,
                originalData: originalImageData,
                addedAt: Date.now(),
                accessed: 0
            });
            
            this.stats.totalImages++;
            if (this.stats.totalImages % 50 === 0 || this.stats.totalImages <= 10) {
                console.log(`📁 Image indexed: ${filename} (Total: ${this.stats.totalImages})`);
            }
            this.updateStatsDisplay();
            
            // Return a lazy-loading wrapper
            return {
                name: filename,
                image: null, // Will be loaded on demand
                isLazy: true,
                originalData: originalImageData
            };
        }

        async getImageOnDemand(filename, quality = 'medium') {
            const key = filename.toLowerCase();
            const cacheKey = `${key}_${quality}`;
            
            // Check if compressed version is already cached
            if (this.compressionCache.has(cacheKey)) {
                this.stats.cacheHits++;
                const cached = this.compressionCache.get(cacheKey);
                // Move to end (simple LRU for compressed cache only)
                this.compressionCache.delete(cacheKey);
                this.compressionCache.set(cacheKey, cached);
                this.updateStatsDisplay();
                return cached;
            }
            
            // Get original from index
            const indexed = this.imageIndex.get(key);
            if (!indexed) {
                return null;
            }
            
            // Check if already being compressed
            if (this.compressionQueue.has(cacheKey)) {
                // Wait for existing compression to complete
                while (this.compressionQueue.has(cacheKey)) {
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                return this.compressionCache.get(cacheKey) || null;
            }
            
            // Start compression
            this.compressionQueue.add(cacheKey);
            this.stats.cacheMisses++;
            
            try {
                const compressed = await this.compressImage(indexed.originalData, filename, quality);
                
                // Manage cache size (simple FIFO for compressed images)
                if (this.compressionCache.size >= this.maxCacheSize) {
                    const firstKey = this.compressionCache.keys().next().value;
                    this.compressionCache.delete(firstKey);
                }
                
                this.compressionCache.set(cacheKey, compressed);
                indexed.accessed++;
                
                this.compressionQueue.delete(cacheKey);
                this.updateStatsDisplay();
                return compressed;
                
            } catch (error) {
                this.compressionQueue.delete(cacheKey);
                console.error(`Failed to compress ${filename}:`, error);
                return null;
            }
        }

        async findImageByName(targetName, quality = 'medium') {
            const lowerTarget = targetName.toLowerCase();
            
            // Search through index (not cache)
            for (const [key, indexed] of this.imageIndex) {
                if (key.includes(lowerTarget) || lowerTarget.includes(key.replace(/\.[^/.]+$/, ""))) {
                    return await this.getImageOnDemand(indexed.name, quality);
                }
            }
            return null;
        }

        // Legacy method for compatibility
        getImage(filename) {
            // For immediate access, return cached version or null
            const key = filename.toLowerCase();
            const cacheKey = `${key}_medium`;
            return this.compressionCache.get(cacheKey) || null;
        }

        cleanupCompressedCache() {
            // Simple cleanup - remove oldest compressed images if cache is full
            if (this.compressionCache.size >= this.maxCacheSize) {
                const toRemove = Math.floor(this.maxCacheSize * 0.3);
                let removed = 0;
                
                for (const [key] of this.compressionCache) {
                    if (removed >= toRemove) break;
                    this.compressionCache.delete(key);
                    removed++;
                }
                
                console.log(`Compressed cache cleanup: Removed ${removed} cached images`);
            }
            this.updateStatsDisplay();
        }

        clear() {
            this.imageIndex.clear();
            this.compressionCache.clear();
            this.compressionQueue.clear();
            this.stats = {
                totalImages: 0,
                cacheHits: 0,
                cacheMisses: 0,
                compressionTime: 0
            };
            this.updateStatsDisplay();
        }

        // Fast indexing for large image sets (no compression during load)
        async indexBatch(imageDataArray, batchSize = 50) {
            const totalImages = imageDataArray.length;
            let processed = 0;
            
            // Show progress bar for large batches
            const showProgress = totalImages > 20;
            if (showProgress) {
                document.getElementById('loading-progress').classList.remove('hidden');
            }
            
            console.log(`Indexing ${totalImages} images in batches of ${batchSize} (no compression)`);
            
            for (let i = 0; i < imageDataArray.length; i += batchSize) {
                const batch = imageDataArray.slice(i, i + batchSize);
                
                // Index batch synchronously (very fast)
                batch.forEach(imageData => {
                    try {
                        const indexed = this.addImage(imageData.name, imageData.data);
                        imageArray.push(indexed);
                    } catch (error) {
                        console.error(`Failed to index image ${imageData.name}:`, error);
                    }
                });
                
                processed += batch.length;
                
                // Update progress
                if (showProgress) {
                    const progress = Math.round((processed / totalImages) * 100);
                    document.getElementById('progress-bar').style.width = `${progress}%`;
                    document.getElementById('progress-text').textContent = 
                        `Indexing images... ${processed}/${totalImages} (${progress}%)`;
                }
                
                // Very small delay to allow UI updates
                if (i + batchSize < imageDataArray.length) {
                    await new Promise(resolve => setTimeout(resolve, 5));
                }
            }
            
            // Hide progress bar
            if (showProgress) {
                setTimeout(() => {
                    document.getElementById('loading-progress').classList.add('hidden');
                }, 500);
            }
            
            console.log(`✅ Completed indexing ${processed} images instantly! Images will compress on-demand.`);
            return processed;
        }

                 getStats() {
            const totalAccesses = this.stats.cacheHits + this.stats.cacheMisses;
            const hitRate = totalAccesses > 0 ? Math.round((this.stats.cacheHits / totalAccesses) * 100) : 100;
            const avgCompressionTime = this.stats.cacheMisses > 0 ? 
                Math.round(this.stats.compressionTime / this.stats.cacheMisses) : 0;
            
            return {
                totalImages: this.stats.totalImages,
                cachedImages: this.compressionCache.size,
                maxCacheSize: this.maxCacheSize,
                hitRate: hitRate,
                totalAccesses: totalAccesses,
                avgCompressionTime: avgCompressionTime,
                memoryUsage: `${Math.round((this.compressionCache.size / this.maxCacheSize) * 100)}%`
            };
        }

        updateStatsDisplay() {
            const stats = this.getStats();
            const statsElement = document.getElementById('image-cache-stats');
            if (statsElement) {
                const hitRateColor = stats.hitRate > 80 ? 'green' : stats.hitRate > 50 ? 'orange' : 'red';
                
                statsElement.innerHTML = `
                    <p>Total: ${stats.totalImages} images</p>
                    <p>Cached: ${stats.cachedImages}/${stats.maxCacheSize}</p>
                    <p>Hit Rate: <span style="color: ${hitRateColor}">${stats.hitRate}%</span></p>
                    <p>Avg Load: ${stats.avgCompressionTime}ms</p>
                `;
            }
        }
    }

    // Initialize persistent image manager
    console.log(`Initializing persistent image storage system for random access`);
    const imageManager = new ImageManager(1024); // Only need max image size
    var imageArray = []; // Keep for backward compatibility
    var VRRef = [];
    var VRSpheres = [];
    var objects = [];
    var markers = [];
    let labelContainer;
    let referenceSelection = [];
    let alignSelection = [];

    const renderer = new THREE.WebGLRenderer({ 
        antialias: false, 
        alpha: true,
        powerPreference: "high-performance"
    });
    renderer.autoClear = false;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = false; // Disable shadows for better performance
    document.body.appendChild(renderer.domElement);

    const orthoRenderer = new THREE.WebGLRenderer({
        antialias: false,
        alpha: true,
        powerPreference: "high-performance"
    });
    orthoRenderer.autoClear = false;
    orthoRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit pixel ratio
    orthoRenderer.shadowMap.enabled = false; // Disable shadows for better performance
    const orthoView = document.getElementById("orthoView");
    orthoRenderer.setSize(orthoView.clientWidth, orthoView.clientHeight);
    document.getElementById("orthoView").appendChild(orthoRenderer.domElement);

    //Manipulatable Group
    var m_Group;

    //Infinite Axis Lines
    function createInfiniteAxisLines() {
        const axisLength = 100000; // Large enough to appear infinite
        
        // X-axis (Red)
        const xGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(-axisLength, 0, 0),
            new THREE.Vector3(axisLength, 0, 0)
        ]);
        const xMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        const xLine = new THREE.Line(xGeometry, xMaterial);
        xLine.name = "X-Axis";
        scene.add(xLine);
        
        // Y-axis (Green)
        const yGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -axisLength, 0),
            new THREE.Vector3(0, axisLength, 0)
        ]);
        const yMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        const yLine = new THREE.Line(yGeometry, yMaterial);
        yLine.name = "Y-Axis";
        scene.add(yLine);
        
        // Z-axis (Blue)
        const zGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, -axisLength),
            new THREE.Vector3(0, 0, axisLength)
        ]);
        const zMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
        const zLine = new THREE.Line(zGeometry, zMaterial);
        zLine.name = "Z-Axis";
        scene.add(zLine);
    }
    
    createInfiniteAxisLines();

    //Lights
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    scene.add(directionalLight);

    const light = new THREE.AmbientLight(0x404040);
    scene.add(light);

    //Camera
    const camera = new THREE.PerspectiveCamera(
        110,
        window.innerWidth / window.innerHeight,
        0.1,
        800000,
    );
    camera.position.x = -210.41;
    camera.position.y = 1.31;
    camera.position.z = 0;

    const orthoCamera = new THREE.OrthographicCamera(
        orthoView.clientWidth / -2,
        orthoView.clientWidth / 2,
        orthoView.clientHeight / 2,
        orthoView.clientHeight / -2,
        0.1,
        80000,
    );
    orthoCamera.position.x = -210.41;
    orthoCamera.position.y = 1.31;
    orthoCamera.position.z = 0;
    //Mouse Raycaster Perspective
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();
    //Mouse Raycaster Orthographic
    const orthoRaycaster = new THREE.Raycaster();
    const orthoPointer = new THREE.Vector2();

    function onPointerMove(event) {
       /* If the pointer is over the outliner (or a child of it),
          don't run the viewport-hover logic – let the outliner's
          own mouseenter/leave handlers manage the tooltip. */
       if (event.target.closest('#outliner')) {
           return;
       }
        /* 1 — turn any movement into a "hide" */
        hideTooltip();                // clears timer + fades out if visible

        /* 2 — update the pointer NDC */
        pointer.x =  (event.clientX / window.innerWidth ) * 2 - 1;
        pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;

        /* helper to climb to the GLB root */
        function findGLBRoot(obj) {
            while (obj && obj !== scene) {
                if ((obj.name || "").toLowerCase().endsWith(".glb")) return obj;
                obj = obj.parent;
            }
            return null;
        }

        /* 3 — ray‑cast and arm a NEW timer (only if cursor stays put) */
        raycaster.setFromCamera(pointer, camera);
        const firstHit = raycaster.intersectObjects(scene.children, true)[0];
        const hitRoot  = firstHit ? findGLBRoot(firstHit.object) : null;

        hoverObject = hitRoot;        // remember current object (may be null)

        /* 4 — check if hovering over a cone and disable/enable zoom accordingly */
        const coneHit = raycaster.intersectObjects(markers).find(i => i.object.cameraPos && i.object.parent.visible);
        if (coneHit) {
            // Hovering over a cone - disable zoom functionality
            orbitalControls.enableZoom = false;
            orbitalControls.enablePan = false;
            orbitalControls.enableRotate = false;
            renderer.domElement.style.cursor = 'pointer';
        } else {
            // Not hovering over a cone - enable zoom functionality
            orbitalControls.enableZoom = true;
            orbitalControls.enablePan = true;
            orbitalControls.enableRotate = true;
            renderer.domElement.style.cursor = 'default';
        }

        if (hoverObject) {
            hoverTimerId = setTimeout(() => {
                showTooltip(event.clientX, event.clientY,
                            "Double-click to refocus");
            }, 1000);   // 1 s delay (set to 3000 for 3 s)
        }
    }

    function handleFloors() {
        //Floor section
        //Dynamically add Floors section
        var floorNumbers = [];
        const labelDivInstance = document.getElementById("labelDiv");
        if (labelDivInstance) {
            labelDivInstance.remove();
        }
        globalFloors.forEach((e) => {
            // console.log("Pushing " + e.floor);
            if (!floorNumbers.includes(e.floor)) {
                floorNumbers.push(e.floor);
            }
        });

        // console.log(floorNumbers);
        // console.log(globalFloors);

        if (floorNumbers.length > 0) {
            const floorSection = document.getElementById("show-floors");
            // console.log(floorSection);
            if (floorSection.classList.contains("hidden")) {
                floorSection.classList.remove("hidden");
            }
            const listChild = floorSection.getElementsByTagName("*");
            // console.log(listChild);
            if (listChild.length > 0) {
                Array.from(listChild).forEach((element) => {
                    element.remove();
                });
            }

            const checkboxesId = [];

            floorNumbers.forEach((e) => {
                const div = document.createElement("div");
                const checkbox = document.createElement("input");
                const label = document.createElement("label");

                label.innerText = `Floor ${e}`;
                label.htmlFor = `floor-${e}-checkbox`;

                checkbox.type = "checkbox";
                checkbox.checked = true;
                checkbox.id = `floor-${e}-checkbox`;
                checkbox.setAttribute("class", "mr-1");

                checkboxesId.push(`floor-${e}-checkbox`);
                div.appendChild(checkbox);
                div.appendChild(label);
                div.setAttribute("class", "p-2 bg-zinc-100 rounded-sm mt-1");

                checkbox.addEventListener("change", (e) => {
                    // const g = globalSvgContainer.querySelector('g')
                    const selectedFloor = e.target.id.split("-")[1];
                    const selectedMarkers = globalFloors.filter(
                        (i) => i.floor == selectedFloor,
                    );

                    if (e.target.checked) {
                        selectedMarkers.forEach((e) => {
                            e.arrow.visible = true;
                        });
                    } else {
                        selectedMarkers.forEach((e) => {
                            e.arrow.visible = false;
                        });
                    }

                    createLabels();
                });

                floorSection.appendChild(div);
            });
        }
    }

let lastConeClicked = null;   // remembers which cone we clicked last
let showGeneratedView   = false;  // toggle state *for that cone only*

async function reviewVR(event) {
    const intersects = raycaster.intersectObjects(markers);
    const hit = intersects.find(i => i.object.cameraPos && i.object.parent.visible);
    if (!hit) return;

    const cone       = hit.object;
    const panel      = document.getElementById("vr-image-panel");
    const img        = document.getElementById("vr-img");
    const flippedTag = document.getElementById("vr-flipped-tag");
    const targetName = cone.name.toLowerCase();

    // Helper function to apply flipping based on image name
    function applyImageFlipping(imageName) {
        const shouldFlip = imageName.toLowerCase().includes("bf");
        
        if (shouldFlip) {
            img.style.transform = "scaleX(-1)";
            flippedTag.classList.remove("hidden");
        } else {
            img.style.transform = "scaleX(1)";
            flippedTag.classList.add("hidden");
        }
    }

    /* ───── decide which view to show ───── */
    if (cone !== lastConeClicked) {          // new cone → always start in photo mode
        lastConeClicked = cone;
        showGeneratedView = false;
    } else {
        showGeneratedView = !showGeneratedView;      // same cone → toggle back / forth
    }

    if (showGeneratedView) {
        console.log(cone)
        const renderURL = await render360SnapshotForCone(cone);
        img.src = renderURL;
        
        // Set up rotation for generated view
        setVRImage(renderURL, cone.name);
        
        // Hide overlay for generated views (since we're already showing the rendered view)
        vrOverlayCanvas.style.display = 'none';
        
        // For generated views, check cone name for flipping
        applyImageFlipping(cone.name);
        panel.classList.remove("hidden");
    } else {
        try {
            // Show loading indicator
            img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23666'%3ELoading...%3C/text%3E%3C/svg%3E";
            panel.classList.remove("hidden");
            
            // Use persistent image manager for on-demand loading
            const entry = await imageManager.findImageByName(targetName, 'medium');
            if (entry) {
                img.src = entry.image;
                
                // Set up rotation for equirectangular image
                setVRImage(entry.image, entry.name);
                
                // Prepare overlay and show it for comparison
                await renderOverlayCanvas(cone);
                vrOverlayCanvas.style.display = 'block';
                vrOverlayCanvas.style.opacity = '0.45';
                
                // Apply flipping based on the image entry name
                applyImageFlipping(entry.name);
            } else {
                // Hide panel and reset states
                img.style.transform = "scaleX(1)";
                flippedTag.classList.add("hidden");
                vrDragOverlay.classList.add("hidden");
                vrRotationDisplay.classList.add("hidden");
                vrOverlayCanvas.style.display = 'none';
                panel.classList.add("hidden");
                console.warn(`Image not found: ${targetName}`);
            }
        } catch (error) {
            console.error(`Error loading image ${targetName}:`, error);
            // Show error state
            img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23ff0000'%3EError loading image%3C/text%3E%3C/svg%3E";
        }
    }

}

async function renderOverlayCanvas(cone) {
    if (!vrOverlayCanvas || !cone) {
        console.warn('Missing overlay canvas or cone');
        return;
    }
    
    try {
    // Set overlay canvas size to match the panel
    const panel = document.getElementById("vr-image-panel");
        if (!panel) {
            console.warn('VR panel not found');
            return;
        }
        
    vrOverlayCanvas.width = panel.offsetWidth;
    vrOverlayCanvas.height = panel.offsetHeight;
        
        console.log(`Rendering overlay for cone: ${cone.name}`);
    
    // Generate a separate render for the overlay
    const overlayRenderURL = await render360SnapshotForCone(cone);
    
        // Load and draw the overlay image
        return new Promise((resolve, reject) => {
    const overlayImg = new Image();
            
    overlayImg.onload = function() {
                try {
        vrOverlayCtx.clearRect(0, 0, vrOverlayCanvas.width, vrOverlayCanvas.height);
        vrOverlayCtx.drawImage(overlayImg, 0, 0, vrOverlayCanvas.width, vrOverlayCanvas.height);
                    
                    // Ensure the overlay is visible
                    vrOverlayCanvas.style.display = 'block';
                    vrOverlayCanvas.style.opacity = '0.45';
                    
                    console.log(`Overlay successfully rendered for cone: ${cone.name}`);
                    resolve();
                } catch (error) {
                    console.error('Error drawing overlay:', error);
                    reject(error);
                }
            };
            
            overlayImg.onerror = function() {
                console.error('Failed to load overlay image');
                reject(new Error('Failed to load overlay image'));
            };
            
            overlayImg.src = overlayRenderURL;
        });
    } catch (error) {
        console.error('Error in renderOverlayCanvas:', error);
        throw error;
    }
}

    // Canvas pool for efficient reuse
    class CanvasPool {
        constructor(maxSize = 5) {
            this.pool = [];
            this.maxSize = maxSize;
        }

        getCanvas(width, height) {
            let canvas = this.pool.find(c => 
                c.width >= width && c.height >= height && !c.inUse
            );
            
            if (!canvas) {
                if (this.pool.length < this.maxSize) {
                    canvas = document.createElement('canvas');
                    this.pool.push(canvas);
                } else {
                    // Reuse oldest canvas
                    canvas = this.pool.find(c => !c.inUse) || this.pool[0];
                }
            }
            
            canvas.width = width;
            canvas.height = height;
            canvas.inUse = true;
            return canvas;
        }

        releaseCanvas(canvas) {
            if (canvas) {
                canvas.inUse = false;
                // Clear canvas
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        cleanup() {
            this.pool.forEach(canvas => {
                canvas.inUse = false;
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            });
        }
    }

    const canvasPool = new CanvasPool(5);

    // Debounce utility for performance optimization
    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }

    // VR Image Rotation Variables
    let vrCurrentImage = null;
    let vrRotation = 0; // degrees
    let vrIsDragging = false;
    let vrLastMouseX = 0;
    let vrImageSize = { width: 0, height: 0 };
    
    // Debounced version of drawVRRotatedImage for better performance
    const debouncedDrawVRRotatedImage = debounce(drawVRRotatedImage, 16); // ~60fps max

    // VR Image Rotation DOM Elements
    const vrOverlayCanvas = document.getElementById('vr-overlay-canvas');
    const vrDragOverlay = document.getElementById('vr-drag-overlay');
    const vrRotationDisplay = document.getElementById('vr-rotation-display');
    const vrOverlayCtx = vrOverlayCanvas.getContext('2d');

    // VR Image Rotation Event Handlers
    vrDragOverlay.addEventListener('mousedown', handleVRMouseDown);
    window.addEventListener('mousemove', handleVRMouseMove);
    window.addEventListener('mouseup', handleVRMouseUp);

    function handleVRMouseDown(e) {
        if (!vrCurrentImage) return;
        
        vrIsDragging = true;
        vrLastMouseX = e.clientX;
        vrDragOverlay.style.cursor = 'grabbing';
        
        // Show overlay when starting to drag
        if (vrOverlayCanvas && !showGeneratedView) {
            vrOverlayCanvas.style.display = 'block';
        }
    }

    function handleVRMouseMove(e) {
        if (!vrIsDragging) return;
        
        const deltaX = e.clientX - vrLastMouseX;
        
        // Convert pixels to degrees (adjust sensitivity)
        vrRotation -= deltaX * 0.5;
        // Keep rotation in range -180 to 180
        vrRotation = ((vrRotation + 180) % 360) - 180;
        
        // Update display
        updateVRRotationDisplay();
        
        // Redraw rotated image (debounced for better performance)
        debouncedDrawVRRotatedImage();
        
        vrLastMouseX = e.clientX;
    }

    function handleVRMouseUp() {
        vrIsDragging = false;
        vrDragOverlay.style.cursor = 'grab';
        
        // Hide overlay when done dragging
        if (vrOverlayCanvas) {
            vrOverlayCanvas.style.display = 'none';
        }
    }

    function updateVRRotationDisplay() {
        vrRotationDisplay.textContent = `Rotation: ${vrRotation.toFixed(1)}°`;
    }

    function drawVRRotatedImage() {
        if (!vrCurrentImage) return;
        
        const img = document.getElementById('vr-img');
        
        // Use canvas pool for better performance
        const canvas = canvasPool.getCanvas(vrImageSize.width, vrImageSize.height);
        const ctx = canvas.getContext('2d');
        
        // Calculate horizontal offset for rotation
        let xOffset = (vrRotation / 360) * vrImageSize.width;
        xOffset = ((xOffset % vrImageSize.width) + vrImageSize.width) % vrImageSize.width;
        
        // Calculate available width from xOffset to the image end
        const availableWidth = vrImageSize.width - xOffset;
        
        // Create a temporary image element for drawing
        const tempImg = new Image();
        tempImg.onload = function() {
            // Draw the right segment of the image
            ctx.drawImage(
                tempImg,
                xOffset, 0, availableWidth, vrImageSize.height,
                0, 0, availableWidth, vrImageSize.height
            );
            
            // Draw the left segment to complete the wrap-around
            if (xOffset > 0) {
                ctx.drawImage(
                    tempImg,
                    0, 0, xOffset, vrImageSize.height,
                    availableWidth, 0, xOffset, vrImageSize.height
                );
            }
            
            // Update the main image with reduced quality for better performance
            img.src = canvas.toDataURL('image/jpeg', 0.7);
            
            // Release canvas back to pool
            canvasPool.releaseCanvas(canvas);
        };
        tempImg.src = vrCurrentImage;
    }

    function setVRImage(imageSrc, imageName) {
        vrCurrentImage = imageSrc;
        vrRotation = 0;
        
        // Create a temporary image to get dimensions
        const tempImg = new Image();
        tempImg.onload = function() {
            vrImageSize.width = tempImg.width;
            vrImageSize.height = tempImg.height;
            
            // Show rotation controls
            vrDragOverlay.classList.remove('hidden');
            vrRotationDisplay.classList.remove('hidden');
            updateVRRotationDisplay();
        };
        tempImg.src = imageSrc;
    }
    

    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(512, {
        format: THREE.RGBAFormat,
        generateMipmaps: false,
        minFilter: THREE.LinearFilter,
    });

    // CubeCamera will render into cubeRenderTarget
    const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
    scene.add(cubeCamera);

    // after you've created cubeRenderTarget & cubeCamera…

    // 1. Full‐screen quad geometry (2:1 aspect space)
    const quadGeo = new THREE.PlaneGeometry(2, 2);

    // 2. ShaderMaterial that maps UV→direction→cubemap
    const eqMaterial = new THREE.ShaderMaterial({
        uniforms: {
            envMap: { value: cubeRenderTarget.texture },
        },
        vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = vec4(position, 1.0);
    }
  `,
        fragmentShader: `
    #define PI 3.141592653589793
    varying vec2 vUv;
    uniform samplerCube envMap;
    void main() {
      // φ ∈ [0,2π], θ ∈ [0,π]
      float phi   = vUv.x * PI * 2.0;
      float theta = PI - (vUv.y * PI);
      vec3 dir = vec3(
        sin(theta) * cos(phi),
        cos(theta),
        sin(theta) * sin(phi)
      );
      gl_FragColor = textureCube(envMap, dir);
    }
  `,
        depthTest: false,
        depthWrite: false,
    });

    // 3. Put it in its own scene
    // 3. Build the EQ scene & camera
    const eqScene = new THREE.Scene();
    const quadMesh = new THREE.Mesh(quadGeo, eqMaterial);
    quadMesh.frustumCulled = false; // ensure it always draws
    eqScene.add(quadMesh);

    // 4. Orthographic camera that exactly covers NDC –1 to +1 in X & Y
    const eqCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    eqMaterial.needsUpdate = true;

    window.addEventListener("pointermove", onPointerMove);

    window.addEventListener("click", reviewVR);

    window.addEventListener("keydown", (e) => {
        if (e.key == "ArrowLeft") {
            console.log(e.key);
            camera.rotateY(THREE.MathUtils.degToRad(5));
        } else if (e.key == "ArrowRight") {
            console.log(e.key);
            camera.rotateY(THREE.MathUtils.degToRad(-5));
        }
        if (e.key == "ArrowUp") {
            console.log(e.key);
            camera.rotateX(THREE.MathUtils.degToRad(5));
        } else if (e.key == "ArrowDown") {
            console.log(e.key);
            camera.rotateX(THREE.MathUtils.degToRad(-5));
        }
    });

    const orbitalControls = new OrbitControls(camera, renderer.domElement);
    orbitalControls.enableKeys = false;

    function fitCameraToObject(cam, controls, obj, padding = 2.5, duration = 0.6) {
    // 1. Get world-space bounding box & size
    const box   = new THREE.Box3().setFromObject(obj);
    const size  = box.getSize(new THREE.Vector3());
    const center= box.getCenter(new THREE.Vector3());

    // 2. Figure out the largest side and required distance
    const maxDim = Math.max(size.x, size.y, size.z);
    const fov    = cam.fov * (Math.PI/180);
    let   dist   = (maxDim/2) / Math.tan(fov/2);
    dist  *= padding;                // add some head-room

    // 3. Build new camera position (keep same spherical angle)
    const dir = new THREE.Vector3()
                    .subVectors(cam.position, controls.target)
                    .normalize();
    const newPos = dir.multiplyScalar(dist).add(center);

    // 4. Animate camera & target
    const tweenObj = {
        cx: cam.position.x, cy: cam.position.y, cz: cam.position.z,
        tx: controls.target.x, ty: controls.target.y, tz: controls.target.z
    };
    gsap.to(tweenObj, {
        cx: newPos.x, cy: newPos.y, cz: newPos.z,
        tx: center.x, ty: center.y, tz: center.z,
        duration,
        ease: "power2.out",
        onUpdate: () => {
        cam.position.set(tweenObj.cx, tweenObj.cy, tweenObj.cz);
        controls.target.set(tweenObj.tx, tweenObj.ty, tweenObj.tz);
        controls.update();
        }
    });
    }

    // Variables for keyboard control
    const keyState = {};

    // CSV navigation variables
    let currentCsvIndex = 0;
    let csvPoints = [];

    // Event listeners for keydown and keyup
    window.addEventListener("keydown", (event) => {
        keyState[event.key.toLowerCase()] = true;
        
        // Handle arrow key navigation for CSV points
        if (event.key === "ArrowRight" || event.key === "ArrowLeft") {
            event.preventDefault(); // Prevent default arrow key behavior
            if (event.key === "ArrowRight") {
                navigateToNextCsvPoint().catch(console.error);
            } else if (event.key === "ArrowLeft") {
                navigateToPreviousCsvPoint().catch(console.error);
            }
        }
    });

    window.addEventListener("keyup", (event) => {
        keyState[event.key.toLowerCase()] = false;
    });

    // Function to navigate to the next CSV point
    async function navigateToNextCsvPoint() {
        if (csvPoints.length === 0) {
            updateCsvPointsList();
        }
        
        if (csvPoints.length > 0) {
            currentCsvIndex = (currentCsvIndex + 1) % csvPoints.length;
            await focusOnCsvPoint(csvPoints[currentCsvIndex]);
            updateNavigationDisplay();
        }
    }

    // Function to navigate to the previous CSV point
    async function navigateToPreviousCsvPoint() {
        if (csvPoints.length === 0) {
            updateCsvPointsList();
        }
        
        if (csvPoints.length > 0) {
            currentCsvIndex = (currentCsvIndex - 1 + csvPoints.length) % csvPoints.length;
            await focusOnCsvPoint(csvPoints[currentCsvIndex]);
            updateNavigationDisplay();
        }
    }

    // Function to update the list of CSV points
    function updateCsvPointsList() {
        csvPoints = markers.filter(marker => marker.cameraPos && marker.parent && marker.parent.visible);
        currentCsvIndex = 0;
        console.log(`Found ${csvPoints.length} CSV points for navigation`);
    }

    // Function to focus camera on a specific CSV point
    async function focusOnCsvPoint(point) {
        if (!point) return;
        
        // Calculate a position slightly offset from the point for better viewing
        const offset = new THREE.Vector3(0, 50, 100); // Offset up and back
        const targetPosition = point.position.clone().add(offset);
        
        // Animate camera to the new position
        gsap.to(camera.position, {
            x: targetPosition.x,
            y: targetPosition.y,
            z: targetPosition.z,
            duration: 1,
            ease: "power2.out",
            onUpdate: () => {
                orbitalControls.target.copy(point.position);
                orbitalControls.update();
            }
        });
        
        // Update VR image panel to match the selected point
        await updateVRPanelForPoint(point);
        
        console.log(`Navigated to CSV point: ${point.name}`);
    }

    // Function to update VR panel for a specific point
    async function updateVRPanelForPoint(point) {
        const panel = document.getElementById("vr-image-panel");
        const img = document.getElementById("vr-img");
        const flippedTag = document.getElementById("vr-flipped-tag");
        const targetName = point.name.toLowerCase();

        // Helper function to apply flipping based on image name
        function applyImageFlipping(imageName) {
            const shouldFlip = imageName.toLowerCase().includes("bf");
            
            if (shouldFlip) {
                img.style.transform = "scaleX(-1)";
                flippedTag.classList.remove("hidden");
            } else {
                img.style.transform = "scaleX(1)";
                flippedTag.classList.add("hidden");
            }
        }

        // Show loading indicator
        img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23666'%3ELoading...%3C/text%3E%3C/svg%3E";
        panel.classList.remove("hidden");

        try {
            // Use persistent image manager for on-demand loading
            const entry = await imageManager.findImageByName(targetName, 'medium');
            if (entry) {
                img.src = entry.image;
                
                // Set up rotation for equirectangular image
                setVRImage(entry.image, entry.name);
                
                // Show drag overlay and rotation display
                vrDragOverlay.classList.remove("hidden");
                vrRotationDisplay.classList.remove("hidden");
                
                // Immediately show overlay canvas (will be updated when rendering completes)
                vrOverlayCanvas.style.display = 'block';
                vrOverlayCanvas.style.opacity = '0.45';
                
                // Prepare overlay and show it for comparison
                try {
                    await renderOverlayCanvas(point);
                    console.log('Overlay rendering completed successfully');
                } catch (overlayError) {
                    console.error('Error rendering overlay:', overlayError);
                    // Overlay is already visible from above, so we just log the error
                }
                
                // Apply flipping based on the image entry name
                applyImageFlipping(entry.name);
                
                console.log(`VR panel updated for point: ${point.name}`);
            } else {
                // Hide panel and reset states
                img.style.transform = "scaleX(1)";
                flippedTag.classList.add("hidden");
                vrDragOverlay.classList.add("hidden");
                vrRotationDisplay.classList.add("hidden");
                vrOverlayCanvas.style.display = 'none';
                panel.classList.add("hidden");
                console.warn(`Image not found: ${targetName}`);
            }
        } catch (error) {
            console.error(`Error loading image ${targetName}:`, error);
            // Show error state
            img.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='200' height='100'%3E%3Ctext x='50%25' y='50%25' text-anchor='middle' dy='.3em' fill='%23ff0000'%3EError loading image%3C/text%3E%3C/svg%3E";
        }
    }

    // Function to update the navigation display
    function updateNavigationDisplay() {
        const button = document.getElementById('next-csv-point');
        if (button && csvPoints.length > 0) {
            button.textContent = `Next Point (${currentCsvIndex + 1}/${csvPoints.length})`;
            // Re-add the SVG icon
            const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
            svg.setAttribute("xmlns", "http://www.w3.org/2000/svg");
            svg.setAttribute("width", "16");
            svg.setAttribute("height", "16");
            svg.setAttribute("viewBox", "0 0 24 24");
            svg.setAttribute("fill", "none");
            svg.setAttribute("stroke", "currentColor");
            svg.setAttribute("stroke-linecap", "round");
            svg.setAttribute("stroke-linejoin", "round");
            svg.setAttribute("class", "ml-2");
            
            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
            path.setAttribute("d", "M9 18l6-6-6-6");
            path.setAttribute("stroke-width", "2");
            svg.appendChild(path);
            
            button.appendChild(svg);
        }
    }

    // Adjust these speeds to control rotation and movement
    const rotationSpeed = 0.02;
    const movementSpeed = 0.5;

    // 1) Double-click in the viewport → focus whatever you double-clicked
    renderer.domElement.addEventListener("dblclick", (e) => {
    pointer.x =  (e.clientX / window.innerWidth ) * 2 - 1;
    pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(pointer, camera);
    const hit = raycaster.intersectObjects(scene.children, true)[0];
    if (hit) fitCameraToObject(camera, orbitalControls, hit.object);
    });

    // Frame rate limiting for performance
    let lastTime = 0;
    const targetFPS = 60; // Limit to 50 FPS for better performance
    const frameInterval = 1000 / targetFPS;

    function animate(currentTime = 0) {
        // Limit frame rate
        if (currentTime - lastTime < frameInterval) {
            requestAnimationFrame(animate);
            return;
        }
        lastTime = currentTime;

        // Update raycaster for object intersections
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children);

        orthoRaycaster.setFromCamera(orthoPointer, orthoCamera);
        const orthoIntersects = orthoRaycaster.intersectObjects(scene.children);
        var label = document.getElementById("label");
        label.innerHTML = "";

        // Default Tag State
        document.getElementById("tag").style.display = "none";
        if (intersects.length > 0 && orthoIntersects.length > 0) {
            document.getElementById("tag").style.display = "flex";
            document.getElementById("tag").style.flexDirection = "column";

            var idLabel = document.createElement("p");
            var detailLabel = document.createElement("p");
            let positionObjects = intersects.filter(
                (item) => item.object.cameraPos && item.object.parent.visible,
            );

            let orthoPositionObjects = orthoIntersects.filter(
                (item) => item.object.cameraPos && item.object.parent.visible,
            );

            // positionObjects = orthoPositionObjects

            if (positionObjects.length > 0) {
                idLabel.innerText = `ID: ${positionObjects[0].object.name}`;
                idLabel.style.color = "#007700";
                idLabel.style.lineHeight = "1em";
                label.append(idLabel);

                idLabel.innerText += ` \nPos: ${positionObjects[0].object.position.x} ${positionObjects[0].object.position.y} ${positionObjects[0].object.position.z}`;
                idLabel.innerText += ` \nRot: ${THREE.MathUtils.radToDeg(positionObjects[0].object.rotation.x).toFixed(4)} ${THREE.MathUtils.radToDeg(positionObjects[0].object.rotation.z).toFixed(4)} ${THREE.MathUtils.radToDeg(positionObjects[0].object.rotation.y).toFixed(4)}`;
                detailLabel.style.color = "#007700";
                label.append(detailLabel);
            }
        }

        // Update camera position/rotation based on keyboard input
        if (keyState["arrowup"] || keyState["w"]) {
            camera.position.z -= movementSpeed;
        }
        if (keyState["arrowdown"] || keyState["s"]) {
            camera.position.z += movementSpeed;
        }
        if (keyState["arrowleft"] || keyState["a"]) {
            camera.rotation.y += rotationSpeed;
        }
        if (keyState["arrowright"] || keyState["d"]) {
            camera.rotation.y -= rotationSpeed;
        }

        // Ensure camera target is updated correctly after manual rotation
        orbitalControls.update();
        orthoCamera.position.copy(camera.position);
        orthoCamera.rotation.copy(camera.rotation);
        orthoCamera.zoom = 100 / orbitalControls.getDistance();
        orthoCamera.updateProjectionMatrix();
        // orthoCamera.left = (orthoView.clientWidth / -2) * orbitalControls.getDistance()
        // orthoCamera.right = (orthoView.clientWidth / 2) * orbitalControls.getDistance()
        // orthoCamera.top = (orthoView.clientHeight / 2) * orbitalControls.getDistance()
        // orthoCamera.bottom = (orthoView.clientHeight / -2) * orbitalControls.getDistance()

        requestAnimationFrame(animate);

        // Render loop - Optimized to reduce render calls
        renderer.clear();
        
        // Sort scene children by render order for proper z-indexing
        const sortedChildren = scene.children.slice().sort((a, b) => {
            return (a.renderOrder || 0) - (b.renderOrder || 0);
        });
        
        // Render scene with sorted children
        renderer.render(scene, camera);
        
        // Only render VRSpheres, objects, and markers if they have visible content
        if (VRSpheres.length > 0) {
            renderer.clearDepth();
            VRSpheres.forEach((e) => {
                if (e.children.length > 0) renderer.render(e, camera);
            });
        }

        if (objects.length > 0) {
            renderer.clearDepth();
            objects.forEach((e) => {
                if (e.children.length > 0) renderer.render(e, camera);
            });
        }

        if (markers.length > 0) {
            renderer.clearDepth();
            markers.forEach((e) => {
                if (e.children.length > 0) renderer.render(e, camera);
            });
        }

        updateLabelPositions();

        // Render loop for orthographic camera - Optimized
        orthoRenderer.clear();
        orthoRenderer.render(scene, orthoCamera);
        
        if (VRSpheres.length > 0) {
            orthoRenderer.clearDepth();
            VRSpheres.forEach((e) => {
                if (e.children.length > 0) orthoRenderer.render(e, orthoCamera);
            });
        }

        if (objects.length > 0) {
            orthoRenderer.clearDepth();
            objects.forEach((e) => {
                if (e.children.length > 0) orthoRenderer.render(e, orthoCamera);
            });
        }

        if (markers.length > 0) {
            orthoRenderer.clearDepth();
            markers.forEach((e) => {
                if (e.children.length > 0) orthoRenderer.render(e, orthoCamera);
            });
        }

        // console.log(orbitalControls.getDistance())

        // console.log(camera.position)
        // console.log(camera.rotation)
    }

    animate(performance.now());

    //Tag
    document.addEventListener("mousemove", (e) => {
        document.getElementById("tag").style.left = `${e.x}px`;
        document.getElementById("tag").style.top = `${e.y}px`;
        document.getElementById("tag").style.transform = `translate(${
            (e.clientX / window.innerWidth) * -100
        }%, ${(e.clientY / window.innerHeight) * -150}%)`;
    });

    const fbxFiles = [];
    const glbFiles = [];
    const csvGroups = [];
    const simplifiedNamesId = [];
    const images = [];
    let globalFloors = [];
    let originalWireframeMeshes = []

    // Load assets from provided data instead of fetching from server
    async function loadAssetsFromData(assetsData) {
        try {
            // Process GLB models
            if (assetsData.models && Array.isArray(assetsData.models)) {
                for (const modelData of assetsData.models) {
                    try {
                        let fileData;
                        
                        if (typeof modelData.data === 'string') {
                            // Handle base64 encoded data
                            const binaryStr = atob(modelData.data);
                            const len = binaryStr.length;
                            const bytes = new Uint8Array(len);
                            for (let i = 0; i < len; i++) {
                                bytes[i] = binaryStr.charCodeAt(i);
                            }
                            fileData = bytes;
                        } else if (modelData.data instanceof ArrayBuffer) {
                            // Handle ArrayBuffer data
                            fileData = new Uint8Array(modelData.data);
                        } else if (modelData.data instanceof Uint8Array) {
                            // Handle Uint8Array data
                            fileData = modelData.data;
                        } else {
                            throw new Error(`Unsupported model data format for ${modelData.modelName}`);
                        }

                        // Create a File object from the binary data
                        const blob = new Blob([fileData], {
                            type: "model/gltf-binary",
                        });
                        const glbFile = new File([blob], modelData.modelName, {
                            type: "model/gltf-binary",
                        });

                        // Process the GLB file
                        await handleFileChange(glbFile, [glbFile]);
                        console.log(`Loaded GLB model: ${modelData.modelName}`);
                    } catch (error) {
                        console.error(`Error loading model ${modelData.modelName}:`, error);
                    }
                }
            }

            // Process camera CSV data
            if (assetsData.cameraCSV) {
                try {
                    let csvBlob;
                    
                    if (typeof assetsData.cameraCSV.data === 'string') {
                        // Handle string CSV data
                        csvBlob = new Blob([assetsData.cameraCSV.data], {
                            type: "text/csv",
                        });
                    } else if (assetsData.cameraCSV.data instanceof ArrayBuffer) {
                        // Handle ArrayBuffer CSV data
                        csvBlob = new Blob([new Uint8Array(assetsData.cameraCSV.data)], {
                            type: "text/csv",
                        });
                    } else if (assetsData.cameraCSV.data.data) {
                        // Handle buffer with .data property (from server response)
                        csvBlob = new Blob([new Uint8Array(assetsData.cameraCSV.data.data)], {
                            type: "text/csv",
                        });
                    } else {
                        throw new Error("Unsupported CSV data format");
                    }

                    const csvFile = new File([csvBlob], assetsData.cameraCSV.csvName || 'camera.csv', { 
                        type: "text/csv" 
                    });

                    // Process the CSV file
                    await handleFileChange(csvFile, [csvFile]);
                    console.log(`Loaded camera CSV: ${assetsData.cameraCSV.csvName}`);
                } catch (error) {
                    console.error("Error loading camera CSV:", error);
                }
            }

            // Process image array with batch optimization
            if (assetsData.images && Array.isArray(assetsData.images)) {
                console.log(`Preparing to load ${assetsData.images.length} images...`);
                
                // Prepare image data for batch processing
                const imageDataForBatch = [];
                
                for (const imageData of assetsData.images) {
                    try {
                        let dataURL;
                        
                        if (typeof imageData.data === 'string') {
                            if (imageData.data.startsWith('data:')) {
                                // Handle data URL directly
                                dataURL = imageData.data;
                            } else {
                                // Handle base64 encoded image
                                const binaryStr = atob(imageData.data);
                                const len = binaryStr.length;
                                const bytes = new Uint8Array(len);
                                for (let i = 0; i < len; i++) {
                                    bytes[i] = binaryStr.charCodeAt(i);
                                }
                                const imageBlob = new Blob([bytes], {
                                    type: imageData.mimeType || "image/jpeg",
                                });
                                dataURL = await new Promise((resolve) => {
                                    const reader = new FileReader();
                                    reader.onload = (e) => resolve(e.target.result);
                                    reader.readAsDataURL(imageBlob);
                                });
                            }
                        } else if (imageData.data instanceof ArrayBuffer) {
                            // Handle ArrayBuffer image data
                            const imageBlob = new Blob([imageData.data], {
                                type: imageData.mimeType || "image/jpeg",
                            });
                            dataURL = await new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(imageBlob);
                            });
                        } else if (imageData.data instanceof Uint8Array) {
                            // Handle Uint8Array image data
                            const imageBlob = new Blob([imageData.data], {
                                type: imageData.mimeType || "image/jpeg",
                            });
                            dataURL = await new Promise((resolve) => {
                                const reader = new FileReader();
                                reader.onload = (e) => resolve(e.target.result);
                                reader.readAsDataURL(imageBlob);
                            });
                        } else {
                            throw new Error(`Unsupported image data format for ${imageData.imageName}`);
                        }

                        if (dataURL) {
                            imageDataForBatch.push({
                                name: imageData.imageName,
                                data: dataURL
                            });
                        }
                        
                    } catch (error) {
                        console.error(`Error preparing image ${imageData.imageName}:`, error);
                    }
                }
                
                // Index all images instantly (no compression during load)
                if (imageDataForBatch.length > 0) {
                    await imageManager.indexBatch(imageDataForBatch, 100); // Index 100 images at a time
                    console.log(`Successfully indexed ${imageDataForBatch.length} images for on-demand loading`);
                }
            }

            console.log("All assets loaded successfully");
        } catch (error) {
            console.error("Error loading assets:", error);
        }
    }

    // Example of how to use the new function:
    // loadAssetsFromData({
    //     models: [
    //         { modelName: "model1.glb", data: "base64EncodedData..." },
    //         { modelName: "model2.glb", data: arrayBufferData }
    //     ],
    //     cameraCSV: {
    //         csvName: "cameras.csv",
    //         data: "csvStringData..."
    //     },
    //     images: [
    //         { imageName: "image1.jpg", data: "base64EncodedData...", mimeType: "image/jpeg" },
    //         { imageName: "image2.jpg", data: arrayBufferData, mimeType: "image/jpeg" }
    //     ]
    // });

    // Get project key from URL parameters
    function getProjectKeyFromURL() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('project') || urlParams.get('key') || urlParams.get('id') || 'default';
    }

    // Helper function to fetch assets from server using project key
    async function fetchAssetsFromServer(projectKey) {
        if (!projectKey) {
            projectKey = getProjectKeyFromURL();
        }

        try {
            console.log(`Loading project: ${projectKey}`);
            
            // Single endpoint to fetch all assets for a project
            const response = await fetch(`http://localhost:9234/api/project/${projectKey}`);
            
            if (!response.ok) {
                throw new Error(`Failed to fetch project ${projectKey}: ${response.status} ${response.statusText}`);
            }

            const assetsData = await response.json();
            console.log(`Successfully loaded project ${projectKey}:`, {
                models: assetsData.models?.length || 0,
                images: assetsData.images?.length || 0,
                hasCamera: !!assetsData.cameraCSV
            });

            return assetsData;
        } catch (error) {
            console.error(`Error fetching project ${projectKey}:`, error);
            
            // Fallback: try legacy endpoints for backward compatibility
            try {
                console.log("Trying legacy endpoints...");
                const assetsData = {};

                const modelResponse = await fetch("http://localhost:9234/model");
                if (modelResponse.ok) {
                    const { models } = await modelResponse.json();
                    assetsData.models = models;
                }

                const csvResponse = await fetch("http://localhost:9234/camera-csv");
                if (csvResponse.ok) {
                    const csvData = await csvResponse.json();
                    assetsData.cameraCSV = csvData;
                }

                return assetsData;
            } catch (legacyError) {
                console.error("Legacy endpoints also failed:", legacyError);
                return {};
            }
        }
    }

    // Display current project info in UI
    function displayProjectInfo(projectKey) {
        const uiArea = document.getElementById('ui-area');
        if (uiArea) {
            // Remove existing project info
            const existingInfo = uiArea.querySelector('.project-info');
            if (existingInfo) existingInfo.remove();

            // Project info pill is hidden per user request
            return;

            // Add new project info (commented out to hide the pill)
            /* 
            const projectInfo = document.createElement('div');
            projectInfo.className = 'project-info bg-blue-100 p-2 rounded-md mb-3 text-xs';
            projectInfo.innerHTML = `
                <div class="flex items-center justify-between">
                    <span><strong>Project:</strong> ${projectKey}</span>
                    <button id="share-link" class="bg-blue-500 text-white px-2 py-1 rounded text-xs hover:bg-blue-600">
                        📋 Copy Link
                    </button>
                </div>
            `;
            
            // Insert after the home link
            const homeLink = uiArea.querySelector('a[href="/"]');
            if (homeLink && homeLink.parentElement) {
                homeLink.parentElement.insertBefore(projectInfo, homeLink.parentElement.children[1]);
            }

            // Add copy link functionality
            document.getElementById('share-link')?.addEventListener('click', () => {
                const shareUrl = `${window.location.origin}${window.location.pathname}?project=${projectKey}`;
                navigator.clipboard.writeText(shareUrl).then(() => {
                    const btn = document.getElementById('share-link');
                    const originalText = btn.textContent;
                    btn.textContent = '✅ Copied!';
                    btn.style.backgroundColor = '#10b981';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '';
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy link:', err);
                    alert(`Share this link: ${shareUrl}`);
                });
            });
            */
        }
    }

    // Auto-load project from URL parameter
    const projectKey = getProjectKeyFromURL();
    displayProjectInfo(projectKey);
    fetchAssetsFromServer(projectKey).then(loadAssetsFromData);

    // Alternative: Load assets directly (uncomment and provide your data)
    // loadAssetsFromData({
    //     models: [
    //         { modelName: "model1.glb", data: "base64EncodedData..." },
    //         { modelName: "model2.glb", data: arrayBufferData }
    //     ],
    //     cameraCSV: {
    //         csvName: "cameras.csv",
    //         data: "csvStringData..."
    //     },
    //     images: [
    //         { imageName: "image1.jpg", data: "base64EncodedData...", mimeType: "image/jpeg" },
    //         { imageName: "image2.jpg", data: arrayBufferData, mimeType: "image/jpeg" }
    //     ]
    // });

    //File Drop
    function handleDrop(event) {
        event.preventDefault();
        const items = event.dataTransfer.items;
        const files = event.dataTransfer.files;
        console.log(event.dataTransfer);

        handleFileChange(items, files);
    }

    async function handleFileChange(items, files) {
        console.log("Dropped files:", files);
        const fileArray = Array.from(files);

        for (let i = 0; i < fileArray.length; i++) {
            const file = fileArray[i];
            const lower = file.name.toLowerCase();
            console.log("Processing:", file.name);

            // ----- Directory? -----
            const item = items[i];
            if (item && item.webkitGetAsEntry) {
                const entry = item.webkitGetAsEntry();
                if (entry && entry.isDirectory) {
                    // recurse through folders
                    await enumerateDirectoryWithManyFiles(entry);
                    continue;
                }
            }

            // ----- CSV -----
            if (file.type === "text/csv" || lower.endsWith(".csv")) {
                globalFloors = [];
                const text = await file.text();
                processCSVData(text, file.name);
                continue;
            }

            // ----- GLB / GLTF -----
            if (file.type === "model/gltf-binary" || lower.endsWith(".glb")) {
                const arrayBuffer = await file.arrayBuffer();

                // read the JSON chunk to detect Draco
                try {
                    const dv = new DataView(arrayBuffer);
                    const decoder = new TextDecoder("utf-8");
                    const jsonLen = dv.getUint32(12, true);
                    const jsonChunk = new Uint8Array(arrayBuffer, 20, jsonLen);
                    const jsonText = decoder.decode(jsonChunk);
                    const json = JSON.parse(jsonText);
                    console.log(
                        "GLB uses DRACO?",
                        json.extensionsUsed?.includes(
                            "KHR_draco_mesh_compression",
                        ),
                    );
                } catch (e) {
                    console.warn("Failed to inspect GLB JSON chunk:", e);
                }

                GLTFloader.parse(
                    arrayBuffer,
                    "",
                    (gltf) => {
                        applyLitMaterialToGLTF(gltf.scene);
                        gltf.scene.name = file.name;
                        gltf.scene.scale.set(100, 100, 100);
                        objects.push(gltf.scene);
                        simplifiedNamesId.push({
                            uuid: gltf.scene.uuid,
                            simplifiedName: file.name.replace(/\D/g, ""),
                        });
                        scene.add(gltf.scene);
                        updateOutliner();
                    },
                    (err) => console.error("GLB load error:", err),
                );
                continue;
            }

            // ----- FBX -----
            if (lower.endsWith(".fbx")) {
                const arrayBuffer = await file.arrayBuffer();
                // turn into a Blob URL for FBXLoader
                const blob = new Blob([arrayBuffer]);
                const url = URL.createObjectURL(blob);

                const loader = new FBXLoader();
                loader.load(
                    url,
                    (fbx) => {
                        applyLitMaterialToGLTF(fbx);
                        fbx.name = file.name;
                        fbx.scale.set(0.1, 0.1, 0.1);
                        objects.push(fbx);
                        simplifiedNamesId.push({
                            uuid: fbx.uuid,
                            simplifiedName: file.name.replace(/\D/g, ""),
                        });
                        scene.add(fbx);
                        updateOutliner();
                        URL.revokeObjectURL(url);
                    },
                    undefined,
                    (err) => console.error("FBX load error:", err),
                );
                continue;
            }

            // ----- JPG / Other Images -----
            if (file.type.startsWith("image/") && (lower.endsWith(".jpg") || lower.endsWith(".png"))) {
                const dataURL = await new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.readAsDataURL(file);
                });
                
                // Index image for on-demand loading
                const indexed = await imageManager.addImage(file.name, dataURL);
                imageArray.push(indexed);
                continue;
            }

            console.warn("Unsupported file type:", file.name);
        }
    }

    function applyLitMaterialToGLTF(gltfScene) {
        const material = new THREE.MeshStandardMaterial({
            color: 0x00ff00, // Set your desired color
            wireframe: true, // Default to wireframe off
            depthTest: true,
            depthWrite: true,
            transparent: false
        });

        gltfScene.traverse((child) => {
            if (child.isMesh) {
                child.material = material;
                child.material.wireframe = true; // Ensure wireframe is initially false
                child.renderOrder = 0; // Lower render order for wireframes
                originalWireframeMeshes.push(child);
            }
        });
    }

    async function enumerateDirectoryWithManyFiles(directoryEntry) {
        //Workaround because readEntries only reads 100 files
        let reader = directoryEntry.createReader();
        let resultEntries = [];

        let read = async function () {
            let entries = await traverseDirectoryAsync(reader);
            if (entries.length > 0) {
                resultEntries = resultEntries.concat(entries);
                await read();
            }
        };

        await read();
        return resultEntries;
    }

    function getGrandparent(entry) {
        return new Promise((resolve, reject) => {
            entry.getParent(
                (parent) => {
                    parent.getParent(
                        (grandparent) => {
                            resolve(grandparent.name);
                        },
                        (error) => {
                            reject(error);
                        },
                    );
                },
                (error) => {
                    reject(error);
                },
            );
        });
    }
    //Traverse File Tree Workaround because readEntries only reads 100 files
    function traverseDirectoryAsync(reader) {
        return new Promise((resolve, reject) => {
            reader.readEntries(
                (entries) => {
                    var objectCount = 0;

                    entries.forEach((entry) => {
                        if (entry.isFile && entry.name.endsWith(".fbx")) {
                            entry.file((file) => {
                                objectCount++;
                                const tempCount = objectCount;
                                const reader = new FileReader();
                                reader.readAsArrayBuffer(file);
                                reader.onload = (event) => {
                                    const arrayBuffer = event.target.result;
                                    const loader = new FBXLoader();
                                    const item = loader.parse(arrayBuffer, "");
                                    var currentObject;
                                    getGrandparent(entry)
                                        .then((grandparentName) => {
                                            item.unitName = grandparentName;
                                            item.name = entry.name;
                                            currentObject = {
                                                fileName: entry.name,
                                                unitName: grandparentName,
                                            };
                                            const csvObject = csvGroups.find(
                                                (x) =>
                                                    x.userData
                                                        .simplifiedName ===
                                                    grandParent,
                                            );
                                            var newObject = {
                                                uuid: item.uuid,
                                                simplifiedName: grandparentName,
                                                csvObject: csvObject
                                                    ? csvObject
                                                    : "",
                                            };
                                            simplifiedNamesId.push(newObject);
                                            fbxFiles.push(currentObject);

                                            const fileUploadEvent =
                                                new CustomEvent("file-upload", {
                                                    detail: currentObject,
                                                });
                                            window.dispatchEvent(
                                                fileUploadEvent,
                                            );
                                        })
                                        .catch((error) =>
                                            console.error(
                                                "Error fetching grandparent:",
                                                error,
                                            ),
                                        );

                                    scene.add(item);
                                };
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".glb")
                        ) {
                            glbFiles.push(entry);
                            entry.file((file) => {
                                objectCount++;
                                const tempCount = objectCount;
                                const reader = new FileReader();
                                reader.readAsArrayBuffer(file);
                                reader.onload = (event) => {
                                    const arrayBuffer = event.target.result;
                                    const loader = new GLTFLoader();
                                    const item = loader.parse(arrayBuffer, "");
                                    item.name = entry.name;
                                    simplifiedNamesId.push({
                                        uuid: item.uuid,
                                        simplifiedName: entry.name.replace(
                                            /\D/g,
                                            "",
                                        ),
                                    });
                                    console.log("item name" + item.name);
                                    glbFiles.push(item.name);
                                    scene.add(item);
                                };
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".csv")
                        ) {
                            entry.file((file) => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    processCSVData(e.target.result, file.name);
                                };
                                reader.readAsText(file);
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".jpg")
                        ) {
                            entry.file((file) => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    processVRImage(e.target.result, file.name);
                                };
                                reader.readAsDataURL(file);
                            });
                        } else if (entry.isDirectory) {
                            const subReader = entry.createReader();
                            traverseDirectoryAsync(subReader); // Recursive call
                        }
                    });
                    resolve(entries);
                },
                (error) => reject(error),
            );
        });
    }

    // Function to export a Three.js object to a GLB file
    function exportToGLB(object, filename) {
        const exporter = new GLTFExporter();
        exporter.parse(
            object,
            (result) => {
                let blob;
                if (result instanceof ArrayBuffer) {
                    blob = new Blob([result], {
                        type: "application/octet-stream",
                    });
                } else if (typeof result === "object") {
                    blob = new Blob([JSON.stringify(result)], {
                        type: "application/json",
                    });
                } else {
                    console.error("Unexpected result type:", result);
                    return;
                }

                saveBlob(blob, filename);
            },
            (error) => {
                console.error("An error occurred during the GLB export", error);
            },
            { binary: true }, // Options object with binary set to true
        );
    }

    // Function to save the Blob as a file
    function saveBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.style.display = "none";
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();

        // Clean up
        setTimeout(() => {
            URL.revokeObjectURL(url);
            document.body.removeChild(link);
        }, 100);
    }

    // Function to export all FBX files in fbxFiles array
    function exportAllFBXFilesToGLB() {
        const exportEntireScene = document.getElementById(
            "export-all-scene-checkbox",
        ).checked;
        if (exportEntireScene) {
            // Export the entire scene
            exportToGLB(scene, "scene.glb");
        } else {
            // Export only the FBX models
            fbxFiles.forEach((fbxFile) => {
                const object = scene.getObjectByName(fbxFile.fileName);
                if (object) {
                    const filename = `${fbxFile.fileName.split(".")[0]}.glb`;
                    exportToGLB(object, filename);
                }
            });
        }
    }

    // Add an event listener to the export button
    const exportButton = document.getElementById("export-all-fbx");
    exportButton.addEventListener("click", exportAllFBXFilesToGLB);

    // Function to export CSV with updated rotations
    function exportCSVWithRotations() {
        if (!m_Group || !m_Group.children || m_Group.children.length === 0) {
            alert("error", "Please import a CSV file first to export rotations");
            return;
        }

        let csvContent = ""; // No header

        m_Group.children.forEach((child) => {
            if (child instanceof THREE.Mesh && child.cameraPos) {
                // Get world position
                const worldPosition = new THREE.Vector3();
                child.getWorldPosition(worldPosition);

                // Format: name,x,-z,-y,0,0,rotation_y_in_degrees
                csvContent += `${child.name},${worldPosition.x.toFixed(6)},${(-worldPosition.z).toFixed(6)},${(-worldPosition.y).toFixed(6)},0,0,${THREE.MathUtils.radToDeg(child.rotation.y).toFixed(6)}\n`;
            }
        });

        // Create and download the CSV file
        const blob = new Blob([csvContent], { type: "text/csv" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${m_Group.name.split(".")[0]}_with_rotations.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        alert("notify", `Exported ${m_Group.children.length} cones with updated rotations`);
    }

    // Add event listener for CSV export button
    const exportCsvButton = document.getElementById("export-csv-rotations");
    if (exportCsvButton) {
        exportCsvButton.addEventListener("click", exportCSVWithRotations);
    }

    const logScene = document.getElementById("log-scene");
    logScene.addEventListener("click", (e) => {
        console.log(scene);
    });
    const dropZone = document.getElementById("drop-zone");
    dropZone.addEventListener("drop", handleDrop);
    document.body.addEventListener("dragover", (e) => {
        event.preventDefault();
    });

    function createCone(name, position, rotation) {
        const geometry = new THREE.ConeGeometry(20, 40, 32); // Cone with radius 0.5 and height 1
        const material = new THREE.MeshBasicMaterial({ 
            color: 0xff0000,
            depthTest: true,
            depthWrite: true,
            transparent: false
        }); // Red color, change as needed
        const cone = new THREE.Mesh(geometry, material);
        const dir = new THREE.Vector3(Math.sin(THREE.MathUtils.degToRad(rotation.z)), 0, Math.cos(THREE.MathUtils.degToRad(rotation.z)));
        //normalize the direction vector (convert to vector of length 1)
        dir.normalize();

        // const origin = new THREE.Vector3( position.x, position.y, position.z);
        // const length = 15;
        // const hex = 0xff0000;
        // const arrow = new THREE.ArrowHelper( dir, origin, length, hex, 5, 8);
        // arrow.scale.set(3,3,3)

        // Set position
        cone.position.set(0, 0, 0);

        // Set rotation using Euler angles, converting degrees to radians
        cone.rotation.set(
            THREE.MathUtils.degToRad(0),
            THREE.MathUtils.degToRad(90),
            THREE.MathUtils.degToRad(90),
        );
        cone.updateMatrix();
        cone.geometry.applyMatrix4(cone.matrix); //to bake rotation to cone
        cone.position.set(position.x, position.y, position.z);
        cone.rotation.set(0, THREE.MathUtils.degToRad(rotation.z), 0);
        cone.scale.set(1, 1, 1);
        cone.updateMatrix();
        console.log(cone.rotation);
        cone.renderOrder = 1000; // Higher render order to render on top
        cone.name = name;
        markers.push(cone);
        return cone;
    }
    var showMarkerNames = false;

    // function createCone(name, position, rotation) {
    //     const loader = new GLTFLoader();
    //     const camera = loader.load("./camera.glb", (e) => {
    //         const model = e.scene

    //         model.position.set(position.x, position.y, position.z)
    //         model.renderOrder = 0;
    //         model.name = name;
    //     })
    //     return camera
    // }

    // Create a label div for each marker
    function createLabels() {
        document.getElementById("marker-label-container").innerHTML = "";
        var copiedMarkers;
        copiedMarkers = markers.filter((e) => e.visible);
        copiedMarkers.forEach((marker) => {
            const labelDiv = document.createElement("div");
            labelDiv.style.backgroundColor = "#444444";
            labelDiv.style.padding = "2px 5px";
            labelDiv.style.borderRadius = "6px";
            labelDiv.className = "marker-label";
            labelDiv.innerText = marker.name;

            // Style the label
            labelDiv.style.position = "absolute";
            labelDiv.style.color = "white";
            labelDiv.style.fontSize = "10px";

            document
                .getElementById("marker-label-container")
                .appendChild(labelDiv);
            marker.userData.label = labelDiv; // Store the label in userData
        });
    }

    // Function to update label positions on the screen
    function updateLabelPositions() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        const widthHalf = width / 2;
        const heightHalf = height / 2;

        const distances = markers.map((marker) =>
            camera.position.distanceTo(marker.position),
        );
        const minDistance = Math.min(...distances);
        const maxDistance = Math.max(...distances);
        const distanceRange = maxDistance - minDistance || 1;

        // Sort markers by distance from the camera (closest markers first)
        const sortedMarkers = markers
            .sort((a, b) => {
                const distanceA = camera.position.distanceTo(a.position);
                const distanceB = camera.position.distanceTo(b.position);
                return distanceA - distanceB;
            })
            .filter((e) => e.visible);

        sortedMarkers.map((marker, i) => {
            // console.log(marker)
            const labelDiv = marker.userData.label;
            if (!labelDiv) return;

            // Get the 3D position of the marker and project it to 2D
            const vector = new THREE.Vector3();
            vector.setFromMatrixPosition(marker.matrixWorld).project(camera);

            // Convert to 2D screen space
            const x = vector.x * widthHalf + widthHalf;
            const y = -(vector.y * heightHalf) + heightHalf;

            // Update label position and visibility based on camera view
            labelDiv.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
            labelDiv.style.display =
                vector.z > -1 && vector.z < 1 ? "block" : "none";

            // Calculate distance and adjust opacity based on the relative distance
            const distance = camera.position.distanceTo(marker.position);
            const normalizedDistance =
                (distance - minDistance + 1) / distanceRange;
            const minOpacity = 0.6;
            labelDiv.style.opacity =
                minOpacity +
                (1 - minOpacity) *
                    (1 - normalizedDistance) ** (maxDistance / minDistance);
            labelDiv.style.zIndex = 1000 - Math.floor(distance); // Higher z-index for closer markers
        });
    }

    function createCSVFromSphereGroups(csvGroups) {
        let csvContent = ""; // CSV header

        csvGroups.forEach((group) => {
            group.children.forEach((child) => {
                if (child instanceof THREE.Mesh) {
                    // Ensure child is a mesh (sphere)
                    const name = child.name;
                    const worldPosition = new THREE.Vector3();
                    const worldQuaternion = new THREE.Quaternion();
                    const worldEuler = new THREE.Euler();
                    const position = child.getWorldPosition(worldPosition);
                    const rotation = child.getWorldQuaternion(worldQuaternion);
                    worldEuler.setFromQuaternion(worldQuaternion);

                    csvContent += `${name},${worldPosition.x},${-worldPosition.y},${worldPosition.z},${worldEuler.x},${worldEuler.y},${worldEuler.z}\n`;
                }
            });

            // Create a downloadable CSV file
            const blob = new Blob([csvContent], { type: "text/csv" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${group.name.split(".")[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        });
    }

    //Calculate center of all CSV points
    function calculateGroupCenter(group) {
        const positions = group.children.map((child) => child.position);
        const totalPositions = positions.length;

        if (totalPositions === 0) return null;

        const sum = positions.reduce(
            (acc, pos) => {
                acc.x += pos.x;
                acc.y += pos.y;
                acc.z += pos.z;
                return acc;
            },
            { x: 0, y: 0, z: 0 },
        );

        return {
            x: sum.x / totalPositions,
            y: sum.y / totalPositions,
            z: sum.z / totalPositions,
        };
    }

    function translateGroupToOrigin(group) {
        const center = calculateGroupCenter(group);
        group.initPosition = new THREE.Vector3(-center.x, -center.y, -center.z);
        if (!center) return;

        group.position.set(-center.x, -center.y, -center.z);
    }

    function alert(type, message) {
        var el = document.createElement("div");
        el.style.background = "#ffffff88";
        el.style.padding = "20px";
        el.style.borderRadius = "15px";
        el.classList.add("notification");
        var text = document.createElement("p");
        if (type == "error") {
            el.classList.add("alert-error");
        } else if (type == "notify") {
            el.classList.add("alert-notify");
        }
        text.innerText = message;
        text.style.margin = "0px";
        el.appendChild(text);

        document.getElementById("notification-panel").appendChild(el);

        setTimeout((e) => {
            el.remove();
        }, 2000);
    }

    // Function to scale each point relative to the center point of the group
    function scaleGroupRelativeToCenter(group, scaleFactor) {
        m_Group.scale.set(scaleFactor, scaleFactor, scaleFactor);
        if (!m_Group.initPosition) {
            m_Group.initPosition = new THREE.Vector3(
                m_Group.position.x,
                m_Group.position.y,
                m_Group.position.z,
            );
        }
        m_Group.position.set(
            m_Group.initPosition.x * scaleFactor,
            m_Group.initPosition.y * 1,
            m_Group.initPosition.z * scaleFactor,
        );
        var center = group.position;
        group.children.forEach((child) => {
            child.scale.set(1 / scaleFactor, 1 / scaleFactor, 1 / scaleFactor);
        });
    }

    function convertFBXtoGLB(position, rotation) {
        // Assuming FBX is Y-up and GLB is Z-up
        // Convert position
        const convertedPosition = {
            x: position.x,
            y: position.z,
            z: -position.y,
        };

        // Convert rotation (assuming Euler angles)
        const convertedRotation = {
            x: rotation.x,
            y: rotation.z,
            z: -rotation.y,
        };

        return { position: convertedPosition, rotation: convertedRotation };
    }

    // Function to process CSV data and create spheres
    function processCSVData(csvText, name?) {
        const lines = csvText.split("\n"); // Split CSV text into lines
        // Skip the first line if it contains headers, and process the rest

        const group = new THREE.Group();

        for (let i = 0; i < lines.length; i++) {
            const row = lines[i].split(",");
            if (row.length >= 7) {
                const name = row[0];
                const position = {
                    x: parseFloat(row[1]),
                    y: parseFloat(row[3]),
                    z: -parseFloat(row[2]),
                };
                const rotation = {
                    x: parseFloat(row[4]),
                    y: parseFloat(row[5]),
                    z: parseFloat(row[6]),
                };
                const floor = name.includes("_") ? name.split("_")[0] : name; //Get Floor Number
                const arrow = createCone(name, position, rotation);
                arrow.cameraPos = true;
                arrow.floor = floor;

                globalFloors.push({ floor: floor, arrow: arrow }); //Push obj to globalFloors

                group.add(arrow);
                // console.log(arrow);
            }

            if (name) {
                group.name = name;
                group.userData.simplifiedName = name.replace(/\D/g, "");
            }
            scene.add(group);
            m_Group = group;
        }
        createLabels();
        csvGroups.push(group);
        handleFloors();

        //Update main object references
        if (simplifiedNamesId.length > 0) {
            simplifiedNamesId.forEach((e) => {
                if (e.simplifiedName == name.replace(/\D/g, "")) {
                    e.csvObject = group.uuid;
                } else {
                    group.remove();
                }
            });
        }
        const csvUploadEvent = new CustomEvent("file-upload-csv", {
            detail: {
                simplifiedName: group.userData.simplifiedName,
                name: group.name,
            },
        });
        window.dispatchEvent(csvUploadEvent);
        updateOutliner();
        
        // Update CSV points list for navigation
        updateCsvPointsList();
        updateNavigationDisplay();
    }

    function processVRImage(data, name?) {
        const thisImage = { name: name, image: data };
        imageArray.push(thisImage);
    }

    document.getElementById("ui-area").addEventListener("click", (e) => {
        if (!m_Group) {
            alert(
                "error",
                "Please Import some CSV files to use these features",
            );
        }
    });

    document.getElementById("x-flip").addEventListener("click", (e) => {
        m_Group.rotateOnWorldAxis(
            new THREE.Vector3(1, 0, 0),
            THREE.MathUtils.degToRad(180),
        );
    });

    document.getElementById("y-flip").addEventListener("click", (e) => {
        m_Group.rotateOnWorldAxis(
            new THREE.Vector3(0, 1, 0),
            THREE.MathUtils.degToRad(180),
        );
    });

    document.getElementById("z-flip").addEventListener("click", (e) => {
        m_Group.rotateOnWorldAxis(
            new THREE.Vector3(0, 0, 1),
            THREE.MathUtils.degToRad(180),
        );
    });

    document.getElementById("y-up").addEventListener("click", (e) => {
        m_Group.children.forEach((e) => {
            const initYPos = e.position.y;
            e.position.y = -initYPos;
        });
    });

    document.getElementById("center-csv").addEventListener("change", (e) => {
        if (e.target.checked) {
            calculateGroupCenter(m_Group);
            translateGroupToOrigin(m_Group);
            alert("notify", "csv-centered");
        } else {
            m_Group.position.set(0, 0, 0);
            alert("notify", "csv-centered");
        }
    });

    document.getElementById("show-labels").addEventListener("change", (e) => {
        createLabels();
        if (e.target.checked) {
            document.getElementById("marker-label-container").style.display =
                "block";
        } else {
            document.getElementById("marker-label-container").style.display =
                "none";
        }
    });

    document
        .getElementById("show-face-orientation")
        .addEventListener("change", (e) => {
            if (e.target.checked) {
                console.log(glbFiles);
                console.log(markers);
                scene.traverse(function (child) {
                    console.log(child.name);
                    if (
                        child.isMesh &&
                        !(child.userData && child.userData.label) &&
                        !child.name.toLowerCase().includes("sphere")
                    ) {
                        child.material = new THREE.ShaderMaterial({
                            vertexShader: `
                                varying vec3 vNormal;
                                void main() {
                                    vNormal = normalize(normalMatrix * normal);
                                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                                }`,
                            fragmentShader: `
                                varying vec3 vNormal;
                                void main() {
                                    float facingRatio = dot(vNormal, vec3(0.0, 0.0, 1.0));
                                    float blueIntensity = 0.5 + 0.5 * facingRatio; // Blue becomes more intense as the normal faces the viewer
                                    float redIntensity = 0.5 - 0.5 * facingRatio; // Red becomes more intense as the normal faces away
                                    gl_FragColor = vec4(redIntensity, 0.0, blueIntensity, 0.5); // Semi-transparent
                                }`,
                            side: THREE.FrontSide,
                            transparent: true,
                        });
                    }
                });
            } else {
                scene.traverse((child) => {
                    if (
                        child.isMesh &&
                        !(child.userData && child.userData.label) &&
                        !child.name.toLowerCase().includes("sphere")
                    ) {
                        child.material = material;
                        child.material.wireframe = true; // Ensure wireframe is initially false
                        originalWireframeMeshes.push(child);
                    }
                });
            }
        });

    // Updated buildTree with collapsible parents, auto-collapse for >6 children, and dblclick to toggle visibility
    function buildTree(object) {
        // Create <li> for this node
        const li = document.createElement("li");
        li.className =
            "my-[3px] text-2xs hover:bg-gray-300 cursor-pointer flex flex-col";

        // Container holds toggle (if any), name, and color picker
        const container = document.createElement("div");
        container.className = "flex items-center gap-2";

        // Initialize enabled state if not already
        if (object.userData.isEnabled === undefined) {
            object.userData.isEnabled = true;
        }

        // Double-click to toggle this object and its children
        container.addEventListener("dblclick", (e) => {
            e.stopPropagation();
            const newState = !object.userData.isEnabled;
            toggleVisibility(object, newState);
            styleSubtree(li, newState);
            // Clear or refresh HTML labels overlay when CSV cones visibility changes
            if (typeof createLabels === "function") {
                createLabels();
            }
        });

        // Create toggle button for nodes with children
        const hasChildren = object.children && object.children.length > 0;
        let toggle;
        if (hasChildren) {
            toggle = document.createElement("button");
            // Start collapsed if >6 children, otherwise expanded
            const startCollapsed = object.children.length > 6;
            toggle.textContent = startCollapsed ? "+" : "\u2212";
            toggle.className =
                "toggle-btn w-4 h-4 p-0 m-0 border-none bg-transparent";
            toggle.style.cursor = "pointer";
            container.appendChild(toggle);
        }

        // Name label
        const nameSpan = document.createElement("span");
        nameSpan.textContent = object.name || object.type || "Unnamed";
        container.appendChild(nameSpan);

        // Add rotation input for cones (camera positions)
        if (object.cameraPos) {
            const rotationContainer = document.createElement("div");
            rotationContainer.className = "flex items-center gap-1 ml-2";
            
            const rotationLabel = document.createElement("span");
            rotationLabel.textContent = "Z:";
            rotationLabel.className = "text-xs text-gray-600";
            rotationContainer.appendChild(rotationLabel);
            
            const rotationInput = document.createElement("input");
            rotationInput.type = "number";
            rotationInput.step = "0.1";
            rotationInput.className = "w-16 h-4 text-xs border border-gray-300 rounded px-1";
            rotationInput.value = THREE.MathUtils.radToDeg(object.rotation.y).toFixed(1);
            
            // Update cone rotation when input changes
            rotationInput.addEventListener("input", (e) => {
                const newRotation = THREE.MathUtils.degToRad(parseFloat(e.target.value));
                object.rotation.y = newRotation;
                
                // Update the cone's visual representation
                object.updateMatrix();
                object.geometry.applyMatrix4(object.matrix);
                object.rotation.set(0, newRotation, 0);
                object.updateMatrix();
                
                // Update labels if they exist
                if (typeof createLabels === "function") {
                    createLabels();
                }
            });
            
            // Update input when cone rotation changes externally
            const updateRotationInput = () => {
                rotationInput.value = THREE.MathUtils.radToDeg(object.rotation.y).toFixed(1);
            };
            
            // Store the update function for external use
            object.userData.updateRotationInput = updateRotationInput;
            
            rotationContainer.appendChild(rotationInput);
            
            // Add offset field
            const offsetLabel = document.createElement("span");
            offsetLabel.textContent = "Offset:";
            offsetLabel.className = "text-xs text-gray-600 ml-2";
            rotationContainer.appendChild(offsetLabel);
            
            const offsetInput = document.createElement("input");
            offsetInput.type = "number";
            offsetInput.step = "0.1";
            offsetInput.className = "w-16 h-4 text-xs border border-gray-300 rounded px-1";
            offsetInput.value = "0.0";
            
            // Initialize offset if not exists
            if (object.userData.originalRotation === undefined) {
                object.userData.originalRotation = object.rotation.y;
                object.userData.offset = 0;
            }
            
            // Update offset when input changes
            offsetInput.addEventListener("input", (e) => {
                const offset = THREE.MathUtils.degToRad(parseFloat(e.target.value));
                object.userData.offset = offset;
                
                // Calculate final rotation: original + offset
                const finalRotation = object.userData.originalRotation + offset;
                object.rotation.y = finalRotation;
                
                // Update the cone's visual representation
                object.updateMatrix();
                object.geometry.applyMatrix4(object.matrix);
                object.rotation.set(0, finalRotation, 0);
                object.updateMatrix();
                
                // Update the main rotation input to show the final value
                if (object.userData.updateRotationInput) {
                    object.userData.updateRotationInput();
                }
                
                // Update labels if they exist
                if (typeof createLabels === "function") {
                    createLabels();
                }
            });
            
            rotationContainer.appendChild(offsetInput);
            container.appendChild(rotationContainer);
        }

        // Color picker
        const colorPicker = document.createElement("input");
        colorPicker.type = "color";
        colorPicker.style.cursor = "pointer";
        colorPicker.value = "#ff0000";
        colorPicker.className = "w-6 h-6 p-0 m-0 border-none";
        object.userData.colorPicker = colorPicker;
        colorPicker.addEventListener("input", (e) => {
            e.stopPropagation();
            updateObjectColor(object, e.target.value);
        });
        container.appendChild(colorPicker);

        li.appendChild(container);

        // Build children list
        if (hasChildren) {
            const ul = document.createElement("ul");
            ul.className = "ml-4 list-disc";
            // Auto-collapse large lists
            const isCollapsed = object.children.length > 6;
            ul.style.display = isCollapsed ? "none" : "block";

            // Recursively add children
            object.children.forEach((child) => {
                const childLi = buildTree(child);
                ul.appendChild(childLi);
            });
            li.appendChild(ul);

            // Toggle expand/collapse
            toggle.addEventListener("click", (e) => {
                e.stopPropagation();
                const hidden = ul.style.display === "none";
                ul.style.display = hidden ? "block" : "none";
                toggle.textContent = hidden ? "\u2212" : "+";
            });
        } else {
            // Leaf: make draggable
            container.draggable = true;
            container.addEventListener("dragstart", (e) => {
                e.stopPropagation();
                e.dataTransfer.setData("text/plain", object.id);
            });
        }


            if ( (object.name || '').toLowerCase().endsWith('.glb') ) {
                container.addEventListener('mouseenter', ev => {
                    hoverTimerId = setTimeout(() => {
                    showTooltip(ev.clientX, ev.clientY, "Click to refocus");
                    }, 200);      // 3 s
                });

                container.addEventListener('mousemove', ev => {
                    if (tooltip.style.opacity === '1') showTooltip(ev.clientX, ev.clientY, "Click to refocus");
                });

                container.addEventListener('mouseleave', hideTooltip);
                container.addEventListener('click', hideTooltip); // user followed hint
            }

        // Context menu on CSV files: export 360 for the whole group
        if (object.name.toLowerCase().endsWith(".csv")) {
            container.addEventListener("contextmenu", (e) => {
                e.preventDefault();
                if (
                    confirm(`Export all 360° images for group ${object.name}?`)
                ) {
                    // Determine group key
                    const key = getGroupId(object.name);
                    // Hide everything
                    scene.children.forEach((o) => (o.visible = false));
                    // Show only objects in this group (matching key)
                    scene.children.forEach((o) => {
                        const k = getGroupId(o.name || "");
                        if (k === key) o.visible = true;
                    });
                    // Also show cones under the CSV group
                    const csvGroup = scene.getObjectByName(object.name);
                    if (csvGroup) csvGroup.visible = true;
                    // Trigger 360 export
                    exportAll360ForGroup(object);
                }
            });
        }

        // Apply initial disabled style if needed
        styleSubtree(li, object.userData.isEnabled);
        li.setAttribute("data-object-id", object.id);
        return li;
    }

    // helper to save the current renderer canvas as a PNG
    function saveDebugImage(label) {
        const link = document.createElement("a");
        link.href = renderer.domElement.toDataURL("image/png");
        link.download = `${label}.png`;
        link.click();
    }

async function render360SnapshotForCone(cone, allCones = markers) {
    // 1) backup renderer state
    const origSize       = renderer.getSize(new THREE.Vector2());
    const origDPR        = renderer.getPixelRatio();
    const origClearColor = renderer.getClearColor(new THREE.Color()).getHex();
    const origClearAlpha = renderer.getClearAlpha();
    const origAutoClear  = renderer.autoClear;



    // 2) add a light at every cone in the group
    const lights = markers.map((mark) => {
        const light = new THREE.PointLight(0xffffff, 10, 0, 0.8);
        light.position.copy(mark.position);
        scene.add(light);
        return light;
    });

    // Hide everything but the cones
    // scene.children.forEach(o => o.visible = false);
    // markers.forEach(m => {
    //   m.visible = true;
    //   // keep their original materials
    // });
    cone.visible = true

    markers.forEach((m) => (m.visible = false));
    const whiteMat = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        shininess: 30,
    });
    whiteMat.dithering = true;
    const prevOverride = scene.overrideMaterial;
    scene.overrideMaterial = whiteMat;

    // Capture cube map
    cubeCamera.position.copy(cone.position);
    cubeCamera.quaternion.copy(cone.quaternion);
    cubeCamera.quaternion.multiply(
      new THREE.Quaternion().setFromAxisAngle(
        new THREE.Vector3(0,1,0),
        Math.PI/2
      )
    );
    renderer.autoClear = true
    cubeCamera.update(renderer, scene);

    // Restore material and visibility
    scene.overrideMaterial = prevOverride;
    markers.forEach((m) => (m.visible = true));

    // 6) equirectangular pass (optimized for performance)
    // Equirectangular pass
    renderer.setPixelRatio(1);
    renderer.setSize(1024, 512);
    renderer.setRenderTarget(null);
    renderer.autoClear = true;
    renderer.setClearColor(0x000000, 1);
    renderer.clear(true, true, true);
    renderer.render(eqScene, eqCam);

    // Source canvas
    const srcCanvas = renderer.domElement;

    const dataURL = srcCanvas.toDataURL("image/jpeg", 0.6); // Reduced quality for better performance

    // 8) re-enable wireframes
    originalWireframeMeshes.forEach(m => {
      m.material.wireframe = true;
      m.material.needsUpdate = true;
    });

    lights.forEach((l) => scene.remove(l));

    // 7) restore renderer state
    renderer.setPixelRatio(origDPR);
    renderer.setSize(origSize.x, origSize.y, true);
    renderer.setClearColor(origClearColor, origClearAlpha);
    renderer.autoClear = origAutoClear;

    // 9) return a JPEG data-URL
    return dataURL;
}

    /**
     * exportAll360ForGroup: exports one group's CSV+cones into a zip folder (or downloads directly)
     * @param {Object3D} groupObj - the CSV group object
     * @param {JSZip} [zipFolder] - optional JSZip folder for multi-group export
     */
    async function exportAll360ForGroup(groupObj, zipFolder) {
        const isRootCall = !zipFolder;
        // Capture original renderer state
        const origSize = renderer.getSize(new THREE.Vector2());
        const origDPR = renderer.getPixelRatio();
        const origClearColor = renderer
            .getClearColor(new THREE.Color())
            .getHex();
        const origClearAlpha = renderer.getClearAlpha();
        const origAutoClear = renderer.autoClear;
        const origPhysLights = renderer.physicallyCorrectLights;
        const origToneMapping = renderer.toneMapping;
        const origToneExp = renderer.toneMappingExposure;
        const origDither = renderer.dither;

        // Prepare ZIP target
        const zip = zipFolder || new JSZip();

        // Derive prefix from CSV name
        const base = groupObj.name.toLowerCase().replace(/\.csv$/, "");
        const prefix = base.split("_").slice(-5).join("_");
        console.log(
            `Starting export for group: ${groupObj.name}, prefix: ${prefix}`,
        );

        // Find cones
        const cones = groupObj.children.filter((ch) => ch.cameraPos);
        console.log(`Found ${cones.length} cones for group ${prefix}`);

        // Add lights once
        const lights = cones.map((cone) => {
            const light = new THREE.PointLight(0xffffff, 20, 0, 0.8);
            light.position.copy(cone.position);
            scene.add(light);
            return light;
        });

        // Helper to yield control
        const tick = () => new Promise((r) => setTimeout(r, 0));

        // Single loop: render once per cone, then zip original + flipped
        for (let i = 0; i < cones.length; i++) {
            const cone = cones[i];
            const instanceName = `${prefix}_${cone.name}`.toLowerCase();
            console.log(
                `▶ [${groupObj.name}] Processing cone ${i + 1}/${cones.length}: ${instanceName}`,
            );

            // Hide cones and override material
            markers.forEach((m) => (m.visible = false));
            const whiteMat = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                shininess: 30,
            });
            whiteMat.dithering = true;
            const prevOverride = scene.overrideMaterial;
            scene.overrideMaterial = whiteMat;

            // Capture cube map
            cubeCamera.position.copy(cone.position);
            console.log(cone.quaternion)
            cubeCamera.quaternion.copy(cone.quaternion);
               // add a 90° clockwise offset about world-Y
               cubeCamera.quaternion.multiply(
                 new THREE.Quaternion().setFromAxisAngle(
                   new THREE.Vector3(0,1,0),
                   -Math.PI/2
                 )
               );
            cubeCamera.update(renderer, scene);

            // Restore material and visibility
            scene.overrideMaterial = prevOverride;
            markers.forEach((m) => (m.visible = true));

            // Equirectangular pass
            renderer.setPixelRatio(1);
            renderer.setSize(2048, 1024);
            renderer.setRenderTarget(null);
            renderer.autoClear = true;
            renderer.setClearColor(0x000000, 1);
            renderer.clear(true, true, true);
            renderer.render(eqScene, eqCam);

            // Source canvas
            const srcCanvas = renderer.domElement;

            // ZIP original
            console.log(`  Capturing original: ${instanceName}.jpg`);
            const origDataURL = srcCanvas.toDataURL("image/jpeg", 0.6); // Reduced quality for better performance
            zip.file(`${instanceName}.jpg`, origDataURL.split(",")[1], {
                base64: true,
            });

            // Prepare flipped name
            const flipParts = prefix.split("_");
            if (flipParts.length >= 3) flipParts[2] += "f";
            const flippedName =
                `${flipParts.join("_")}_${cone.name}`.toLowerCase();

            // ZIP flipped
            console.log(`  Capturing flipped: ${flippedName}.jpg`);
            const off = document.createElement("canvas");
            off.width = srcCanvas.width;
            off.height = srcCanvas.height;
            const ctx = off.getContext("2d");
            ctx.translate(off.width, 0);
            ctx.scale(-1, 1);
            ctx.drawImage(srcCanvas, 0, 0);
            const flipDataURL = off.toDataURL("image/jpeg", 0.8);
            zip.file(`${flippedName}.jpg`, flipDataURL.split(",")[1], {
                base64: true,
            });

            // Yield periodically
            if (i % 5 === 4) await tick();
        }

        // Duplicate s1→s2
        Object.keys(zip.files).forEach((fn) => {
            if (/s1/i.test(fn)) {
                const newName = fn.replace(/s1/gi, "s2");
                console.log(`↪ Duplicating ${fn} to ${newName}`);
                const data = zip.files[fn]._data;
                zip.file(newName, data, { base64: true });
            }
        });

        // Cleanup lights
        lights.forEach((l) => scene.remove(l));
        console.log(`Completed export for group ${prefix}`);

        // If root call, finalize and download ZIP
        if (isRootCall) {
            console.log("Generating ZIP...");
            const blob = await zip.generateAsync(
                { type: "blob", streamFiles: true },
                (meta) => {
                    console.log(`  ZIP progress: ${meta.percent.toFixed(1)}%`);
                },
            );
            const a = document.createElement("a");
            a.href = URL.createObjectURL(blob);
            a.download = `${base}-360s-batches.zip`;
            a.click();
            console.log("Download triggered");
        }

        // Restore renderer state
        renderer.setPixelRatio(origDPR);
        renderer.setSize(origSize.x, origSize.y);
        renderer.setClearColor(origClearColor, origClearAlpha);
        renderer.autoClear = origAutoClear;
        renderer.physicallyCorrectLights = origPhysLights;
        renderer.toneMapping = origToneMapping;
        renderer.toneMappingExposure = origToneExp;
        renderer.dither = origDither;

        // Re-enable wireframes
        scene.traverse((o) => {
            if (o.isMesh && o.material) {
                const mats = Array.isArray(o.material)
                    ? o.material
                    : [o.material];
                mats.forEach((m) => {
                    m.wireframe = true;
                    m.needsUpdate = true;
                });
            }
        });
        console.log("Renderer and wireframes restored.");
    }

    // Recursively toggle visibility in the Three.js scene
    function toggleVisibility(object, visible) {
        object.visible = visible;
        object.userData.isEnabled = visible;
        if (object.children) {
            object.children.forEach((child) =>
                toggleVisibility(child, visible),
            );
        }
    }

    // Apply or remove visual "disabled" style on a <li> subtree
    function styleSubtree(liElement, enabled) {
        const applyStyle = (el) => {
            el.style.opacity = enabled ? "1" : "0.5";
            el.style.textDecoration = enabled ? "" : "line-through";
        };
        applyStyle(liElement.querySelector("div"));
        // Also style all descendant <div> containers
        liElement
            .querySelectorAll("li > div")
            .forEach((div) => applyStyle(div));
    }

    function updateObjectColor(object, color) {
        // Update material color if this object is a Mesh.
        if (object.isMesh && object.material && object.material.color) {
            object.material.color.set(color);
            object.material.needsUpdate = true;
        }
        // If a color picker was stored on this object, update it.
        if (object.userData && object.userData.colorPicker) {
            object.userData.colorPicker.value = color;
        }
        // Recursively update all children.
        if (object.children && object.children.length > 0) {
            object.children.forEach((child) => updateObjectColor(child, color));
        }
    }

    // Utility to extract a grouping key from object names (segments 3–6)
    function getGroupId(name) {
        const segments = name.split("_");
        if (segments.length >= 6) {
            // take segments[2], [3], [4], [5]
            return segments.slice(2, 6).join("_");
        }
        return null;
    }

    const tooltip = document.getElementById('hover-tooltip');
    let  hoverTimerId  = null;
    let hoverObject  = null; 

    /**
     * Show tooltip next to the mouse.
     * @param {number}  x   screen-space X
     * @param {number}  y   screen-space Y
     * @param {string=} msg text to display (defaults to previous / "Double-click to refocus")
     */
    function showTooltip(x, y, msg) {
        if (msg !== undefined) tooltip.textContent = msg;
        tooltip.style.left  = (x + 14) + 'px';
        tooltip.style.top   = (y + 14) + 'px';
        tooltip.style.opacity = 1;
    }
    /** hide tooltip & cancel timer */
    function hideTooltip() {
        clearTimeout(hoverTimerId);
        hoverTimerId = null;
        tooltip.style.opacity = 0;
    }

    // Updated updateOutliner with grouping logic
    function updateOutliner() {
        const outliner = document.getElementById("outliner");
        if (!outliner) return;
        outliner.innerHTML = "";

        // 2) Outliner rows already have the object id stored:
        outliner.addEventListener("click", (e) => {
        const target = e.target as HTMLElement;
        const li = target.closest("li[data-object-id]") as HTMLElement;
        if (!li) return;
        const obj = scene.getObjectById(+li.dataset.objectId);
        if (obj)  fitCameraToObject(camera, orbitalControls, obj);
        });

        // -- build map of groups --
        const groupsMap = new Map();
        const standalone = [];
        scene.children.forEach((obj) => {
            const nm = obj.name || "";
            const lo = nm.toLowerCase();
            const key = getGroupId(nm);
            if ((lo.endsWith(".csv") || lo.endsWith(".glb")) && key) {
                if (!groupsMap.has(key)) groupsMap.set(key, []);
                groupsMap.get(key).push(obj);
            } else {
                standalone.push(obj);
            }
        });

        // -- status line --
        let statusEl = null;
        if (groupsMap.size > 1) {
            statusEl = document.createElement("div");
            statusEl.className = "mb-1 text-xs text-gray-700";
            statusEl.textContent = "Ready to export groups…";
            outliner.appendChild(statusEl);
        }

        // -- "Export All" button --
        if (groupsMap.size > 1) {
            // Export All Groups button
            const btn = document.createElement("button");
            btn.textContent = "Export All Groups 360°";
            btn.className = "mb-2 p-1 bg-blue-500 text-white text-xs rounded";
            btn.addEventListener('click', async () => {
                btn.disabled = true;
                statusEl.textContent = 'Starting export of all groups…';
                await new Promise(r=>setTimeout(r,0));

                // 1) Single master zip
                const rootZip = new JSZip();
                let idx = 1;
                const total = groupsMap.size;

                // 2) Loop over each group once
                for (const objs of groupsMap.values()) {
                    const csvObj = objs.find(o => o.name.toLowerCase().endsWith('.csv'));
                    if (!csvObj) continue;

                    const key = getGroupId(csvObj.name);
                    statusEl.textContent = `Processing group "${key}" (${idx}/${total})…`;
                    console.log(`→ [${idx}/${total}] exporting group ${key}`);
                    await new Promise(r=>setTimeout(r,0));

                    // 3) Create a sub-folder in the master zip
                    const folder = rootZip.folder(key);
                    // This writes *only* this group's panoramas into that folder
                    await exportAll360ForGroup(csvObj, folder);

                    idx++;
                }

                // 4) Finalize and download
                statusEl.textContent = 'Finalizing ZIP…';
                console.log('All groups done, generating combined ZIP');
                const blob = await rootZip.generateAsync({
                    type: 'blob',
                    streamFiles: true,
                }, meta => console.log(`ZIP ${meta.percent.toFixed(1)}%`));

                const a = document.createElement('a');
                a.href     = URL.createObjectURL(blob);
                a.download = 'all-groups-360s.zip';
                a.click();
                console.log('Combined ZIP download triggered');

                statusEl.textContent = '✅ All groups exported!';
                btn.disabled = false;
            });

            outliner.appendChild(btn);
        }

        // -- now render the tree as before --
        const ul = document.createElement("ul");
        // Build grouped nodes
        groupsMap.forEach((objs, key) => {
            const parentLi = document.createElement("li");
            parentLi.className =
                "group-node my-[3px] text-2xs hover:bg-gray-300 cursor-pointer flex flex-col";

            // Container for name and events
            const container = document.createElement("div");
            container.className = "flex items-center gap-2";
            container.textContent = `Group: ${key}`;

            // Double-click toggles visibility
            container.addEventListener("dblclick", (e) => {
                e.stopPropagation();
                const newState = !objs[0].visible;
                objs.forEach((o) => (o.visible = newState));
                objs.forEach((o) => {
                    if (o.userData.csvObject) {
                        const csvObj = scene.getObjectByProperty(
                            "uuid",
                            o.userData.csvObject,
                        );
                        if (csvObj) csvObj.visible = newState;
                    }
                });
                createLabels();
                styleSubtree(parentLi, newState);
            });

            parentLi.appendChild(container);

            // Children
            const childUl = document.createElement("ul");
            childUl.className = "ml-4 list-disc";
            objs.forEach((childObj) => {
                childUl.appendChild(buildTree(childObj));
            });
            parentLi.appendChild(childUl);
            ul.appendChild(parentLi);
        });

        // Standalone
        standalone.forEach((obj) => {
            ul.appendChild(buildTree(obj));
        });

        outliner.appendChild(ul);
    }

    const refDropzone = document.getElementById("reference-dropzone");
    const alignDropzone = document.getElementById("align-dropzone");
    const alignButton = document.getElementById("align-button");
    const alignmentPopup = document.getElementById("alignment-popup");

    // Prevent default behavior for dragover events.
    [refDropzone, alignDropzone].forEach((zone) => {
        zone.addEventListener("dragover", (e) => {
            e.preventDefault();
            console.log(e);
        });
    });

    // Handle drop on Reference zone.
    refDropzone.addEventListener("drop", (e) => {
        e.preventDefault();
        console.log("Dropped");
        console.log(e);
        if (referenceSelection.length >= 2) return;
        const objId = parseInt(e.dataTransfer.getData("text/plain"));
        const obj = scene.getObjectById(objId);
        if (!obj) return;
        // Optionally, check that this object comes from a CSV-derived group (e.g. via a flag)
        referenceSelection.push(obj);
        console.log(referenceSelection);
        updateDropzoneUI(refDropzone, referenceSelection);
        checkAlignmentReady();
    });

    // Handle drop on Align zone.
    alignDropzone.addEventListener("drop", (e) => {
        e.preventDefault();
        console.log(e);
        if (alignSelection.length >= 2) return;
        const objId = parseInt(e.dataTransfer.getData("text/plain"));
        const obj = scene.getObjectById(objId);
        if (!obj) return;
        alignSelection.push(obj);
        console.log(alignSelection);
        updateDropzoneUI(alignDropzone, alignSelection);
        checkAlignmentReady();
    });

    // Helper to update the dropzone display.
    function updateDropzoneUI(zone, selectionArray) {
        zone.innerHTML = "";
        selectionArray.forEach((obj) => {
            const span = document.createElement("span");
            span.textContent = obj.name;
            span.className = "block text-center text-blue-700";
            zone.appendChild(span);
        });
        if (selectionArray.length === 0) {
            zone.textContent = "Drop 2 items here";
        }
    }

    // Check if both zones have 2 items and show the Align button.
    function checkAlignmentReady() {
        if (referenceSelection.length === 2 && alignSelection.length === 2) {
            alignButton.classList.remove("hidden");
        }
    }

    alignButton.addEventListener("click", () => {
        alignGroups(referenceSelection, alignSelection);
        // Clear selections and hide popup
        referenceSelection = [];
        alignSelection = [];
        refDropzone.innerHTML = "Drop 2 items here";
        alignDropzone.innerHTML = "Drop 2 items here";
        alignButton.classList.add("hidden");
        alignmentPopup.classList.add("hidden");
    });

    // Alignment function: splits the transformation between the two groups.
    function alignGroups(refMarkers, alignMarkers) {
        // Assume the CSV-derived group is the parent of a marker.
        const groupA = refMarkers[0].parent;
        const groupB = alignMarkers[0].parent;

        // Helper to get an object's world position.
        const getPosition = (obj) => {
            const pos = new THREE.Vector3();
            obj.getWorldPosition(pos);
            return pos;
        };

        // Get the world positions of the two markers for each group.
        const p1 = getPosition(refMarkers[0]);
        const p2 = getPosition(refMarkers[1]);
        const q1 = getPosition(alignMarkers[0]);
        const q2 = getPosition(alignMarkers[1]);

        // Compute each group's anchor (midpoint of its two markers).
        const midA = new THREE.Vector3().addVectors(p1, p2).multiplyScalar(0.5);
        const midB = new THREE.Vector3().addVectors(q1, q2).multiplyScalar(0.5);

        // Compute the global target anchor (average of the two midpoints).
        const midAvg = new THREE.Vector3()
            .addVectors(midA, midB)
            .multiplyScalar(0.5);

        // Compute rotation angles based on projection to the XZ plane.
        const getXZ = (vec) => new THREE.Vector2(vec.x, vec.z);
        const angleA = Math.atan2(
            getXZ(p2).y - getXZ(p1).y,
            getXZ(p2).x - getXZ(p1).x,
        );
        const angleB = Math.atan2(
            getXZ(q2).y - getXZ(q1).y,
            getXZ(q2).x - getXZ(q1).x,
        );
        const deltaAngle = angleB - angleA;

        // For each group, compute how much to translate so that its anchor becomes midAvg.
        const offsetA = new THREE.Vector3().subVectors(midAvg, midA);
        const offsetB = new THREE.Vector3().subVectors(midAvg, midB);

        // Apply the translation to each group.
        groupA.position.add(offsetA);
        groupB.position.add(offsetB);

        // Helper function to rotate a group about a given world point.
        function rotateGroupAboutPoint(group, point, angle) {
            group.position.sub(point);
            group.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
            group.position.add(point);
            group.rotation.y += angle;
        }

        // Rotate groupA about midAvg by half the deltaAngle.
        rotateGroupAboutPoint(groupA, midAvg, deltaAngle / 2);
        // Rotate groupB about midAvg by the negative half deltaAngle.
        rotateGroupAboutPoint(groupB, midAvg, -deltaAngle / 2);

        console.log(
            "Aligned groups using marker anchors:",
            groupA.name,
            groupB.name,
        );
    }

    document
        .getElementById("open-align-popup")
        ?.addEventListener("click", () => {
            alignmentPopup.classList.remove("hidden");
        });

    document.getElementById("scale-slider").addEventListener("input", (e) => {
        scaleGroupRelativeToCenter(m_Group, e.target.value);
    });

    document
        .getElementById("cone-size-slider")
        .addEventListener("input", (e) => {
            markers.forEach((i) => {
                console.log(e);
                i.scale.set(e.target.value, e.target.value, e.target.value);
                console.log(i.scale);
            });
        });

    window.addEventListener("export-csv", (e) => {
        createCSVFromSphereGroups([m_Group]);
    });

    window.addEventListener("object-switch", (e) => {
        csvGroups.forEach((e) => {
            e.visible = false;
        });
        fbxFiles.forEach((e) => {
            e.visible = false;
        });
        simplifiedNamesId.forEach((i) => {
            if (i.simplifiedName == e.detail) {
                // console.log(i.csvObject);
                scene.getObjectByProperty("uuid", i.uuid).visible = true;
                if (i.csvObject) {
                    const csvObj = scene.getObjectByProperty(
                        "uuid",
                        i.csvObject,
                    );
                    csvObj.visible = true;
                    csvObj.children.forEach((j) => {
                        j.visible = true;
                    });
                    m_Group = scene.getObjectByProperty("uuid", i.csvObject);
                }
            } else {
                scene.getObjectByProperty("uuid", i.uuid).visible = false;
                if (i.csvObject) {
                    const csvObj = scene.getObjectByProperty(
                        "uuid",
                        i.csvObject,
                    );
                    csvObj.visible = false;
                    csvObj.children.forEach((j) => {
                        j.visible = false;
                    });
                }
            }
        });
    });

    //Gizmo controls
    document.getElementById("camera-top").addEventListener("click", (e) => {
        camera.position.set(0, 400, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    });

    document.getElementById("camera-bottom").addEventListener("click", (e) => {
        camera.position.set(0, -400, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 180, 0));
    });

    document.getElementById("camera-left").addEventListener("click", (e) => {
        camera.position.set(-200, 0, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    });

    document.getElementById("camera-right").addEventListener("click", (e) => {
        camera.position.set(200, 0, 0);
        camera.setRotationFromEuler(new THREE.Euler(0, 0, 0));
    });

    window.addEventListener("resize", onWindowResize, false);

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
</script>

<style>
    html {
        min-height: 100vh;
        width: 100%;
        margin: 0%;
    }

    body {
        /* min-height: 100vh;
        width: 100%;
        margin: 0%; */
        max-width: 100vw;
        display: flex;
        flex-wrap: wrap;
        min-height: 90vh;
        margin: 0%;
    }

    .ui-area {
        position: fixed;
        height: min-content;
    }

    .notification-panel {
        position: fixed;
        display: flex;
        flex-direction: column;
        right: 0%;
        width: 250px;
        grid-column: auto;
        gap: 10px;
    }

    .notification {
        padding: 0.5em;
        background-color: azure;
    }

    #tag,
    #tag * {
        display: flex;
        position: fixed;
        background-color: #cccccccc;
        padding: 0em 0.5em;
        text-align: left;
        line-height: 0.5em;
        font-family: monospace;
        font-weight: 100;
        justify-content: center;
        min-width: max-content;
        pointer-events: none;
        /* transform: translate(-50%); */
        /* min-height: 50px; */
        height: fit-content;
        border-radius: 6px;
        /* font-family: sans-serif; */
    }
    #label {
        display: flex;
        text-align: center;
        justify-content: center;
        margin: 0%;
        height: 100%;
        font-family: sans-serif;
    }
</style>
