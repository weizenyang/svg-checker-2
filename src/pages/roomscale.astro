---
import ObjectList from "../components/object-list.tsx";
---

<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Three.js - Three Sides of a Cube</title>
    </head>
    <body id="drop-zone">
        <div class="ui-area">
            <button id="log-scene"> Log Scene </button>
            <button id="x-flip"> X-Axis </button>
            <button id="y-flip"> Y-Axis </button>
            <button id="z-flip"> Z-Axis </button>
            <button id="y-up"> Y-Up Toggle </button>
            <ObjectList client:load />
        </div>
        <div id="tag">
            <h3 id="label">-</h3>
        </div>
    </body>
</html>

<script>
    import * as THREE from "../scripts/three";
    import { OrbitControls } from "../scripts/three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "../scripts/three/examples/jsm/loaders/GLTFLoader.js";
    import { FBXLoader } from "../scripts/three/examples/jsm/loaders/FBXLoader";

    const scene = new THREE.Scene();

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    //Manipulatable Group
    var m_Group;

    //Axis
    const axesHelper = new THREE.AxesHelper(5);
    scene.add(axesHelper);

    //Lights
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
    scene.add(directionalLight);

    const light = new THREE.AmbientLight(0x404040);
    scene.add(light);

    //Camera
    const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
    );
    camera.position.x = -210.41;
    camera.position.y = 1.31;
    camera.position.z = 0;

    //Mouse Raycaster
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function onPointerMove(event) {
        pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
        pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    }

    window.addEventListener("pointermove", onPointerMove);

    //Controls
    const orbitalControls = new OrbitControls(camera, renderer.domElement);

    //Action!!
    function animate() {
        raycaster.setFromCamera(pointer, camera);
        const intersects = raycaster.intersectObjects(scene.children);
        var label = document.getElementById("label");
        label.innerHTML = "";

        //Default Tag State
        document.getElementById("tag").style.display = "none";
        if (intersects.length > 0) {
            document.getElementById("tag").style.display = "flex";
            var idLabel = document.createElement("p");
            let positionObjects = intersects.filter(
                (item) => item.object.cameraPos && item.object.parent.visible
            );

            if (positionObjects.length > 0) {
                console.log(positionObjects[0])
                idLabel.innerText = `ID: ${positionObjects[0].object.name}`;
                idLabel.style.color = "#007700";
                label.append(idLabel);
            }
        }

        requestAnimationFrame(animate);
        orbitalControls.update();
        renderer.render(scene, camera);
    }
    animate();

    //Tag
    document.addEventListener("mousemove", (e) => {
        document.getElementById("tag").style.left = `${e.x}px`;
        document.getElementById("tag").style.top = `${e.y}px`;
        document.getElementById("tag").style.transform = `translate(${
            (e.clientX / window.innerWidth) * -100
        }%, ${(e.clientY / window.innerHeight) * -150}%)`;
    });

    const fbxFiles = [];
    const glbFiles = [];
    const csvGroups = [];
    const simplifiedNamesId = [];

    //File Drop
    function handleDrop(event) {
        event.preventDefault();
        const items = event.dataTransfer.items;
        const files = event.dataTransfer.files;

        // Check if a single item is dropped
        if (items.length === 1) {
            const entry = items[0].webkitGetAsEntry(); // Use webkitGetAsEntry for better folder support
            const file = files[0];
            if (entry && file.type != "text/csv") {
                if (entry.isDirectory) {
                    enumerateDirectoryWithManyFiles(entry);
                } else {
                    console.error("Please drop a folder containing FBX files.");
                }
            } else if (file.type === "text/csv" || file.name.endsWith(".csv")) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    processCSVData(e.target.result, file.name);
                };
                reader.readAsText(files[0]);
            } else {
                console.error("Dropped item could not be accessed.");
            }
        } else {
            console.error("Please drop only one item.");
        }
    }

    async function enumerateDirectoryWithManyFiles(directoryEntry) {
        //Workaround because readEntries only reads 100 files
        let reader = directoryEntry.createReader();
        let resultEntries = [];

        let read = async function () {
            let entries = await traverseDirectoryAsync(reader);
            if (entries.length > 0) {
                resultEntries = resultEntries.concat(entries);
                await read();
            }
        };

        await read();
        return resultEntries;
    }

    function getGrandparent(entry) {
        return new Promise((resolve, reject) => {
            entry.getParent(
                (parent) => {
                    parent.getParent(
                        (grandparent) => {
                            resolve(grandparent.name);
                        },
                        (error) => {
                            reject(error);
                        },
                    );
                },
                (error) => {
                    reject(error);
                },
            );
        });
    }
    //Traverse File Tree Workaround because readEntries only reads 100 files
    function traverseDirectoryAsync(reader) {
        return new Promise((resolve, reject) => {
            reader.readEntries(
                (entries) => {
                    var objectCount = 0;

                    entries.forEach((entry) => {
                        if (entry.isFile && entry.name.endsWith(".fbx")) {
                            entry.file((file) => {
                                objectCount++;
                                const tempCount = objectCount;
                                const reader = new FileReader();
                                reader.readAsArrayBuffer(file);
                                reader.onload = (event) => {
                                    const arrayBuffer = event.target.result;
                                    const loader = new FBXLoader();
                                    const item = loader.parse(arrayBuffer, "");
                                    var currentObject;
                                    getGrandparent(entry)
                                        .then((grandparentName) => {
                                            item.unitName = grandparentName;
                                            item.name = entry.name;
                                            currentObject = {
                                                fileName: entry.name,
                                                unitName: grandparentName,
                                            };
                                            const csvObject = csvGroups.find(x => x.userData.simplifiedName === grandParent);
                                            var newObject = {uuid: item.uuid, simplifiedName: grandparentName, csvObject: csvObject ? csvObject : ""}
                                            simplifiedNamesId.push(newObject)
                                            fbxFiles.push(currentObject);

                                            const fileUploadEvent =
                                                new CustomEvent("file-upload", {
                                                    detail: currentObject,
                                                });
                                            window.dispatchEvent(
                                                fileUploadEvent,
                                            );
                                        })
                                        .catch((error) =>
                                            console.error(
                                                "Error fetching grandparent:",
                                                error,
                                            ),
                                        );

                                    scene.add(item);
                                };
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".glb")
                        ) {
                            glbFiles.push(entry);
                            entry.file((file) => {
                                objectCount++;
                                const tempCount = objectCount;
                                const reader = new FileReader();
                                reader.readAsArrayBuffer(file);
                                reader.onload = (event) => {
                                    const arrayBuffer = event.target.result;
                                    const loader = new GLTFLoader();
                                    const item = loader.parse(arrayBuffer, "");
                                    item.name = entry.name;
                                    simplifiedNamesId.push({uuid: item.uuid, simplifiedName: entry.name.replace(/\D/g, "")})
                                    glbFiles.push(item.name);
                                    scene.add(item);
                                };
                            });
                        } else if (
                            entry.isFile &&
                            entry.name.endsWith(".csv")
                        ) {
                            entry.file((file) => {
                                const reader = new FileReader();
                                reader.onload = (e) => {
                                    processCSVData(e.target.result, file.name);
                                };
                                reader.readAsText(file);
                            });
                        } else if (entry.isDirectory) {
                            const subReader = entry.createReader();
                            traverseDirectoryAsync(subReader); // Recursive call
                        }
                    });
                    resolve(entries);
                },
                (error) => reject(error),
            );
        });
    }

    const logScene = document.getElementById("log-scene");
    logScene.addEventListener("click", (e) => {
        console.log(scene);
    });
    const dropZone = document.getElementById("drop-zone");
    dropZone.addEventListener("drop", handleDrop);
    document.body.addEventListener("dragover", (e) => {
        event.preventDefault();
    });

    function createSphere(name, position, rotation) {
        const geometry = new THREE.SphereGeometry(0.5, 32, 16); // Sphere radius set to 1, adjust as needed
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color, change as needed
        const sphere = new THREE.Mesh(geometry, material);

        // Set position
        sphere.position.set(position.x, position.y, position.z);

        // Set rotation using Euler angles, converting degrees to radians
        sphere.rotation.set(
            THREE.MathUtils.degToRad(rotation.x + 180),
            THREE.MathUtils.degToRad(rotation.y),
            THREE.MathUtils.degToRad(rotation.z),
        );

        sphere.name = name;

        return sphere;
    }

    // Function to create a CSV from sphere groups and trigger download
function createCSVFromSphereGroups(csvGroups) {
    let csvContent = ""; // CSV header

    csvGroups.forEach(group => {
        group.children.forEach(child => {
            if (child instanceof THREE.Mesh) { // Ensure child is a mesh (sphere)
                const name = child.name;
                const position = child.position;
                const rotation = child.rotation;
                csvContent += `${name},${position.x},${-position.y},${position.z},${rotation.x},${rotation.y},${rotation.z}\n`;
            }
        });
        
        // Create a downloadable CSV file
        const blob = new Blob([csvContent], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${group.name.split(".")[0]}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
    });
}

function convertFBXtoGLB(position, rotation) {
    // Assuming FBX is Y-up and GLB is Z-up
    // Convert position
    const convertedPosition = {
        x: position.x,
        y: position.z,
        z: -position.y,
    };

    // Convert rotation (assuming Euler angles)
    const convertedRotation = {
        x: rotation.x,
        y: rotation.z,
        z: -rotation.y,
    };

    return { position: convertedPosition, rotation: convertedRotation };
}

    // Function to process CSV data and create spheres
    function processCSVData(csvText, name?) {
        const lines = csvText.split("\n"); // Split CSV text into lines
        // Skip the first line if it contains headers, and process the rest

        const group = new THREE.Group();

        for (let i = 1; i < lines.length; i++) {
            const row = lines[i].split(",");
            if (row.length >= 7) {
                const name = row[0];
                const position = {
                    x: parseFloat(row[1]),
                    y: parseFloat(row[2]),
                    z: parseFloat(row[3]),
                };
                const rotation = {
                    x: parseFloat(row[4]),
                    y: parseFloat(row[5]),
                    z: parseFloat(row[6]),
                };
                // position.y = position.y * -1;
                // const { position: convertedPosition, rotation: convertedRotation } = convertFBXtoGLB(position, rotation);
                const sphere = createSphere(name, position, rotation);
                sphere.cameraPos = true;
                
                group.add(sphere);
            }

            if(name){
                group.name = name;
                group.userData.simplifiedName = name.replace(/\D/g, "");
            }
            scene.add(group);
            m_Group = group;
        }
        csvGroups.push(group)

        //Update main object references
        if(simplifiedNamesId.length > 0){
            simplifiedNamesId.forEach((e) => {
                if(e.simplifiedName == name.replace(/\D/g, "")){
                    e.csvObject = group.uuid;
                } else {
                    group.remove()
                }
            })
        }
        

            const csvUploadEvent = new CustomEvent('file-upload-csv', {
                detail: {
                    simplifiedName: group.userData.simplifiedName,
                    name: group.name
                },
            })
            window.dispatchEvent(csvUploadEvent)
    }

    document.getElementById("x-flip").addEventListener("click", (e) => {
        m_Group.rotateOnWorldAxis(
            new THREE.Vector3(1, 0, 0),
            THREE.MathUtils.degToRad(180),
        );
    });

    document.getElementById("y-flip").addEventListener("click", (e) => {
        m_Group.rotateOnWorldAxis(
            new THREE.Vector3(0, 1, 0),
            THREE.MathUtils.degToRad(180),
        );
    });

    document.getElementById("z-flip").addEventListener("click", (e) => {
        m_Group.rotateOnWorldAxis(
            new THREE.Vector3(0, 0, 1),
            THREE.MathUtils.degToRad(180),
        );
    });

    document.getElementById("y-up").addEventListener("click", (e) => {
        m_Group.children.forEach((e) => {
            const initYPos = e.position.y;
            e.position.y = -initYPos;
        });
    });

    window.addEventListener('export-csv', (e) => {
        createCSVFromSphereGroups([m_Group]);
    })

    window.addEventListener('object-switch', (e) => {
        csvGroups.forEach((e) => {
            e.visible = false
        })
        fbxFiles.forEach((e) => {
            e.visible = false
        })
        simplifiedNamesId.forEach((i) => {
            if(i.simplifiedName == e.detail){
                console.log(i.csvObject)
                scene.getObjectByProperty('uuid', i.uuid).visible = true;
            if(i.csvObject){
                const csvObj = scene.getObjectByProperty('uuid', i.csvObject);
                csvObj.visible = true;
                csvObj.children.forEach((j) => {
                    j.visible = true
                })
                m_Group = scene.getObjectByProperty('uuid', i.csvObject);
            }

            } else {
                
                    scene.getObjectByProperty('uuid', i.uuid).visible = false;
                    if(i.csvObject){
                        const csvObj = scene.getObjectByProperty('uuid', i.csvObject);
                        csvObj.visible = false;
                        csvObj.children.forEach((j) => {
                            j.visible = false;
                        })
                    }
            } 
        })
    })

    window.addEventListener( 'resize', onWindowResize, false );

    function onWindowResize(){
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );
    }
</script>

<style>
    html {
        min-height: 100vh;
        width: 100%;
        margin: 0%;
    }

    body {
        /* min-height: 100vh;
        width: 100%;
        margin: 0%; */
        max-width: 100vw;
        display: flex;
        flex-wrap: wrap;
        min-height: 90vh;
        margin: 0%;
    }

    .ui-area {
        position: fixed;
        height: min-content;
    }

    #tag,
    #tag * {
        display: flex;
        position: fixed;
        background-color: #cccccccc;
        padding: 0em 0.5em;
        text-align: left;
        line-height: 0.5em;
        font-family: monospace;
        font-weight: 100;
        justify-content: center;
        min-width: max-content;
        pointer-events: none;
        /* transform: translate(-50%); */
        /* min-height: 50px; */
        height: fit-content;
        border-radius: 6px;
        /* font-family: sans-serif; */
    }
    #label {
        display: flex;
        text-align: center;
        justify-content: center;
        margin: 0%;
        height: 100%;
        font-family: sans-serif;
    }
</style>
