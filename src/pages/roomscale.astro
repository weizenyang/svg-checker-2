---

---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Three.js - Three Sides of a Cube</title>
	</head>
	<body id="drop-zone">
        <div class="ui-area">
            <button id="log-scene">
                Log Scene
            </button>
            <button id="x-flip">
                X-Axis
            </button>
            <button id="y-flip">
                Y-Axis
            </button>
            <button id="z-flip">
                Z-Axis
            </button>

            <button id="y-up">
                Y-Up Toggle
            </button>
        </div>
        <div id="tag">
            <h3 id="label">-</h3>
        </div>
	</body>
</html>

<script>
	import * as THREE from '../scripts/three';
	import { OrbitControls } from '../scripts/three/examples/jsm/controls/OrbitControls.js';
	import { GLTFLoader } from '../scripts/three/examples/jsm/loaders/GLTFLoader.js';
    import { FBXLoader } from '../scripts/three/examples/jsm/loaders/FBXLoader'
    import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';
    
	const scene = new THREE.Scene();

	const renderer = new THREE.WebGLRenderer({ antialias: true });
	renderer.setSize(window.innerWidth, window.innerHeight);
	document.body.appendChild(renderer.domElement);

    //Manipulatable Group
    var m_Group;

    //Axis
    const axesHelper = new THREE.AxesHelper( 5 );
    scene.add( axesHelper );

    //Lights
    const directionalLight = new THREE.DirectionalLight( 0xffffff, 1.0 );
    scene.add(directionalLight);

    const light = new THREE.AmbientLight( 0x404040 );
    scene.add( light );

    //Camera
    const camera = new THREE.PerspectiveCamera(
		75,
		window.innerWidth / window.innerHeight,
		0.1,
		1000,
	);
    camera.position.x = -210.41;
    camera.position.y = 1.31;
	camera.position.z = 0;

    //Mouse Raycaster
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    function onPointerMove( event ) {
        pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    }

    window.addEventListener( 'pointermove', onPointerMove );

    //Controls
    const orbitalControls = new OrbitControls(camera, renderer.domElement);

    //Action!!
	function animate() {
        raycaster.setFromCamera( pointer, camera );
        const intersects = raycaster.intersectObjects( scene.children );
        var label = document.getElementById("label");
        label.innerHTML = ""

        //Default Tag State
        document.getElementById("tag").style.display = "none";
        if (intersects.length > 0) {
                document.getElementById("tag").style.display = "flex";
                var idLabel = document.createElement('p')
                idLabel.innerText = `ID: ${intersects[0].object.name}`
                idLabel.style.color = "#007700"
                label.append(idLabel)
        }

        
		requestAnimationFrame(animate);
        orbitalControls.update();
		renderer.render(scene, camera);
	}
	animate();

    	//Tag
        document.addEventListener("mousemove", (e) => {
            document.getElementById("tag").style.left = `${e.x}px`;
            document.getElementById("tag").style.top = `${e.y}px`;
            document.getElementById("tag").style.transform = `translate(${
                (e.clientX / window.innerWidth) * -100
            }%, ${(e.clientY / window.innerHeight) * -150}%)`;
        });


    //File Drop
    function handleDrop(event) {
        event.preventDefault();
        const items = event.dataTransfer.items;
        const files = event.dataTransfer.files;

        // Check if a single item is dropped
        if (items.length === 1) {
            const entry = items[0].webkitGetAsEntry(); // Use webkitGetAsEntry for better folder support
            const file = files[0];
            if (entry && file.type != "text/csv") {
            if (entry.isDirectory) {
                console.log(file)
                const reader = entry.createReader();
                traverseDirectory(reader); // Recursive function for subfolders and FBX files
            } else {
                console.error('Please drop a folder containing FBX files.');
            }
            } else if (file.type === "text/csv" || file.name.endsWith('.csv')){  
                const reader = new FileReader();
                reader.onload = (e) => {
                    processCSVData(e.target.result);
                }
                
                reader.readAsText(files[0])
            } else {
            console.error('Dropped item could not be accessed.');
            }
        } else {
            console.error('Please drop only one item.');
        }
    }

    //Traverse File Tree
    function traverseDirectory(reader) {
      reader.readEntries((entries) => {
        var objectCount = 0
        console.log(entries);
        const fbxFiles = [];
        const glbFiles = [];
        entries.forEach((entry) => {
          if (entry.isFile && entry.name.endsWith('.fbx')) {
            fbxFiles.push(entry);
            entry.file((file) => {
                objectCount++
                const tempCount = objectCount
                const reader = new FileReader();
                reader.readAsArrayBuffer(file);
                reader.onload = (event) => {
                const arrayBuffer = event.target.result;
                    const loader = new FBXLoader();
                    const item = loader.parse(arrayBuffer, '')
                    scene.add(item)
                    
                };
                console.log("fbx")
            });
            
          } else if (entry.isFile && entry.name.endsWith('.glb')) {
            glbFiles.push(entry);
            entry.file((file) => {
                objectCount++
                const tempCount = objectCount
                const reader = new FileReader();
                reader.readAsArrayBuffer(file);
                reader.onload = (event) => {
                const arrayBuffer = event.target.result;
                    // loadGLBFile(arrayBuffer)
                    const loader = new GLTFLoader();
                    const item = loader.parse(arrayBuffer, '')
                    scene.add(item)

                };
                console.log("glb")
            });
            
          } else if (entry.isDirectory) {
            const subReader = entry.createReader();
            traverseDirectory(subReader); // Recursive call
          }
        });

        // Process the list of FBX files after reading all entries
        console.log('Found FBX files:', fbxFiles);
      });
    }
        const logScene = document.getElementById('log-scene');
        logScene.addEventListener('click', (e)=>{
            console.log(scene)
        })
        const dropZone = document.getElementById('drop-zone');
        dropZone.addEventListener('drop', handleDrop);
        document.body.addEventListener("dragover", (e) => {
            event.preventDefault();
        });

        function createSphere(name, position, rotation) {
            const geometry = new THREE.SphereGeometry(0.5, 32, 16); // Sphere radius set to 1, adjust as needed
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color, change as needed
            const sphere = new THREE.Mesh(geometry, material);

            // Set position
            sphere.position.set(position.x, position.y, position.z);

            // Set rotation using Euler angles, converting degrees to radians
            sphere.rotation.set(THREE.MathUtils.degToRad(rotation.x + 180),
                                THREE.MathUtils.degToRad(rotation.y),
                                THREE.MathUtils.degToRad(rotation.z));

            sphere.name = name

            return sphere;
        }

// Function to process CSV data and create spheres
function processCSVData(csvText) {
    const lines = csvText.split('\n'); // Split CSV text into lines
    // Skip the first line if it contains headers, and process the rest
    
    const group = new THREE.Group();

    for (let i = 1; i < lines.length; i++) {
        const row = lines[i].split(',');
        if (row.length >= 7) {
            const name = row[0];
            const position = { x: parseFloat(row[1]), y: parseFloat(row[2]), z: parseFloat(row[3]) };
            const rotation = { x: parseFloat(row[4]), y: parseFloat(row[5]), z: parseFloat(row[6]) };
            position.y = position.y * -1;
            const sphere = createSphere(name, position, rotation);
            group.add(sphere);
        }

        scene.add(group)
        m_Group = group
    }
}

document.getElementById("x-flip").addEventListener("click", (e) => {
    m_Group.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0) , THREE.MathUtils.degToRad(180))
})

document.getElementById("y-flip").addEventListener("click", (e) => {
    m_Group.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0) , THREE.MathUtils.degToRad(180))
})

document.getElementById("z-flip").addEventListener("click", (e) => {
    m_Group.rotateOnWorldAxis(new THREE.Vector3(0, 0, 1) , THREE.MathUtils.degToRad(180))
})

document.getElementById("y-up").addEventListener("click", (e) => {
    m_Group.children.forEach((e) => {
        const initYPos = e.position.y;
        e.position.y = -initYPos;
    })
})

</script>

<style>
    html{
        min-height: 100vh;
        width: 100%;
        margin: 0%;
    }

    body {
        /* min-height: 100vh;
        width: 100%;
        margin: 0%; */
        max-width: 100vw;
        display: flex;
        flex-wrap: wrap;
        min-height: 90vh;
        margin: 0%;
    }

    .ui-area{
        position: fixed;
        height: min-content;
    }

    #tag, #tag *{
		display: flex;
		position: fixed;
		background-color: #cccccccc;
		padding: 0em 0.5em;
		text-align: left;
		line-height: 0.5em;
		font-family: monospace;
		font-weight: 100;
		justify-content: center;
		min-width: max-content;
		pointer-events: none;
		/* transform: translate(-50%); */
		/* min-height: 50px; */
		height: fit-content;
		border-radius: 6px;
		/* font-family: sans-serif; */
	}
	#label {
		display: flex;
		text-align: center;
		justify-content: center;
		margin: 0%;
		height: 100%;
		font-family: sans-serif;
	}
</style>