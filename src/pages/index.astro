---

---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Astro</title>
	</head>
	<body>
		<!--?xml version="1.0" encoding="UTF-8"?-->
		<main class="toolsets" style="display: flex">
			<div class="toolset-section">
				<section class="container">
					<h3>1. Choose your SVG ID Formatting</h3>
					<div class="toggle">
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								id="underscore"
								value="underscore"
								checked="checked"
							/>Underscore on Last Identifier (NHXX-XX<b>_</b>XX)
						</div>

						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="dash"
								id="dash"
							/>Dash on Last Identifier (NHXX-XX<b>-</b>XX)
						</div>
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="none"
								id="none"
								checked="checked"
							/>None
						</div>
					</div>
				</section>

				<section class="container">
					<h3>2. Then, Import SVG file here</h3>
					<div class="sub-item">
						<input type="file" id="myFile" name="filename" />
					</div>
				</section>

				<section class="container">
					<h3>3. Export reformatted files</h3>
					<div class="sub-item" style="display: flex">
						<button id="export" style="margin-right: 1em"
							>Export SVG</button
						>
						<button id="export-csv-count" style="margin-right: 1em"
							>Export CSV with Count</button
						>
						<button id="export-csv" style="margin-right: 1em">Export CSV No Count</button>
						<button id="export-csv-layer">Export CSV w Layer Attributes</button>
						<button id="export-csv-layer-2048">Export CSV w Layer Attributes</button>
					</div>
				</section>
			</div>
			<div id="id-container">
				<div class="id-list-title-container">
					<p
						class="id-list-title"
						style="padding: 0em 0em; font-weight: bold;"
					>
						CTRL + F to look for items
					</p>
					<p class="hide-toggle" id="hide-toggle">^</p>
				</div>
				<ul style="padding-left: 1em;" class="id-list" id="id-list">
				</ul>
			</div>
		</main>

		<section class="container">
			<h3>Viewer</h3>
			<label for="group" >Group:</label>
			<input id="group" oninput="this.value = this.value.toUpperCase()" type="text">

			<label for="unit">Unit:</label>
			<input id="unit" type="text" oninput="this.value = this.value.toUpperCase()">
			<button id="set-name">Set</button>
			<button id="set-unit">Apply Units</button>
			<div class="output" id="svg-container">
				<p
					style="padding: 2em; background-color: #00000022; border-radius: 3px; margin: 0px;"
				>
					No SVG file
				</p>
			</div>

			<button id="flip-x">
				Flip X
			</button>

			<button id="flip-y">
				Flip Y
			</button>

			<div id="tag">
				<h3 id="label">-</h3>
			</div>
			<svg id="svg"></svg>
		</section>
	</body>
</html>

<style>
	@font-face {
		font-family: "gabarito";
		src: url("/Gabarito-VariableFont_wght.ttf");
	}
	* {
		font-family: gabarito, sans-serif;
	}

	h3 {
		margin-top: 0.2em;
	}

	.toolsets {
		width: 100%;
	}

	.toolset-section {
		width: 100%;
		/* padding: 0.5em; */
	}
	#tag {
		display: flex;
		position: fixed;
		background-color: #cccccccc;
		padding: 0em 0.5em;
		text-align: center;
		justify-content: center;
		min-width: max-content;
		pointer-events: none;
		/* transform: translate(-50%); */
		height: 50px;
		border-radius: 6px;
		font-family: sans-serif;
	}
	#label {
		display: flex;
		text-align: center;
		justify-content: center;
		margin: 0%;
		height: 100%;
		font-family: sans-serif;
	}

	.output {
		pointer-events: fill;
	}

	#id-container {
		margin-top: 0.5em;
		background-color: #eee;
		max-height: 390px;
		width: 300px;
		border-radius: 5px;
		/* position: fixed; */
		right: 0%;
		top: 0%;
		display: flex;
		overflow-y: none;
		list-style: none;
		flex-direction: column;
		margin-left: 0.5em;
	}

	#svg-container {
		border: solid 1px #00000055;
		border-radius: 3px;
	}

	.hide {
		display: none;
	}

	.container {
		background-color: #eee;
		margin-top: 0.5em;
		padding: 0.5em;
		border-radius: 5px;
	}

	.selected{
		fill: #ff0000;
	}

	.hovered{
		fill: #ff000066;
	}

	.sub-item {
		padding: 0.5em;
		margin-bottom: 0.1em;
		background-color: #00000011;
		border-radius: 3px;
	}

	.toggle {
		display: flex;
		flex-direction: column;
	}

	.expand {
		transform: rotate(180deg);
	}

	.hide-toggle:hover {
		cursor: pointer;
		text-decoration: underline;
	}

	.id-list {
		margin: 0%;
		overflow-y: scroll;
		min-height: 50px;
	}

	.id-list-title-container {
		display: flex;
		justify-content: space-between;
		padding: 0em 1em;
		background-color: #00000011;
	}

	.id-list-title span:hover {
		cursor: pointer;
		text-decoration: underline;
	}
</style>

<script>
	enum format {
		underscore,
		dash,
		none,
	}

	var flipped = false
	var multiSelect = false
	var clusterId = [];

	var idFormat = format.none; //SVG ID format

	var formattingButtons = document.querySelectorAll(".formatting");
	formattingButtons.forEach((e) => {
		e.addEventListener("change", (event) => setFormat(event.target.value));
	});

	function setFormat(data) {
		if (data == "underscore") {
			idFormat = format.underscore;
		} else if (data == "dash") {
			idFormat = format.dash;
		} else if (data == "none") {
			idFormat = format.none;
		}
	}
	//Attribute Editor
	var groupGlobal = []

	var fileNameGlobal = "";
	var svg = document.getElementById("svg"); // get the SVG element
	var mouseRect = svg.createSVGRect(); // create a rectangle for the mouse position
	var currentSelected = null;
	document.addEventListener("mouseover", (e) => {
		// console.log(e.parentNode.nodeName.toLowerCase())
		if (
			e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
			e.srcElement.nodeName.toLowerCase() == "svg" ||
			e.srcElement.parentNode.nodeName.toLowerCase() == "g" ||
			!e.srcElement.tagName == "image"
		) {
			
			if (currentSelected != null) {
				currentSelected.classList.remove("hovered");
				if(!currentSelected.classList.contains("selected")){
					currentSelected.style.fill = "";
				} else {
					currentSelected.style.fill = "#ff0000";
				}
				
			}
			document.getElementById("tag").style.display = "flex";
			document.getElementById("label").innerText = e.srcElement.id;
			currentSelected = e.srcElement;
			e.srcElement.classList.add("hovered");
		} else {
			document.getElementById("tag").style.display = "none";
			// console.log(e.srcElement.parentNode.nodeName);
		}

		document.querySelectorAll(".hovered").forEach((e) => {
			e.style.fill = "#ff000066";
		})
	});

	document.addEventListener("click", (e) => {
		// console.log(e.parentNode.nodeName.toLowerCase())
		if (
			e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
			e.srcElement.nodeName.toLowerCase() == "svg" ||
			e.srcElement.parentNode.nodeName.toLowerCase() == "g"
		) {
			console.log(e.srcElement.id);
			// if (currentSelected != null) {
			// 	currentSelected.classList.add("hovered");
			// }
			document.getElementById("tag").style.display = "flex";
			document.getElementById("label").innerText = e.srcElement.id;
			currentSelected = e.srcElement;
			
			const groupName = e.srcElement
			//Get Attributes
			if(!multiSelect){
				groupGlobal = []
				document.querySelectorAll(".selected").forEach((e) => {
					// console.log(e.classList)
					e.classList.remove('selected')
					// console.log(e.classList)
					e.style.fill =""
				})
				groupGlobal.push(groupName)
			} else {
				groupGlobal.push(groupName)
			}
			
			
			
			if(groupGlobal.length < 2){
				
				if(groupGlobal[0].getAttribute('group-attribute') != ""){
						document.getElementById("unit").focus()
					
					document.getElementById("group").value = groupGlobal[0].getAttribute('group-attribute')
				} else {
					document.getElementById("group").focus()
					document.getElementById("group").value = ""
				}

				if(groupGlobal[0].getAttribute('unit-attribute') != ""){
					document.getElementById("unit").value = groupGlobal[0].getAttribute('unit-attribute')
				} else {
					document.getElementById("unit").placeholder = "No Attribute"
					document.getElementById("unit").value = ""
				}
				
			} else {
				document.getElementById("group").focus()
				document.getElementById("group").placeholder = "-"
				document.getElementById("unit").placeholder = "-"
			}
				e.srcElement.classList.add("selected")

			// e.srcElement.style.fill = "#ff000055";
		} else {
			document.getElementById("tag").style.display = "none";
		}

		

		document.querySelectorAll(".selected").forEach((e) => {
			e.style.fill = "#ff0000";
		})
	});

	document.getElementById('set-name').addEventListener("click", (e) => {

		document.querySelectorAll(".selected").forEach((e) => {
			
			if(document.querySelectorAll(".selected").length < 2){
				e.setAttribute("group-attribute", document.getElementById('group').value)
				e.setAttribute("unit-attribute", document.getElementById('unit').value)
				if(e.hasAttribute("group-attribute") && e.hasAttribute("unit-attribute")){
				e.id = e.getAttribute("group-attribute") + "_" + e.getAttribute("unit-attribute")
			}
			} else {
				e.setAttribute("group-attribute", document.getElementById('group').value)
				e.id = e.getAttribute("group-attribute") + "_" + e.getAttribute("unit-attribute")
			}
				
			
		})

		

	})


	document.getElementById('set-unit').addEventListener("click", (e) => {
		setUnit()
	})

	//Tag
	document.addEventListener("mousemove", (e) => {
		document.getElementById("tag").style.left = `${e.x}px`;
		document.getElementById("tag").style.top = `${e.y}px`;
		document.getElementById("tag").style.transform = `translate(${
			(e.clientX / window.innerWidth) * -100
		}%, ${(e.clientY / window.innerHeight) * -150}%)`;
	});

	var fileInput = document.getElementById("myFile");
	var type = "";
	fileInput.addEventListener("click", (e)=> {
		fileInput.value = null;
	})

	//SVG Uploading
	fileInput.addEventListener("change", function () {
		flipped = false
		// Get the selected file
		var file = fileInput.files[0];
		fileNameGlobal = file.name;

		// Check if the file is an SVG image
		if (file.type === "image/svg+xml") {
			var reader = new FileReader();

			// Add a load event listener
			reader.addEventListener("load", function () {
				// Get the SVG content as a string
				var svgString = reader.result;
				var parser = new DOMParser();
				var svgDoc = parser.parseFromString(svgString, "image/svg+xml");

				var svgElement = svgDoc.documentElement;

				var list = svgElement.querySelectorAll(`[id]`);
				document.getElementById("id-list").innerHTML = "";

				//Regex Options
				const regexLastUnderscore = /_(?=[^_]*$)/g;
				const regexLastDash = /-(?=[^-]*$)/g;
				const regexDashUnderscore = /\w+-\w+_\w+/;
				const regexText = /^[^-]*/;
				const regexGroupName = /^([A-Z]{2}\d{2}-\d{1,2})/
				const regexUnitNumber = /(\d{1,3})\D*$/


				if (idFormat == format.underscore) {
					var count = 0;
					//If Underscore mode
					list.forEach((i) => {
						const currentId = i.id;
						var listItem = document.createElement("li");

						//Check if ID ends with a dash

						if (!regexDashUnderscore.test(currentId)) {
							//Change the last Dash into Underscore
							const regexResult = currentId.replace(
								regexLastDash,
								"_",
							);
							const selected = svgElement.getElementById(`${currentId}`)
							const groupMatched = selected.id.match(regexGroupName)
						const unitMatched = selected.id.match(regexUnitNumber)	
						if(groupMatched){
							selected.setAttribute("group-attribute", groupMatched[1])
						}

						if(unitMatched){
							selected.setAttribute("unit-attribute", unitMatched[1])
						}
							
							
							selected.id =
								regexResult;
							listItem.innerHTML = regexResult;
							clusterId.push({
								id: count,
								clusterId: regexText.exec(regexResult)[0],
								unitId: regexResult,
							});
						} else {
							clusterId.push({
								id: count,
								clusterId: regexText.exec(currentId)[0],
								unitId: currentId,
							});
							listItem.innerHTML = currentId;
						}
						count++;
						listItem.style.listStyle = "none";
						listItem.style.padding = "0.5em 0em";
						document.getElementById("id-list").append(listItem);
					});
				} else if (idFormat == format.dash) {
					var count = 0;
					list.forEach((i) => {
						const currentId = i.id;
						var listItem = document.createElement("li");
						// console.log(regexDashUnderscore.test(currentId))
						if (regexDashUnderscore.test(currentId)) {
							const regexResult = currentId.replace(
								regexLastUnderscore,
								"-",
							);
							
							const selected = svgElement.getElementById(`${currentId}`)
							const groupMatched = selected.id.match(regexGroupName)
							const unitMatched = selected.id.match(regexUnitNumber)	
							if(groupMatched){
							selected.setAttribute("group-attribute", groupMatched[1])
						}

						if(unitMatched){
							selected.setAttribute("unit-attribute", unitMatched[1])
						}
							selected.id =
								regexResult;
							listItem.innerHTML = regexResult;
							clusterId.push({
								id: count,
								clusterId: regexText.exec(regexResult)[0],
								unitId: regexResult,
							});
						} else {
							listItem.innerHTML = currentId;
							clusterId.push({
								id: count,
								clusterId: regexText.exec(currentId)[0],
								unitId: currentId,
							});
						}
						count++;
						listItem.style.listStyle = "none";
						listItem.style.padding = "0.5em 0em";
						document.getElementById("id-list").append(listItem);
					});
				} else if (idFormat == format.none) {
					var count = 0;
					list.forEach((i) => {
						const currentId = i.id;
						var listItem = document.createElement("li");

						const selected = svgElement.getElementById(`${currentId}`)
						const groupMatched = selected.id.match(regexGroupName)
						const unitMatched = selected.id.match(regexUnitNumber)	
						if(groupMatched){
							selected.setAttribute("group-attribute", groupMatched[1])
						}

						if(unitMatched){
							selected.setAttribute("unit-attribute", unitMatched[1])
						}

						listItem.innerHTML = currentId;

						clusterId.push({
							id: count,
							clusterId: regexText.exec(currentId)[0],
							unitId: currentId,
						});
						count++;
						listItem.style.listStyle = "none";
						listItem.style.padding = "0.5em 0em";
						document.getElementById("id-list").append(listItem);
					});
				}


				// Append the SVG element to the div element
				var svgContainer = document.getElementById("svg-container");
				svgContainer.innerHTML = "";
				svgContainer.appendChild(svgElement);

				//Set type for export filename
				if (idFormat == format.underscore) {
					type = "underscore";
				} else if (idFormat == format.dash) {
					type = "dash";
				} else if (idFormat == format.none) {
					type = "";
				}
			});

			reader.readAsText(file);
		} else {
			alert("Please select an SVG image file.");
		}
	});

	document.addEventListener('keydown', (e) => {
		if(e.key == "Escape"){
			document.querySelectorAll(".selected").forEach((e) => {
				e.classList.remove("selected")
				e.style.fill = ""
				groupGlobal = []
				document.querySelectorAll("#group").value = "";
			})
		}

		if(e.key == "Shift"){
			multiSelect = true
		}

		if(e.key == "Enter"){
			document.querySelector("#set-name").click();
		}

		if(e.key == "Q"){
			document.querySelector("#set-unit").click();
		}
	})

	function setUnit(){

		for(var i = 0; i < groupGlobal.length; i++){
			groupGlobal[i].setAttribute('unit-attribute', pad(i+1))
		}
	}

	//Add zero to single digit
	function pad(d) {
		return (d < 10) ? '0' + d.toString() : d.toString();
	}

	document.addEventListener('keydown', (e) => {
		if(e.key == "Escape"){
			document.querySelectorAll(".selected").forEach((e) => {
				e.classList.remove("selected")
				e.style.fill = ""
				groupGlobal = []
				document.querySelectorAll("#group").value = "";
			})
		}

		if(e.key == "Shift"){
			multiSelect = true
		}
	})

	document.addEventListener('keyup', (e) => {

		if(e.key == "Shift"){
			multiSelect = false
		}
	})

	document.getElementById("hide-toggle").addEventListener("click", (e) => {
		if (document.getElementById("id-list").style.display == "none") {
			document.getElementById("id-list").style.display = "block";
			document.getElementById("hide-toggle").classList.remove("expand");
		} else {
			document.getElementById("id-list").style.display = "none";
			document.getElementById("hide-toggle").classList.add("expand");
		}
	});

	document.getElementById("export-csv").addEventListener("click", (e) => {
		exportCSV();
	});

	document
		.getElementById("export-csv-count")
		.addEventListener("click", (e) => {
			exportCSVId();
		});

	document.getElementById("export").addEventListener("click", (e) => {
		exportSVG();
	});

	document.getElementById("export-csv-layer").addEventListener("click", (e) => {
		exportFloorNamePosition();
	});

	document.getElementById("export-csv-layer-2048").addEventListener("click", (e) => {
		exportFloorNamePosition2048();
	});

	// CSV Conversion
	function exportCSV() {
		const file = fileNameGlobal;
		var data = clusterId;
		data.forEach((e) => {
			delete e.id;
		});
		if (clusterId.length > 0) {
			// We can create a header row by mapping the object keys
			var header = Object.keys(data[0])
				.map((key) => `"${key}"`)
				.join(",");

			var rows = data.map((obj) =>
				Object.values(obj)
					.map((val) => `"${val}"`)
					.join(","),
			);

			var csv = [header, ...rows].join("\n");
			var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);

			link.download = file.replace(/\.[^/.]+$/, "") + "_" + type + ".csv";
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
	}

	// CSV Conversion
	function exportCSVId() {
		var data = clusterId;
		const file = fileNameGlobal;
		if (clusterId.length > 0) {
			// We can create a header row by mapping the object keys
			var header = Object.keys(data[0])
				.map((key) => `"${key}"`)
				.join(",");

			var rows = data.map((obj) =>
				Object.values(obj)
					.map((val) => `"${val}"`)
					.join(","),
			);

			var csv = [header, ...rows].join("\n");
			var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);
			link.download =
				file.replace(/\.[^/.]+$/, "") +
				"_" +
				type +
				"_w_Count" +
				".csv";
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
	}
	//SVG Conversion
	function exportSVG() {
		const file = fileNameGlobal;
		var svg = document.querySelector("#svg-container").querySelector("svg");
		document.querySelectorAll("[id]").forEach((e)=>{
			const str = e.getAttribute('id')
			e.setAttribute("data-name", str.replace(/\s+/g, '_')) 
		})
		document.querySelectorAll("[group-attribute]").forEach((e)=>{
			e.removeAttribute("group-attribute") 
		})
		document.querySelectorAll("[unit-attribute]").forEach((e)=>{
			e.removeAttribute("unit-attribute")  
		})
		if (svg) {
			var serializer = new XMLSerializer();
			var svgString = serializer.serializeToString(svg);
			var blob = new Blob([svgString], { type: "image/svg+xml" });
			var url = URL.createObjectURL(blob);
			var link = document.createElement("a");
			link.href = url;
			link.download = file.replace(/\.[^/.]+$/, "") + "_" + type + ".svg";
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		} else {
			alert("Import and SVG to start!");
		}
	}
	//SVG Conversion
	function exportFloorNamePosition() {
		// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
		if(document.querySelector("#svg-container").querySelector("svg")){
			const parser = new DOMParser();
		var doc = null
		doc = document.querySelector("#svg-container").querySelector("svg")

		const layers = Array.from(doc.querySelectorAll("g")).map((layer) => {
			if(layer.getAttribute("id").toLowerCase() != 'reference'){
				const id = layer.getAttribute("id").replace('_', "");
			const children = Array.from(layer.children).map(
				(child) => {
					console.log(child)
					const childId = child.getAttribute("data-name") ? decodeHtml(child.getAttribute("data-name")) : child.getAttribute("id");
					
					const x = child.getAttribute("cx");
					const y = child.getAttribute("cy");
					return { id: childId, x, y };
				},
			);
			console.log(id, children)
			return { id, children };
			}
			
		}).filter((layer) => layer !== undefined);


		const csv = layers
			.flatMap((layer) =>
				layer.children.map(
					(child) => `${layer.id},${child.id},${child.x},${child.y}`,
				),
			)
			.join("\n");

		console.log(csv);
		
		const file = fileNameGlobal;
		var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);
			link.download =
				file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "")
				".csv";
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
		
	}

		//SVG Conversion
		function exportFloorNamePosition2048() {
		// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
		if(document.querySelector("#svg-container").querySelector("svg")){
			const parser = new DOMParser();
		var doc = null

		
		doc = document.querySelector("#svg-container").querySelector("svg")
		const height = doc.viewBox.baseVal.height
		const width = doc.viewBox.baseVal.width

		const layers = Array.from(doc.querySelectorAll("g")).map((layer) => {
			if(layer.getAttribute("id").toLowerCase() != 'reference'){
				const id = layer.getAttribute("id").replace('_', "");
			const children = Array.from(layer.children).map(
				(child) => {
					console.log(child)
					const childId = child.getAttribute("data-name") ? decodeHtml(child.getAttribute("data-name")) : child.getAttribute("id");
					
					const x = child.getAttribute("cx") / width * 2048;
					const y = child.getAttribute("cy") / height * 2048;
					return { id: childId, x, y };
				},
			);
			console.log(id, children)
			return { id, children };
			}
			
		}).filter((layer) => layer !== undefined);


		const csv = layers
			.flatMap((layer) =>
				layer.children.map(
					(child) => `${layer.id},${child.id},${child.x},${child.y}`,
				),
			)
			.join("\n");

		console.log(csv);
		
		const file = fileNameGlobal;
		var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);
			link.download =
				file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "")
				".csv";
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
		
	}
	

	function decodeHtml(html) {
						var txt = document.createElement("textarea");
						txt.innerHTML = html;
						return txt.value;
					}


	document.getElementById("flip-x").addEventListener("click", (e) => {
		// var svg = document.querySelector("#svg-container").querySelector("svg");
		// svg.style.scale = "-1 1"
		flipped = !flipped
		
		var doc = null
		doc = document.querySelector("#svg-container").querySelector("svg")
		const width = doc.viewBox.baseVal.width
		const layers = Array.from(doc.querySelectorAll("g")).map((layer) => {
			// if(layer.getAttribute("id").toLowerCase() != 'reference'){
				// const id = layer.getAttribute("id").replace('_', "");
			const children = Array.from(layer.children).map(
				(child) => {
					if(child.tagName == "image"){
						
						// child.getAttribute("transform")
						// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
						if(!child.hasAttribute("flipped")){
							child.setAttribute("flipped", "")
							child.style.transform = 'scaleX(-1) translate(-100%, 0)'
						} else {
							child.removeAttribute("flipped")
							child.style.transform = 'scaleX(1) translate(0, 0)'
						}
						
						
						console.log(child.style.scale)
				} else {
						const x = child.getAttribute("cx");
					child.setAttribute("cx", width - x)
					}
					
				},
			);
			// }
			
		})

		
	});

	document.getElementById("flip-y").addEventListener("click", (e) => {
		// var svg = document.querySelector("#svg-container").querySelector("svg");
		// svg.style.scale = "-1 1"
		flipped = !flipped
		
		var doc = null
		doc = document.querySelector("#svg-container").querySelector("svg")
		const height = doc.viewBox.baseVal.height
		const layers = Array.from(doc.querySelectorAll("g")).map((layer) => {
			// if(layer.getAttribute("id").toLowerCase() != 'reference'){
				// const id = layer.getAttribute("id").replace('_', "");
			const children = Array.from(layer.children).map(
				(child) => {
					if(child.tagName == "image"){
						
						// child.getAttribute("transform")
						// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
						if(!child.hasAttribute("flipped")){
							child.setAttribute("flipped", "")
							child.style.transform = 'scaleX(-1) translate(-100%, 0)'
						} else {
							child.removeAttribute("flipped")
							child.style.transform = 'scaleX(1) translate(0, 0)'
						}
						
						
						console.log(child.style.scale)
				} else {
						const x = child.getAttribute("cx");
					child.setAttribute("cy", height - y)
					}
					
				},
			);
			// }
			
		})

		
	});
</script>
