---
import UpdateValuesModal from "../components/UpdateValuesModal.astro";
import Tutorial from "../components/Tutorial.astro";
import "../styles.css";
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Astro</title>
	</head>
	<body class="">
		<div class="drag-drop-prompt">
			<div class="animated-border">
				<h1>Drag and Drop Here</h1>
			</div>
		</div>
		<UpdateValuesModal />
		<main class="toolsets" style="display: flex">
			<div class="toolset-section">
				<a
					href="/"
					class="flex w-fit border-2 pl-2 pr-2 p-1 mb-2 text-center rounded-md content-center hover:bg-neutral-100"
				>
					<div class="align-center content-center">
						<svg
							xmlns="http://www.w3.org/2000/svg"
							fill="none"
							viewBox="0 0 24 24"
							stroke-width="1.5"
							stroke="currentColor"
							class="size-5"
						>
							<path
								stroke-linecap="round"
								stroke-linejoin="round"
								d="m2.25 12 8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25"
							></path>
						</svg>
					</div>

					<p class="ml-2">Home</p>
				</a>
				<section class="container">
					<input
						class="dropdown"
						id="custom-formatting"
						name="formatting"
						type="checkbox"
						style="display: none"
					/>
					<label for="custom-formatting"
						>Custom SVG ID Formatting <span class="arrow">^</span
						></label
					>

					<div class="toggle">
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								id="underscore"
								value="underscore"
							/>Underscore on Last Identifier (NHXX-XX<b>_</b>XX)
						</div>

						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="dash"
								id="dash"
							/>Dash on Last Identifier (NHXX-XX<b>-</b>XX)
						</div>
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="none"
								id="none"
								checked="checked"
							/>None
						</div>
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="fullUnderscore"
								id="fullUnderscore"
							/>Full Underscore
						</div>
					</div>
				</section>

				<section class="container">
					<!-- <h3>2. Then, Import Files here</h3> -->
					<!-- <button class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300" class="button-style">Import </button> -->
					<label for="myFile" class="button-style"
						>Import <svg
							xmlns="http://www.w3.org/2000/svg"
							width="24"
							height="24"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							strokeLinecap="round"
							strokeLinejoin="round"
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="17 8 12 3 7 8" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="3"
								y2="15"
								stroke-width="2"></line>
						</svg></label
					>
					<input
						type="file"
						class="input-style"
						id="myFile"
						name="filename"
						style="display:none; "
					/>
					<label
						for="updateValues"
						class="flex bg-[#ffffff] hover:bg-[#dddddd] items-center justify-center border border-neutral-700 rounded-[4px] p-0.5 mt-1.5 text-sm text-[#333333] align-center cursor-pointer"
						>Update Names
						<svg
							class="ml-1"
							xmlns="http://www.w3.org/2000/svg"
							width="16"
							height="16"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							strokeLinecap="round"
							strokeLinejoin="round"
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="17 8 12 3 7 8" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="3"
								y2="15"
								stroke-width="2"></line>
						</svg></label
					>
					<input
						type="file"
						class="input-style"
						id="updateValues"
						name="filename"
						accept="text/csv"
						style="display:none"
					/>
				</section>

				<section class="container">
					<div
						class="sub-item"
						style="display: flex; flex-direction: column; margin-bottom: 10px;"
					>
						<p style="padding: 0 0px 10px 0em; margin: 0px;">
							Edit:
						</p>
						<div
							class="grid grid-cols-2 button-gap"
							id="edit-options"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="flip-x"
							>
								Flip X</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="flip-y"
							>
								Flip Y</button
							>
						</div>
					</div>

					<div
						class="sub-item hidden"
						id="show-floors"
						style="display: flex; flex-direction: column; margin-bottom: 10px;"
					>
						<p style="padding: 0 0px 10px 0em; margin: 0px;">
							Floors:
						</p>
					</div>

					<div
						class="sub-item"
						style="display: flex; flex-direction: column; margin-bottom: 10px;"
					>
						<input
							id="group"
							type="text"
							placeholder="Group"
							oninput="this.value = this.value.toUpperCase()"
							style="margin-bottom: 10px;"
							class="input-style"
						/>

						<input
							id="unit"
							type="text"
							oninput="this.value = this.value.toUpperCase()"
							placeholder="Unit"
							class="input-style"
						/>
						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="set-name">Set</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="set-unit">Apply Units</button
							>
						</div>
					</div>

					<div
						class="sub-item"
						style="display: flex; flex-direction: column;"
					>
						<p style="padding: 0 0px 10px 0em; margin: 0px;">
							Point Properties:
						</p>
						<input
							id="item-id"
							type="text"
							placeholder="ID"
							style="margin-top: 10px;"
							class="input-style"
						/>

						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="set-id">Set</button
							>
						</div>
						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="add-point">Add Point</button
							>
						</div>
						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="delete-point">Delete</button
							>
						</div>
					</div>
				</section>

				<section class="container">
					<input
						type="text"
						placeholder="File Name"
						class="input-style"
						id="export-file-name"
						style="margin-bottom: 10px"
					/>

					<button
						id="export"
						class="button-style"
						style="margin-bottom: 10px"
					>
						Export SVG
						<svg
							xmlns="http://www.w3.org/2000/svg"
							width="24"
							height="24"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							strokeLinecap="round"
							strokeLinejoin="round"
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="7 10 12 15 17 10" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="15"
								y2="3"
								stroke-width="2"></line>
						</svg></button
					>
					<div class="">
						<input
							type="checkbox"
							id="yx-flip"
							name="yx-flip"
							value="true"
							checked
						/>
						<label for="yx-flip"> Y/X Flip</label>
					</div>

					<button
						id="export-csv-layer"
						class="button-style"
						style="margin-bottom: 10px"
						>Export CSV <span style="margin-left: 8px" class="boxed"
							>4096px</span
						>
					</button>
					<button id="export-csv-layer-2048" class="button-style"
						>Export CSV <span style="margin-left: 8px" class="boxed"
							>2048px</span
						></button
					>
				</section>

				<Tutorial x="some data" id="tutorial" />

				<div class="container" id="id-container">
					<div class="id-list-title-container">
						<p
							class="id-list-title"
							style="padding: 0em 0em; font-weight: bold;"
						>
							CTRL + F to look for items
						</p>
						<p class="hide-toggle" id="hide-toggle">^</p>
					</div>
					<ul style="padding-left: 1em;" class="id-list" id="id-list">
					</ul>
				</div>
			</div>
		</main>

		<section class="container editor grid">
			<div id="image-list-container" class="hidden flex-col">
				<input type="text" placeholder="To Remove" id="text-replacement">
				<label
					for="check-floorplans-button"
					class="flex align-center text-center bg-neutral-100 hover:bg-neutral-300 p-1 pl-2 pr-2 rounded-sm text-sm self-end"
				>
					Check Floorplans
				</label>
				<input
					type="file"
					class="input-style"
					id="check-floorplans-button"
					accept="image/jpeg, image/png, image/webp"
					name="filename"
					multiple
					style="display:none; "
				/>
				<div
					id="image-carousel-container"
					class="hidden flex-col p-2 bg-neutral-100 rounded-sm"
				>
					<p class="text-sm mb-2">Image List</p>
					<ul
						class="flex flex-row max-h-20 w-full space-x-2 overflow-x-scroll overflow-y-hidden"
						id="image-list-carousel"
					>
					</ul>
				</div>
			</div>

			<div
				id="editor-button-container"
				style="display: flex; flex-direction: row; justify-content: space-between;"
			>
				<h3>Viewer</h3>
			</div>

			<div class="output" id="svg-container">
				<p
					style="padding: 2em; background-color: #00000022; border-radius: 3px; margin: 0px;"
				>
					Import SVG file
				</p>
			</div>

			<div class="space-y-4" id="tag">
				<h3 id="label">-</h3>
			</div>
			<svg id="svg" height="0px"></svg>
		</section>
	</body>

	<script>
		// import { onMount } from 'astro/client';
		// import * as svgOp from "./svg-scripts/svg-operations"
		import { transform } from "typescript";
		import {
			currentValuesList,
			updateValuesList,
			updateValuesModal,
			circlesToSpawn,
		} from "../store.js";
		enum format {
			underscore,
			dash,
			none,
			fullUnderscore,
		}

		var flipped = false;
		var multiSelect = false;
		var clusterId = [];

		var idFormat = format.none; //SVG ID format
		var mouseDown = false;
		var globalSvgContainer = document.getElementById("svg-container");
		var mouseInContainer = false;
		var tempSelected;
		var flipYX = true;

		let prevMouseX = 0;
		let prevMouseY = 0;

		let rightMouseDown = false;
		let anchorPoint = { x: 0, y: 0 };
		let typing = false;

		let globalFloors = [];
		let globalFloorsAggregated = [];
		let aggregatePoints = false;
		let checkboxesId = [];

		var formattingButtons = document.querySelectorAll(".formatting");
		formattingButtons.forEach((e) => {
			e.addEventListener("change", (event) =>
				setFormat(event.target.value),
			);
		});

		function setFormat(data) {
			if (data == "underscore") {
				idFormat = format.underscore;
			} else if (data == "dash") {
				idFormat = format.dash;
			} else if (data == "none") {
				idFormat = format.none;
			} else if (data == "fullUnderscore") {
				idFormat = format.fullUnderscore;
			}
		}

		//Attribute Editor
		var groupGlobal = [];

		var fileNameGlobal = "";
		var svg = document.getElementById("svg"); // get the SVG element
		var mouseRect = svg.createSVGRect(); // create a rectangle for the mouse position
		var currentSelected = null;

		// "Show the dialog" button opens the dialog modally

		//New code to interface with SVG
		document
			.getElementById("export-file-name")
			.addEventListener("input", (e) => {
				fileNameGlobal = e.target.value;
				console.log(fileNameGlobal);
			});

		//Check if SVG Container is active
		document
			.getElementById("svg-container")
			.addEventListener("mouseover", (e) => {
				//Set global var MouseInContainer
				mouseInContainer = true;
			});

		document
			.getElementById("svg-container")
			.addEventListener("mouseout", (e) => {
				//Set global var MouseInContainer
				mouseInContainer = false;
			});

		var createNewSVG = () => {
			// Create new SVG if it's not present
			const newSVG = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"svg",
			);
			newSVG.style.width = "100%";
			newSVG.style.height = "100%";
			newSVG.setAttribute("viewBox", "0 0 4096 4096");
			newSVG.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");

			return newSVG;
		};

		document
			.getElementById("svg-container")
			.addEventListener("mouseover", (e) => {
				if (
					e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
					e.srcElement.nodeName.toLowerCase() == "svg" ||
					e.srcElement.parentNode.nodeName.toLowerCase() == "g" ||
					!e.srcElement.tagName == "image"
				) {
					if (currentSelected != null) {
						currentSelected.classList.remove("hovered");
						if (
							!currentSelected.classList.contains(
								"svg-tool-selected",
							)
						) {
							currentSelected.style.fill = "";
						} else {
							currentSelected.style.fill = "#ff0000";
						}
					}
					document.getElementById("tag").style.display = "flex";
					document.getElementById("label").innerHTML = "";
					var label = document.createElement("div");
					if (e.srcElement.id) {
						var idLabel = document.createElement("p");
						idLabel.innerText = `ID: ${e.srcElement.id}`;
						idLabel.style.color = "#007700";
						idLabel.style.marginTop = "10px";
						idLabel.style.marginBottom = "10px";
						label.appendChild(idLabel);
					}

					if (e.srcElement.getAttribute("class")) {
						var classLabel = document.createElement("p");
						var tempClassList = Object.assign(
							{},
							e.srcElement.classList,
						);
						tempClassList = Object.keys(tempClassList).filter(
							(item) =>
								tempClassList[item] !== "svg-tool-selected",
						);
						if (tempClassList.length > 0) {
							var tempString = "";
							tempClassList.forEach((classname) => {
								if (tempString == "") {
									tempString = classname;
								} else {
									tempString += " " + classname;
								}
							});
							classLabel.innerText = `Class: ${tempClassList}`;
							classLabel.style.marginTop = "10px";
							classLabel.style.marginBottom = "10px";
						}

						label.appendChild(classLabel);
					}

					if (e.target.getAttribute("data-floor")) {
						var floorLabel = document.createElement("p");
						floorLabel.innerText = `Floor: ${e.srcElement.getAttribute("data-floor")}`;
						floorLabel.style.color = "#007700";
						floorLabel.style.marginTop = "10px";
						floorLabel.style.marginBottom = "10px";
						label.appendChild(floorLabel);
					}

					document.getElementById("label").append(label);
					currentSelected = e.srcElement;
					e.srcElement.classList.add("hovered");
				} else {
					document.getElementById("tag").style.display = "none";
					mouseInContainer = false;
					// console.log(e.srcElement.parentNode.nodeName);
				}

				document.querySelectorAll(".hovered").forEach((e) => {
					e.style.fill = "#ff000066";
				});
			});

		document.getElementById("yx-flip").addEventListener("change", (e) => {
			flipYX = e.target.checked;
		});

		document
			.getElementById("svg-container")
			.addEventListener("mousedown", (e) => {
				spawnLabel();
				if (
					e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
					e.srcElement.nodeName.toLowerCase() == "svg" ||
					e.srcElement.parentNode.nodeName.toLowerCase() == "g"
				) {
					if (mouseInContainer) {
						if (e.button === 0) {
							// Left mouse button
							mouseDown = true;
						} else if (e.button === 1) {
							// Right mouse button
							rightMouseDown = true;
							prevMouseX = e.clientX;
							prevMouseY = e.clientY;
							// Calculate the anchor point for scaling
							anchorPoint =
								calculateBoundingBoxCenter(groupGlobal);
						}
					}
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;
					// if (currentSelected != null) {
					// 	currentSelected.classList.add("hovered");
					// }
					document.getElementById("tag").style.display = "flex";
					document.getElementById("label").innerText =
						e.srcElement.id;
					currentSelected = e.srcElement;

					const groupName = e.srcElement;
					//Get Attributes
					if (!multiSelect) {
						groupGlobal = [];
						document
							.querySelectorAll(".svg-tool-selected")
							.forEach((e) => {
								// console.log(e.classList)
								e.classList.remove("svg-tool-selected");
								// console.log(e.classList)
								e.style.fill = "";
							});

						groupGlobal.push(groupName);
						console.log(groupGlobal);
					} else {
						if (
							!groupName.classList.contains("hovered") &&
							groupName.classList.contains("svg-tool-selected")
						) {
							groupGlobal.push(groupName);
						} else if (groupGlobal.length <= 1) {
							groupGlobal.push(groupName);
						}
						console.log(groupGlobal);
					}

					if (groupGlobal.length < 2) {
						if (
							groupGlobal[0].getAttribute("group-attribute") != ""
						) {
							document.getElementById("group").value =
								groupGlobal[0].getAttribute("group-attribute");
						} else {
							document.getElementById("group").value = "";
						}

						if (
							groupGlobal[0].getAttribute("unit-attribute") != ""
						) {
							document.getElementById("unit").value =
								groupGlobal[0].getAttribute("unit-attribute");
						} else {
							document.getElementById("unit").placeholder =
								"No Attribute";
							document.getElementById("unit").value = "";
						}

						if (groupGlobal[0].getAttribute("id") != "") {
							document.getElementById("item-id").value =
								groupGlobal[0].getAttribute("id");
						} else {
							document.getElementById("item-id").placeholder =
								"No Attribute";
							document.getElementById("item-id").value = "";
						}
					} else {
						document.getElementById("group").placeholder = "Group";
						document.getElementById("unit").placeholder = "Unit";
						document.getElementById("item-id").placeholder = "ID";
					}
					e.srcElement.classList.add("svg-tool-selected");

					// e.srcElement.style.fill = "#ff000055";
				} else {
					document.getElementById("tag").style.display = "none";
				}

				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.style.fill = "#ff0000";
				});
			});

		document.getElementById("set-name").addEventListener("click", (e) => {
			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				if (
					document.querySelectorAll(".svg-tool-selected").length < 2
				) {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.setAttribute(
						"unit-attribute",
						document.getElementById("unit").value,
					);
					if (
						e.hasAttribute("group-attribute") &&
						e.hasAttribute("unit-attribute")
					) {
						e.id =
							e.getAttribute("group-attribute") +
							"_" +
							e.getAttribute("unit-attribute");
					}
				} else {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.id =
						e.getAttribute("group-attribute") +
						"_" +
						e.getAttribute("unit-attribute");
				}
			});
		});

		document
			.getElementById("delete-point")
			.addEventListener("click", (e) => {
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.remove();
				});
			});

		document.getElementById("set-id").addEventListener("click", (e) => {
			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				if (
					document.querySelectorAll(".svg-tool-selected").length < 2
				) {
					e.setAttribute(
						"id",
						document.getElementById("item-id").value,
					);
				} else {
					e.setAttribute(
						"id",
						document.getElementById("item-id").value,
					);
				}
			});
		});

		document.getElementById("set-unit").addEventListener("click", (e) => {
			setUnit();
		});

		//Tag
		document.addEventListener("mousemove", (e) => {
			document.getElementById("tag").style.left = `${e.x}px`;
			document.getElementById("tag").style.top = `${e.y}px`;
			document.getElementById("tag").style.transform =
				`translate(0%, 150%)`;
		});

		var fileInput = document.getElementById("myFile");
		var type = "";
		fileInput.addEventListener("click", (e) => {
			fileInput.value = null;
		});

		function calculateSensitivity(svgElement) {
			const svgRect = svgElement.getBoundingClientRect(); // Get the on-screen size of the SVG
			const viewBox = svgElement.viewBox.baseVal; // Get the SVG's viewBox dimensions

			const scaleX = viewBox.width / svgRect.width;
			const scaleY = viewBox.height / svgRect.height;

			return { scaleX, scaleY };
		}

		function calculateBoundingBoxCenter(elements) {
			if (elements.length === 0) return { x: 0, y: 0 };

			let minX = Infinity,
				maxX = -Infinity,
				minY = Infinity,
				maxY = -Infinity;

			elements.forEach((element) => {
				const cx = parseFloat(element.getAttribute("cx"));
				const cy = parseFloat(element.getAttribute("cy"));

				if (cx < minX) minX = cx;
				if (cx > maxX) maxX = cx;
				if (cy < minY) minY = cy;
				if (cy > maxY) maxY = cy;
			});

			return {
				x: (minX + maxX) / 2,
				y: (minY + maxY) / 2,
			};
		}

		// Tag and mouse move event listener
		document.addEventListener("mousemove", (e) => {
			// Update Tags
			const tag = document.getElementById("tag");
			tag.style.left = `${e.x}px`;
			tag.style.top = `${e.y}px`;
			tag.style.transform = `translate(0%, -40px)`;

			if (mouseDown && mouseInContainer) {
				spawnLabel();
				const svgElement = globalSvgContainer.querySelector("svg");
				if (svgElement != null) {
					// Calculate sensitivity based on SVG resolution and size
					const { scaleX, scaleY } = calculateSensitivity(svgElement);

					// Calculate mouse movement difference once
					const deltaX = (e.clientX - prevMouseX) * scaleX;
					const deltaY = (e.clientY - prevMouseY) * scaleY;

					// Update previous mouse position once
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;

					// Move a single selected item
					if (
						tempSelected != null &&
						!multiSelect &&
						groupGlobal.length < 2
					) {
						console.log("Moving single item");
						moveElement(tempSelected, deltaX, deltaY);
					}
					// Move multiple selected items
					else if (multiSelect && groupGlobal.length > 0) {
						console.log("Moving all items");
						groupGlobal.forEach((item) =>
							moveElement(item, deltaX, deltaY),
						);
					}

					// console.log("Mouse Down + Move");
				}
			} else if (rightMouseDown && mouseInContainer) {
				const svgElement = globalSvgContainer.querySelector("svg");
				if (svgElement != null) {
					// Calculate sensitivity based on SVG resolution and size
					const { scaleX, scaleY } = calculateSensitivity(svgElement);

					// Calculate mouse movement difference
					const movementX = (e.clientX - prevMouseX) * scaleX;
					const movementY = (e.clientY - prevMouseY) * scaleY;

					// Use horizontal movement for scaling factor
					const scaleFactor = 1 + movementX * 0.01; // Adjust sensitivity here

					// Update previous mouse position
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;

					// Scale all selected items
					groupGlobal.forEach((item) =>
						scaleElement(item, scaleFactor, anchorPoint),
					);

					console.log("Scaling all items");
				}
			}
		});

		//Move SVG with CX and CY
		document.addEventListener("mousedown", (e) => {
			spawnLabel()
			if (mouseInContainer && tempSelected != null) {
				if (e.button === 0) {
					// Left mouse button
					mouseDown = true;
				} else if (e.button === 2) {
					// Right mouse button
					rightMouseDown = true;
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;
					// Calculate the anchor point for scaling
					anchorPoint = calculateBoundingBoxCenter(groupGlobal);
				}
			}

			//Checks if it's a primitive element, otherwise put in a null,
			//If TempSelected is not cleared, it will get wrongfully selected and moved during MouseDown
			if (e.srcElement.parentNode.nodeName.toLowerCase() == "g") {
				tempSelected = e.srcElement;
				console.log("tempSelected");
				console.log(tempSelected);
			} else {
				tempSelected = null;
			}

			if (
				e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
				e.srcElement.nodeName.toLowerCase() == "svg" ||
				e.srcElement.parentNode.nodeName.toLowerCase() == "g"
			) {
				console.log(e.srcElement.parentNode);
				// if (currentSelected != null) {
				// 	currentSelected.classList.add("hovered");
				// }
				document.getElementById("tag").style.display = "flex";
				document.getElementById("tag").classList.add("leading-loose");
				document.getElementById("label").innerText = e.srcElement.id;
				currentSelected = e.srcElement;

				const groupName = e.srcElement;
				//Get Attributes
				if (!multiSelect) {
					groupGlobal = [];
					document
						.querySelectorAll(".svg-tool-selected")
						.forEach((e) => {
							// console.log(e.classList)
							e.classList.remove("svg-tool-selected");
							// console.log(e.classList)
							e.style.fill = "";
						});
					groupGlobal.push(groupName);
				} else {
					if (!groupGlobal.includes(groupName)) {
						groupGlobal.push(groupName);
					}
				}

				if (groupGlobal.length < 2) {
					if (groupGlobal[0].getAttribute("group-attribute") != "") {
						document.getElementById("group").value =
							groupGlobal[0].getAttribute("group-attribute");
					} else {
						document.getElementById("group").value = "";
					}

					if (groupGlobal[0].getAttribute("unit-attribute") != "") {
						document.getElementById("unit").value =
							groupGlobal[0].getAttribute("unit-attribute");
					} else {
						document.getElementById("unit").placeholder =
							"No Attribute";
						document.getElementById("unit").value = "";
					}
				} else {
					document.getElementById("group").placeholder = "-";
					document.getElementById("unit").placeholder = "-";
				}
				e.srcElement.classList.add("svg-tool-selected");

				// e.srcElement.style.fill = "#ff000055";
			} else {
				document.getElementById("tag").style.display = "none";
			}

			document.querySelectorAll(".selected").forEach((e) => {
				e.style.fill = "#ff0000";
			});
		});

		document.addEventListener("mouseup", spawnLabel)

		function moveElement(element, deltaX, deltaY) {
			if (
				element.getAttribute("cx") != null &&
				element.getAttribute("cy") != null
			) {
				const currentCx = parseFloat(element.getAttribute("cx"));
				const currentCy = parseFloat(element.getAttribute("cy"));

				const newCx = currentCx + deltaX;
				const newCy = currentCy + deltaY;

				element.setAttribute("cx", newCx);
				element.setAttribute("cy", newCy);
			}
		}

		function scaleElement(element, scaleFactor, anchor) {
			if (
				element.getAttribute("cx") != null &&
				element.getAttribute("cy") != null
			) {
				const currentCx = parseFloat(element.getAttribute("cx"));
				const currentCy = parseFloat(element.getAttribute("cy"));

				const newCx = anchor.x + (currentCx - anchor.x) * scaleFactor;
				const newCy = anchor.y + (currentCy - anchor.y) * scaleFactor;

				element.setAttribute("cx", newCx);
				element.setAttribute("cy", newCy);
			}
		}

		document.addEventListener("mouseup", (e) => {
			mouseDown = false;
			rightMouseDown = false;
		});

		document.getElementById("add-point").addEventListener("click", (e) => {
			svg = document.getElementById("svg");
			const layers = Array.from(svg.children);

			// Find the layer with the most circle elements
			let maxCircleCount = 0;
			let layerWithMostCircles = null;

			layers.forEach((layer) => {
				const circleCount = layer.querySelectorAll("circle").length;

				if (circleCount > maxCircleCount) {
					maxCircleCount = circleCount;
					layerWithMostCircles = layer;
				}
			});

			if (document.getElementById("item-id").value.length > 0) {
				console.log(document.getElementById("item-id").value);
				const values = document.getElementById("item-id").value.split(",");
				values.map((e, i) => {
					console.log(e);
					const circle = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"circle",
					);
					circle.setAttribute("cx", `${30 * i}`);
					circle.setAttribute("cy", "30");
					circle.setAttribute("r", "30");
					circle.setAttribute("id", e);
					if (layerWithMostCircles) {
						layerWithMostCircles.appendChild(circle);
						console.log(layerWithMostCircles);
					} else {
						try {
							if (
								globalSvgContainer
									.querySelector("svg")
									.querySelector("g")
							) {
								globalSvgContainer
									.querySelector("svg")
									.querySelector("g")
									.appendChild(circle);
							} else {
								let svgInstance =
									globalSvgContainer.querySelector("svg");

								const gElement = document.createElementNS(
									"http://www.w3.org/2000/svg",
									"g",
								);
								gElement.appendChild(circle);
								svgInstance.appendChild(gElement);
							}
						} catch (e) {
							console.log(globalSvgContainer);
							let svgInstance =
								globalSvgContainer.querySelector("svg");

							if (!svgInstance) {
								svgInstance = createNewSVG();
								globalSvgContainer.appendChild(svgInstance);
							}

							const gElement = document.createElementNS(
								"http://www.w3.org/2000/svg",
								"g",
							);
							gElement.appendChild(circle);
							svgInstance.appendChild(gElement);
						}
					}
				});
				labelToggle()
			} else {
				alert("Please add a name for the point");
			}
		});

		function spawnCircle(id, cx, cy, data) {
			const g = globalSvgContainer.querySelector("g");
			const circle = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"circle",
			);
			circle.setAttribute("id", id);
			circle.setAttribute("cx", cx);
			circle.setAttribute("cy", cy);
			circle.setAttribute("r", "30");
			data.forEach((e) => {
				circle.setAttribute(e.field, e.value);
			});
			g.appendChild(circle);

			return circle;
		}

		//Listen to the UpdateValeusModal for circle spawn updates
		circlesToSpawn.listen((circles) => {
			console.log("New Circles!");
			const spacing = 2000 / circles.length;
			circles.map((e, id) => {
				console.log(circles);
				spawnCircle(e, id * spacing + 40, 70, []);
			});
			spawnLabel();
		});

		//Scale from center / scale from bounding box
		const scaleBoundingBoxToFitInstance = (svgElement, elArray) => {
			const circles = elArray;
			if (circles.length === 0) return;

			let minX = Infinity,
				maxX = -Infinity,
				minY = Infinity,
				maxY = -Infinity;

			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));
				const r = parseFloat(circle.getAttribute("r"));

				if (cx - r < minX) minX = cx - r;
				if (cx + r > maxX) maxX = cx + r;
				if (cy - r < minY) minY = cy - r;
				if (cy + r > maxY) maxY = cy + r;
			});

			const bboxWidth = maxX - minX;
			const bboxHeight = maxY - minY;

			const viewBox = svgElement.viewBox.baseVal;
			const svgWidth = viewBox.width;
			const svgHeight = viewBox.height;

			const margin = 0.2; // 1/5 margin

			const maxAllowedWidth = svgWidth * (1 - margin);
			const maxAllowedHeight = svgHeight * (1 - margin);

			const widthScale = maxAllowedWidth / bboxWidth;
			const heightScale = maxAllowedHeight / bboxHeight;

			const scale = Math.min(widthScale, heightScale, 1); // Scale down if necessary

			// Calculate the offset to center the scaled bounding box
			const offsetX = (svgWidth - bboxWidth * scale) / 2 - minX * scale;
			const offsetY = (svgHeight - bboxHeight * scale) / 2 - minY * scale;

			// Apply scaling and translation to each circle
			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));

				const newCx = cx * scale + offsetX;
				const newCy = cy * scale + offsetY;

				circle.setAttribute("cx", newCx.toFixed(4));
				circle.setAttribute("cy", newCy.toFixed(4));
				circle.setAttribute("r", 30);
			});

			spawnLabel();
		};

		// function startListeningForServerChanges() {
		// 	const eventSource = new EventSource('http://localhost:9234/events');

		// 	eventSource.onmessage = (event) => {
		// 		console.log('Server data changed:', event.data);
		// 		fetchDataFromServer(); // Call your function to fetch updated data
		// 	};

		// 	eventSource.onerror = (error) => {
		// 		console.error('EventSource error:', error);
		// 		eventSource.close(); // Optional: Close the connection on error
		// 	};
		// }

		async function fetchDataFromServer() {
			try {
				// Fetch the image data
				const imageResponse = await fetch('http://localhost:9234/image');
				if (!imageResponse.ok) throw new Error('Failed to fetch image');
				const { image, imageName } = await imageResponse.json();
				console.log({ image, imageName })

				// Convert the image buffer to a Blob
				const imageBlob = new Blob([new Uint8Array(image.data)], { type: 'image/webp' }); // Update type if necessary
				const imageFile = new File([imageBlob], imageName, { type: 'image/webp' });

				// Pass the image File object to handleFileChange
				handleFileChange(imageFile);
			} catch (error) {
				console.error('Error fetching image data from server:', error);
			}

			try {
				// Fetch the CSV data
				const csvResponse = await fetch('http://localhost:9234/csv');
				if (!csvResponse.ok) throw new Error('Failed to fetch CSV');
				const { csv, csvName } = await csvResponse.json();
				console.log({ csv, csvName })

				// Convert the CSV buffer to a Blob
				const csvBlob = new Blob([new Uint8Array(csv.data)], { type: 'text/csv' });
				const csvFile = new File([csvBlob], csvName, { type: 'text/csv' });

				// Pass the CSV File object to handleFileChange
				handleFileChange(csvFile);
			} catch (error) {
				console.error('Error fetching CSV data from server:', error);
			}
		}

		fetchDataFromServer()

		function handleFileChange(file) {
			console.log(file)
			flipped = false;
			var count = 0;
			globalFloors = [];
			globalFloorsAggregated = [];

			//Refresh show floors section
			const floorSection = document.getElementById("show-floors");
			floorSection.querySelectorAll("div").forEach((e) => {
				e.remove();
			});
			if (!floorSection.classList.contains("hidden")) {
				floorSection.classList.add("hidden");
			}

			if (document.getElementById("showLabelsDiv")) {
				document.getElementById("showLabelsDiv").remove();
			}

			const processSVG = (svgElement) => {
				const list = svgElement.querySelectorAll(`[id]`);
				svgElement.setAttribute("data-csv-editor", "svg");
				document.getElementById("id-list").innerHTML = "";

				const processIdList = (idFormat) => {
					const regexLastUnderscore = /_(?=[^_]*$)/g;
					const regexLastDash = /-(?=[^-]*$)/g;
					const regexDashUnderscore = /\w+-\w+_\w+/;
					const regexText = /^[^-]*/;
					const regexGroupName = /^([A-Z]{2}\d{2}-\d{1,2})/;
					const regexUnitNumber = /(\d{1,3})\D*$/;

					const handleId = (currentId) => {
						const listItem = document.createElement("li");

						const regexResult =
							idFormat === format.fullUnderscore
								? currentId.replaceAll("-", "_")
								: !regexDashUnderscore.test(currentId)
									? currentId.replace(regexLastDash, "_")
									: currentId;

						const selected = svgElement.getElementById(
							`${currentId}`,
						);
						const groupMatched = selected.id.match(regexGroupName);
						const unitMatched = selected.id.match(regexUnitNumber);

						if (groupMatched) {
							selected.setAttribute(
								"group-attribute",
								groupMatched[1],
							);
						}

						if (unitMatched) {
							selected.setAttribute(
								"unit-attribute",
								unitMatched[1],
							);
						}

						selected.id = regexResult;
						listItem.innerHTML = regexResult;
						clusterId.push({
							id: count,
							clusterId: regexText.exec(regexResult)[0],
							unitId: regexResult,
						});

						count++;
						listItem.style.listStyle = "none";
						listItem.style.padding = "0.5em 0em";
						document.getElementById("id-list").append(listItem);
					};

					list.forEach((i) => {
						const currentId = i.id;

						if (idFormat === format.underscore) {
							handleId(currentId);
						} else if (idFormat === format.dash) {
							handleId(
								regexDashUnderscore.test(currentId)
									? currentId.replace(
											regexLastUnderscore,
											"-",
										)
									: currentId,
							);
						} else if (
							idFormat === format.none ||
							idFormat === format.fullUnderscore
						) {
							handleId(currentId);
						}
					});
				};

				processIdList(idFormat);

				// Append the SVG element to the div element
				const svgContainer = document.getElementById("svg-container");
				svgContainer.innerHTML = "";
				svgContainer.appendChild(svgElement);

				if (imageList.length > 0) {
					previewBackplate(
						previewBackplate(
							document
								.getElementById("svg-container")
								.querySelector("svg"),
						),
					);
				}

				// Set type for export filename
				type =
					idFormat === format.underscore
						? "underscore"
						: idFormat === format.dash
							? "dash"
							: "";
			};

			if (file.type === "image/svg+xml") {
				const reader = new FileReader();
				reader.addEventListener("load", () => {
					const svgString = reader.result;
					const parser = new DOMParser();
					const svgDoc = parser.parseFromString(
						svgString,
						"image/svg+xml",
					);
					const svgElement = svgDoc.documentElement;
					processSVG(svgElement);
					if (
						document
							.getElementById("image-list-container")
							.classList.contains("hidden")
					) {
						document
							.getElementById("image-list-container")
							.classList.remove("hidden");
						document
							.getElementById("image-list-container")
							.classList.add("flex");
						document
							.getElementById("check-floorplans-button")
							.addEventListener("change", uploadImages);
					}
				});
				reader.readAsText(file);
			} else if (
				file.type === "image/jpeg" ||
				file.type === "image/png" ||
				file.type === "image/webp"
			) {
				fileNameGlobal = file.name;
				document.getElementById("export-file-name").value =
					fileNameGlobal;
				const reader = new FileReader();
				reader.onload = (event) => {
					const contents = event.target.result;
					// const img = document.createElement("img");
					// img.src = contents;
					// img.style.maxHeight = "100%";
					// img.style.maxWidth = "100%";
					// img.style.borderRadius = "5px"
					const svgContainer =
						document.getElementById("svg-container");
					var internalSVG = svgContainer.querySelector(
						"svg[data-csv-editor='svg']",
					);

					if (!internalSVG) {
						svgContainer.innerHTML = "";
						const newSVG = createNewSVG();
						svgContainer.appendChild(newSVG);
						internalSVG = newSVG;
					}

					const svgImage = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"image",
					);
					const svgViewbox = internalSVG
						.getAttribute("viewBox")
						.split(" ");
					svgImage.setAttributeNS(null, "href", contents);
					svgImage.setAttributeNS(null, "x", "0");
					svgImage.setAttributeNS(null, "y", "0");
					svgImage.setAttributeNS(null, "width", svgViewbox[2]);
					svgImage.setAttributeNS(null, "height", svgViewbox[3]);

					internalSVG.insertBefore(svgImage, internalSVG.firstChild);
				};
				reader.readAsDataURL(file);
			} else if (file.type === "text/csv") {
				if (
					document
						.getElementById("svg-container")
						.getElementsByTagName("p").length > 0
				) {
					Array.from(
						document
							.getElementById("svg-container")
							.getElementsByTagName("p"),
					).forEach((e) => {
						e.remove();
					});
				}

				fileNameGlobal = file.name;

				document.getElementById("export-file-name").value =
					fileNameGlobal;
				const reader = new FileReader();
				reader.onload = (event) => {
					const contents = event.target.result;
					const lines = contents.trim().split("\n");

					// Check the number of columns and decide to transform
					const firstLineFields = lines[0].split(",");
					let transformedLines = lines;
					let scaleToFit = false;
					//column > 3
					if (firstLineFields.length > 3) {
						// Transform the data if more than three columns
						transformedLines = lines.map((line) => {
							const fields = line.split(",");

							const [name, x, y, z] = fields;
							const cleanedName = `${name.split("_")[0]}~${name.split("_")[1]}`; //Curly line for easier text separation
							scaleToFit = true;

							return `${cleanedName},${-y},${-x},${name}`; // Swap x and y
						});
					}

					var gInstance = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"g",
					); //Create group to contain all points
					gInstance.setAttribute("id", "g-instance");
					const svgContainer =
						document.getElementById("svg-container");

					if (svgContainer.querySelector("svg")) {
						//If SVG already exists
						svgContainer
							.querySelector("svg")
							.querySelectorAll("g")
							.forEach((g) => {
								if (g.id !== "Reference") {
									g.remove();
									console.log(g);
									console.log("^ removed");
								}
							});
					} else {
						const newSVG = createNewSVG();
						newSVG.appendChild(gInstance);
						svgContainer.appendChild(newSVG);

						if (svgContainer.querySelector("img")) {
							const tempImage = svgContainer.querySelector("img");
							const svgimg = document.createElementNS(
								"http://www.w3.org/2000/svg",
								"image",
							);
							svgimg.style.width = "100%";
							svgimg.style.height = "100%";
							svgimg.setAttributeNS(
								"http://www.w3.org/1999/xlink",
								"xlink:href",
								tempImage.src,
							);
							newSVG.append(svgimg);
							tempImage.remove();
						}
					}

					svgContainer.querySelector("svg").appendChild(gInstance); //Add g into the svg

					//Floors
					for (let i = 0; i < transformedLines.length; i++) {
						const fields = transformedLines[i].split(",");

						if (Number(fields[1]) || Number(fields[2])) {
							const floor = fields[0].includes("~")
								? fields[0].split("~")[0]
								: null;
							const name = fields[0].includes("~")
								? fields[0].split("~")[1]
								: fields[0];

							const data = [];
							if (floor) {
								const floorData = {
									field: "data-floor",
									value: floor,
								};
								data.push(floorData);
							}

							const fullName = {
								// Custom attribute to be used as unique identifier for functions
								field: "data-fullname",
								value: fields[3],
							};
							data.push(fullName);

							globalFloors.push({
								floor: floor,
								circle: spawnCircle(
									name,
									Number(fields[flipYX ? 2 : 1]).toFixed(4),
									Number(fields[flipYX ? 1 : 2]).toFixed(4),
									data,
								),
							});
						} else {
							console.error(
								`${
									fields[0]
										? fields[0]
										: `(Nameless), Row ${i + 1}`
								} does not contain any cx, cy data`,
							);
						}
					}

					labelToggle()

					//Floor section
					//Dynamically add Floors section
					var floorNumbers = [];
					const labelDivInstance =
						document.getElementById("labelDiv");
					if (labelDivInstance) {
						labelDivInstance.remove();
					}
					globalFloors.forEach((e) => {
						if (!floorNumbers.includes(e.floor)) {
							floorNumbers.push(e.floor);
						}
					});

					console.log(floorNumbers);
					console.log(globalFloors);

					if (floorNumbers.length > 0) {
						const floorSection =
							document.getElementById("show-floors");
						if (floorSection.classList.contains("hidden")) {
							floorSection.classList.remove("hidden");
						}

						checkboxesId = [];

						floorNumbers.forEach((e) => {
							const div = document.createElement("div");
							const checkbox = document.createElement("input");
							const label = document.createElement("label");

							label.innerText = `Floor ${e}`;
							label.htmlFor = `floor-${e}-checkbox`;
							checkbox.type = "checkbox";
							checkbox.checked = true;
							checkbox.id = `floor-${e}-checkbox`;

							checkboxesId.push(`floor-${e}-checkbox`);
							div.appendChild(checkbox);
							div.appendChild(label);

							checkbox.addEventListener("change", (e) => {
								toggleFloors(aggregatePoints);
								spawnLabel();
							});

							floorSection.appendChild(div);
						});
					}

					//globalFloorsAggregated contains average positioned circle of multicamera points
					const globalFloorsCopy = Object.assign(globalFloors);
					globalFloorsAggregated =
						getAveragedCircles(globalFloorsCopy);

					if (document.getElementById("aggregate-points-parent")) {
						document
							.getElementById("aggregate-points-parent")
							.remove();
					}
					const editOptions = document.getElementById("edit-options");
					const div = document.createElement("div");
					div.id = "aggregate-points-parent";
					const aggregateOptionsCheckbox =
						document.createElement("input");
					const label = document.createElement("label");
					div.classList.add("col-span-2");
					div.classList.add("mt-2");
					label.innerText = `Aggregate points`;
					label.classList.add("ml-1");
					label.htmlFor = `aggregate-points`;
					aggregateOptionsCheckbox.type = "checkbox";
					aggregateOptionsCheckbox.checked = false;
					aggregateOptionsCheckbox.id = `aggregate-points`;
					div.appendChild(aggregateOptionsCheckbox);
					div.appendChild(label);
					editOptions.appendChild(div);

					aggregateOptionsCheckbox.addEventListener("change", (e) => {
						aggregatePoints = e.target.checked;
						toggleFloors(aggregatePoints);
						spawnLabel();
					});

					// Scale bounding box to fit within the SVG frame
					if (scaleToFit) {
						const globalCircle = globalFloors.map(
							(item) => item.circle,
						);
						const globalAggregateCircle =
							globalFloorsAggregated.map((item) => item.circle);
						const totalCircles = [
							...globalCircle,
							...globalAggregateCircle,
						];
						scaleBoundingBoxToFitInstance(
							svgContainer.querySelector("svg"),
							totalCircles,
						);
					}
					// scaleBoundingBoxToFit(svgContainer.querySelector("svg"));
				};
				reader.readAsText(file);
			}
		}

		function labelToggle() {
			if(!document.getElementById("showLabelsDiv")){
				//Add Toggle Label Checkbox
				const showLabelsDiv = document.createElement("div");
				showLabelsDiv.id = "showLabelsDiv";
				const showLabelsToggle = document.createElement("input");
				const showLabelsLabel = document.createElement("label");
				showLabelsLabel.textContent = "Toggle Labels";
				showLabelsLabel.setAttribute("for", "showLabelsToggle");

				showLabelsToggle.type = "checkbox";
				showLabelsToggle.style.padding = "0.5em";
				showLabelsToggle.style.height = "fit-content";
				showLabelsToggle.id = "showLabelsToggle";

				showLabelsDiv.appendChild(showLabelsToggle);
				showLabelsDiv.appendChild(showLabelsLabel);
				document.getElementById("editor-button-container").appendChild(showLabelsDiv);

				showLabelsToggle.addEventListener("change", (e) => {
					if (e.target.checked) {
						spawnLabel();
					} else {
						killLabels();
					}
				});

				showLabelsToggle.checked = true
				spawnLabel()
			}

		}

		const imageList = [];

		function uploadImages(e) {
			const files = Array.from(e.target.files);

			const readFile = (file) => {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onload = (data) =>
						resolve({ name: file.name, data: data.target.result });
					reader.onerror = (error) => reject(error);
					reader.readAsDataURL(file);
				});
			};

			if (
				document
					.getElementById("image-carousel-container")
					.classList.contains("hidden")
			) {
				document
					.getElementById("image-carousel-container")
					.classList.remove("hidden");
				document
					.getElementById("image-carousel-container")
					.classList.add("flex");
			}

			Promise.all(Array.from(files).map(readFile))
				.then((results) => {
					imageList.splice(0, imageList.length);
					imageList.push(...results);
					const imageListCarousel = document.getElementById(
						"image-list-carousel",
					);
					imageListCarousel.innerHTML = "";
					imageList.forEach((image) => {
						const listItem = document.createElement("li");
						listItem.style.height = "100%";
						const imageElement = document.createElement("img");
						imageElement.src = image.data;
						imageElement.style.height = "60px";
						// imageElement.setAttribute("data-name", image.name)
						listItem.appendChild(imageElement);
						imageListCarousel.appendChild(listItem);
					});
					previewBackplate(
						document
							.getElementById("svg-container")
							.querySelector("svg"),
					);
				})
				.catch((error) =>
					console.error("Error loading images:", error),
				);
		}

		function previewBackplate(parentSVG) {
			const listeners = [];
			listeners.forEach((e) => {
				removeEventListener("hover", e);
			});



			let previewerInstance = document.getElementById("image-previewer");
			if (!previewerInstance) {
				const newPreviewer = document.createElement("div");
				const previewerImg = document.createElement("img");
				const previewerText = document.createElement("p");
				newPreviewer.id = "image-previewer-container";
				newPreviewer.style.padding = "5px";
				newPreviewer.style.position = "fixed";
				newPreviewer.style.display = "flex";
				newPreviewer.style.flexDirection = "flex-column";
				newPreviewer.style.backgroundColor = "#cccccccc";
				newPreviewer.style.borderRadius = "10px";
				newPreviewer.style.alignContent = "align-center";
				newPreviewer.style.justifyContent = "justify-center";
				newPreviewer.style.justifyItems = "justify-center";
				newPreviewer.style.transform = "translate(-50%, -113%)";
				newPreviewer.style.width = "310px";
				previewerImg.id = "image-previewer-image";
				previewerImg.style.width = "300px";
				previewerImg.style.marginBottom = "10px";
				newPreviewer.appendChild(previewerImg);
				previewerText.id = "image-previewer-text";
				previewerText.style.fontSize = "12px";
				newPreviewer.appendChild(previewerText);
				document.querySelector("body").appendChild(newPreviewer);
			}

			parentSVG.querySelectorAll("path").forEach((path) => {
				const listener = path.addEventListener("mouseover", (e) => {
					document.getElementById(
						"image-previewer-container",
					).style.display = "block";
					const textReplacement = document.getElementById("text-replacement").value
					console.log(textReplacement)
					const selectedImage = imageList.filter((image) => {
						console.log(e.target.id
									.split("_")
									.join("")
									.split("-")
									.join("")
									.replace(textReplacement, ""))
					console.log(image.name
							.split("_")
							.join("")
							.split("-")
							.join(""))	
							return image.name
							.split("_")
							.join("")
							.split("-")
							.join("")
							.includes(
								e.target.id
									.split("_")
									.join("")
									.split("-")
									.join("")
									.replace(textReplacement, ""),
							)
					}

					)[0];
								
					if (selectedImage) {
						// console.log(selectedImage)
						document.getElementById("image-previewer-image").src =
							selectedImage.data;
						document.getElementById(
							"image-previewer-text",
						).innerHTML = selectedImage.name;
					} else {
						document.getElementById("image-previewer-image").src =
							"";
						document.getElementById(
							"image-previewer-text",
						).innerHTML = "";
					}
				});

				const listener2 = path.addEventListener("mouseout", (e) => {
					document.getElementById(
						"image-previewer-container",
					).style.display = "none";
				});

				listeners.push(listener);
				listeners.push(listener2);
			});
			globalSvgContainer.addEventListener("mousemove", (e) => {
				document.getElementById(
					"image-previewer-container",
				).style.left = `${e.clientX}px`;
				document.getElementById("image-previewer-container").style.top =
					`${e.clientY}px`;
			});
		}

		fileInput.addEventListener("change", () => {
			handleFileChange(fileInput.files[0]);
		});

		document
			.getElementById("updateValues")
			.addEventListener("click", (e) => {
				updateValuesList.set([]);
				currentValuesList.set([]);
				updateValuesModal.set(false);
				console.log("UpdateValues clicked");
			});

		document
			.getElementById("updateValues")
			.addEventListener("change", () => {
				updateValues(document.getElementById("updateValues").files[0]);
			});

		var animationTimeout;
		document.body.addEventListener("dragover", (e) => {
			event.preventDefault(); // Prevent the default behavior
			document.querySelector(".drag-drop-prompt").classList.add("appear");
			if (animationTimeout != null) {
				clearTimeout(animationTimeout);
				animationTimeout = setTimeout((e) => {
					document
						.querySelector(".drag-drop-prompt")
						.classList.remove("appear");
				}, 500);
			} else {
				animationTimeout = setTimeout((e) => {
					document
						.querySelector(".drag-drop-prompt")
						.classList.remove("appear");
				}, 500);
			}
		});

		document.body.addEventListener("dragend", (e) => {
			event.preventDefault(); // Prevent the default behavior
			document
				.querySelector(".drag-drop-prompt")
				.classList.remove("appear");
		});

		document.body.addEventListener("drop", (e) => {
			e.preventDefault();
			console.log(e)
			console.log(e.dataTransfer.files[0]);
			handleFileChange(e.dataTransfer.files[0]);
			document
				.querySelector(".drag-drop-prompt")
				.classList.remove("appear");
		});

		//To check globally if is typing
		document.addEventListener("focusin", (event) => {
			if (
				event.target.tagName === "INPUT" ||
				event.target.tagName === "TEXTAREA"
			) {
				typing = true;
				console.log("Input is active");
			}
		});

		document.addEventListener("focusout", (event) => {
			if (
				event.target.tagName === "INPUT" ||
				event.target.tagName === "TEXTAREA"
			) {
				typing = false;
				console.log("Input is not active");
			}
		});

		document.addEventListener("keydown", (e) => {
			if (e.key == "Escape") {
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.classList.remove("svg-tool-selected");
					e.style.fill = "";
					groupGlobal = [];
					document.querySelectorAll("#group").value = "";
				});

				if (multiSelect) {
					groupGlobal.forEach((e) => {
						e.classList.remove("svg-tool-selected");
						e.style.fill = "";
					});

					multiSelect = false;
				}
			}

			if (
				e.key === "a" &&
				e.ctrlKey &&
				document.activeElement.tagName === "INPUT" &&
				document.activeElement.type === "text"
			) {
				document.activeElement.select();
				console.log(document.activeElement);
			}

			if (e.key == "Shift") {
				multiSelect = true;
			}

			if (e.key == "Enter") {
				document.querySelector("#set-name").click();
			}

			if (e.key == "q") {
				document.querySelector("#set-unit").click();
			}

			if (e.key == "Delete") {
				document.querySelector("#delete-point").click();
			}

			if (event.key === "ArrowLeft") {
				if (!typing) {
					rotateCircles(-45);
				}
			} else if (event.key === "ArrowRight") {
				if (!typing) {
					rotateCircles(45);
				}
			}

			if (e.key == "l") {
				console.log(e.key);
				if (document.getElementById("showLabelsToggle")) {
					document.getElementById("showLabelsToggle").click();
				}
			}

			if (e.ctrlKey && e.key === "a") {
				e.preventDefault(); // Prevent the default browser select all behavior

				const svgElement = globalSvgContainer.querySelector("svg");
				if (svgElement != null) {
					// Select all circles in the SVG
					groupGlobal = Array.from(
						svgElement.querySelectorAll("circle"),
					);

					groupGlobal.forEach((e) => {
						e.classList.add("svg-tool-selected");
						e.style.fill = "#ff0000";
					});

					// Indicate multi-selection mode
					multiSelect = true;

					console.log("All circles selected:", groupGlobal);
				}
			}

			if (e.key == "Delete") {
				document.querySelector("delete-point").click();
				spawnLabel();
			}

			spawnLabel();
		});

		window.addEventListener("resize", (e) => {
			spawnLabel();
		});

		function setUnit() {
			for (var i = 0; i < groupGlobal.length; i++) {
				console.log(i);
				groupGlobal[i].setAttribute("unit-attribute", pad(i + 1));
			}

			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				if (
					document.querySelectorAll(".svg-tool-selected").length < 2
				) {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.setAttribute(
						"unit-attribute",
						document.getElementById("unit").value,
					);
					if (
						e.hasAttribute("group-attribute") &&
						e.hasAttribute("unit-attribute")
					) {
						e.id =
							e.getAttribute("group-attribute") +
							"_" +
							e.getAttribute("unit-attribute");
					}
				} else {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.id =
						e.getAttribute("group-attribute") +
						"_" +
						e.getAttribute("unit-attribute");
				}
			});
		}

		function rotateCircles(angle) {
			const svgElement = document.querySelector("#svg-container svg");
			const circles = svgElement.querySelectorAll("circle");

			if (circles.length === 0) return;

			let minX = Infinity,
				maxX = -Infinity,
				minY = Infinity,
				maxY = -Infinity;

			// Calculate bounding box
			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));
				const r = parseFloat(circle.getAttribute("r"));

				if (cx - r < minX) minX = cx - r;
				if (cx + r > maxX) maxX = cx + r;
				if (cy - r < minY) minY = cy - r;
				if (cy + r > maxY) maxY = cy + r;
			});

			const bboxCenterX = minX + (maxX - minX) / 2;
			const bboxCenterY = minY + (maxY - minY) / 2;

			const radians = (angle * Math.PI) / 180;

			// Rotate each circle around the bounding box center
			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));

				const dx = cx - bboxCenterX;
				const dy = cy - bboxCenterY;

				const newCx =
					bboxCenterX +
					dx * Math.cos(radians) -
					dy * Math.sin(radians);
				const newCy =
					bboxCenterY +
					dx * Math.sin(radians) +
					dy * Math.cos(radians);

				circle.setAttribute("cx", newCx.toFixed(4));
				circle.setAttribute("cy", newCy.toFixed(4));
			});
		}

		function getAveragedCircles(data) {
			console.log("data");
			console.log(data);
			const grouped = {};
			data.forEach((item) => {
				const { floor, circle } = item;
				console.log(circle.attributes[1].textContent);
				const idLocal = circle.getAttribute("id");
				const cxLocal = parseFloat(circle.attributes[1].value);
				const cyLocal = parseFloat(circle.attributes[2].value);
				console.log({ floor, circle, cxLocal, cyLocal });

				// Grouping by floor and id
				if (!grouped[floor]) {
					grouped[floor] = {};
				}
				if (!grouped[floor][idLocal]) {
					grouped[floor][idLocal] = {
						totalCx: 0,
						totalCy: 0,
						count: 0,
						idLocal,
					};
				}

				// Summing cx, cy positions
				grouped[floor][idLocal].totalCx += cxLocal;
				grouped[floor][idLocal].totalCy += cyLocal;
				grouped[floor][idLocal].count += 1;
			});

			console.log(grouped);

			const averagedCircles = [];

			for (const floor in grouped) {
				for (const id in grouped[floor]) {
					const { totalCx, totalCy, count } = grouped[floor][id];
					const avgCx = totalCx / count;
					const avgCy = totalCy / count;

					// Clone the original DOM element and update its attributes
					const originalCircle = data.find(
						(item) => item.circle.getAttribute("id") === id,
					).circle;
					const newCircle = originalCircle.cloneNode(true);
					newCircle.setAttribute("cx", avgCx);
					newCircle.setAttribute("cy", avgCy);

					averagedCircles.push({
						floor,
						circle: newCircle,
					});
				}
			}

			return averagedCircles;
		}

		function toggleFloors(aggregated) {
			const globalG = globalSvgContainer.querySelector("g");
			const localFloors = globalFloors;
			const localFloorsAggregated = globalFloorsAggregated;

			checkboxesId.forEach((i) => {
				const floor = i.split("-")[1];
				if (aggregated) {
					console.log(globalFloorsAggregated);
					localFloors.forEach((e) => {
						e.circle.remove();
					});
					const selectedFloorCirclesAggregated =
						localFloorsAggregated.filter((e) =>
							e.floor.includes(floor),
						);

					if (document.getElementById(i).checked) {
						selectedFloorCirclesAggregated.forEach((e) => {
							globalG.appendChild(e.circle);
						});
						console.log({ Added: selectedFloorCirclesAggregated });
					} else {
						selectedFloorCirclesAggregated.forEach((e) => {
							e.circle.remove();
						});
						console.log({
							Removed: selectedFloorCirclesAggregated,
						});
					}
				} else {
					localFloorsAggregated.forEach((e) => {
						e.circle.remove();
					});
					const selectedFloorCircles = localFloors.filter((e) =>
						e.floor.includes(floor),
					);

					if (document.getElementById(i).checked) {
						selectedFloorCircles.forEach((e) => {
							globalG.appendChild(e.circle);
						});
						console.log({ Added: selectedFloorCircles });
					} else {
						selectedFloorCircles.forEach((e) => {
							e.circle.remove();
						});
						console.log({ Removed: selectedFloorCircles });
					}
				}
			});
		}

		//Add zero to single digit
		function pad(d) {
			return d < 10 ? "0" + d.toString() : d.toString();
		}

		document.addEventListener("keydown", (e) => {
			if (e.key == "Escape") {
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.classList.remove("svg-tool-selected");
					e.style.fill = "";
					groupGlobal = [];
					document.querySelectorAll("#group").value = "";
				});
			}

			if (e.key == "Shift") {
				multiSelect = true;
			}
		});

		document.addEventListener("keyup", (e) => {
			if (e.key == "Shift") {
				multiSelect = false;
				console.log(multiSelect);
			}
		});

		document
			.getElementById("hide-toggle")
			.addEventListener("click", (e) => {
				if (
					document.getElementById("id-list").style.display == "none"
				) {
					document.getElementById("id-list").style.display = "block";
					document
						.getElementById("hide-toggle")
						.classList.remove("expand");
				} else {
					document.getElementById("id-list").style.display = "none";
					document
						.getElementById("hide-toggle")
						.classList.add("expand");
				}
			});

		// document.getElementById("export-csv").addEventListener("click", (e) => {
		// 	exportCSV();
		// });

		// document.getElementById("remove").addEventListener("click", (e) => {
		// 	removeData();
		// });

		// document
		// 	.getElementById("export-csv-count")
		// 	.addEventListener("click", (e) => {
		// 		exportCSVId();
		// 	});

		document.getElementById("export").addEventListener("click", (e) => {
			exportSVG();
		});

		document
			.getElementById("export-csv-layer")
			.addEventListener("click", (e) => {
				exportFloorNamePosition();
			});

		document
			.getElementById("export-csv-layer-2048")
			.addEventListener("click", (e) => {
				exportFloorNamePosition2048();
			});

		//SVG Conversion
		function exportSVG() {
			const file = fileNameGlobal;
			var svg = document
				.querySelector("#svg-container")
				.querySelector("svg");
			document.querySelectorAll("[id]").forEach((e) => {
				const str = e.getAttribute("id");
				e.setAttribute("data-name", str.replace(/\s+/g, "_"));
			});
			document.querySelectorAll("[group-attribute]").forEach((e) => {
				e.removeAttribute("group-attribute");
			});
			document.querySelectorAll("[unit-attribute]").forEach((e) => {
				e.removeAttribute("unit-attribute");
			});
			if (svg) {
				var serializer = new XMLSerializer();
				var svgString = serializer.serializeToString(svg);
				var blob = new Blob([svgString], { type: "image/svg+xml" });
				var url = URL.createObjectURL(blob);
				var link = document.createElement("a");
				link.href = url;
				link.download =
					file.replace(/\.[^/.]+$/, "") + "_" + type + ".svg";
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			} else {
				alert("Import and SVG to start!");
			}
		}
		//SVG Conversion
		function exportFloorNamePosition() {
			// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
			if (document.querySelector("#svg-container").querySelector("svg")) {
				const parser = new DOMParser();
				var doc = null;
				doc = document
					.querySelector("#svg-container")
					.querySelector("svg");

				const layers = Array.from(doc.querySelectorAll("g"))
					.map((layer, index) => {
						if (
							layer.getAttribute("id") != null ||
							layer.getAttribute("id") != undefined
						) {
							if (
								layer.getAttribute("id").toLowerCase() !=
								"reference"
							) {
								console.log("Layer ID is found");
								const id = layer
									.getAttribute("id")
									.replace("_", "");
								const children = Array.from(layer.children).map(
									(child) => {
										console.log(child);
										const childId = child.getAttribute(
											"data-name",
										)
											? decodeHtml(
													child.getAttribute(
														"data-name",
													),
												)
											: child.getAttribute("id");

										const x = child.getAttribute("cx");
										const y = child.getAttribute("cy");
										return { id: childId, x, y };
									},
								);
								console.log(id, children);
								return { id, children };
							}
						} else {
							console.log("Layer ID is null");
							console.log(layer);
							const id = `item-${index}`;
							const children = Array.from(layer.children).map(
								(child) => {
									console.log(child);
									const childId = child.getAttribute(
										"data-name",
									)
										? decodeHtml(
												child.getAttribute("data-name"),
											)
										: child.getAttribute("id");

									const x = child.getAttribute("cx");
									const y = child.getAttribute("cy");
									return { id: childId, x, y };
								},
							);
							console.log(id, children);
							return { id, children };
						}
					})
					.filter((layer) => layer !== undefined);

				var csv;
				if (layers.length < 2) {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				} else {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				}

				const file = fileNameGlobal;
				var blob = new Blob([csv], { type: "text/csv" });
				var link = document.createElement("a");
				link.href = URL.createObjectURL(blob);
				link.download =
					file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "");
				(".csv");
				link.click();
			} else {
				alert("Import an SVG to start!");
			}
		}

		//SVG Conversion
		function exportFloorNamePosition2048() {
			// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
			if (document.querySelector("#svg-container").querySelector("svg")) {
				const parser = new DOMParser();
				var doc = null;

				doc = document
					.querySelector("#svg-container")
					.querySelector("svg");
				const height = doc.viewBox.baseVal.height;
				const width = doc.viewBox.baseVal.width;

				const layers = Array.from(doc.querySelectorAll("g"))
					.map((layer) => {
						if (
							layer.getAttribute("id").toLowerCase() !=
							"reference"
						) {
							const id = layer
								.getAttribute("id")
								.replace("_", "");
							const children = Array.from(layer.children).map(
								(child) => {
									console.log(child);
									const childId = child.getAttribute(
										"data-name",
									)
										? decodeHtml(
												child.getAttribute("data-name"),
											)
										: child.getAttribute("id");

									const x =
										(child.getAttribute("cx") / width) *
										2048;
									const y =
										(child.getAttribute("cy") / height) *
										2048;
									return { id: childId, x, y };
								},
							);
							console.log(id, children);
							return { id, children };
						}
					})
					.filter((layer) => layer !== undefined);

				var csv;
				if (layers.length < 2) {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				} else {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				}

				console.log(csv);

				const file = fileNameGlobal;
				var blob = new Blob([csv], { type: "text/csv" });
				var link = document.createElement("a");
				link.href = URL.createObjectURL(blob);
				link.download =
					file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "");
				(".csv");
				link.click();
			} else {
				alert("Import an SVG to start!");
			}
		}

		function decodeHtml(html) {
			var txt = document.createElement("textarea");
			txt.innerHTML = html;
			return txt.value;
		}

		document.getElementById("flip-x").addEventListener("click", (e) => {
			
			flipped = !flipped;

			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");
			const width = doc.viewBox.baseVal.width;
			const layers = Array.from(doc.querySelectorAll("g")).map(
				(layer) => {
					// if(layer.getAttribute("id").toLowerCase() != 'reference'){
					// const id = layer.getAttribute("id").replace('_', "");
					const children = Array.from(layer.children).map((child) => {
						if (child.tagName == "image") {
							// child.getAttribute("transform")
							// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
							if (!child.hasAttribute("flipped")) {
								child.setAttribute("flipped", "");
								child.style.transform =
									"scaleX(-1) translate(-100%, 0)";
							} else {
								child.removeAttribute("flipped");
								child.style.transform =
									"scaleX(1) translate(0, 0)";
							}

							console.log(child.style.scale);
						} else {
							const x = child.getAttribute("cx");
							child.setAttribute("cx", width - x);
						}
					});
					// }
				},
			);
			spawnLabel()
		});

		document.getElementById("flip-y").addEventListener("click", (e) => {
			// var svg = document.querySelector("#svg-container").querySelector("svg");
			// svg.style.scale = "-1 1"
			flipped = !flipped;

			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");
			const height = doc.viewBox.baseVal.height;
			const layers = Array.from(doc.querySelectorAll("g")).map(
				(layer) => {
					// if(layer.getAttribute("id").toLowerCase() != 'reference'){
					// const id = layer.getAttribute("id").replace('_', "");
					const children = Array.from(layer.children).map((child) => {
						if (child.tagName == "image") {
							// child.getAttribute("transform")
							// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
							if (!child.hasAttribute("flipped")) {
								child.setAttribute("flipped", "");
								child.style.transform =
									"scaleY(-1) translate(0, -100%)";
							} else {
								child.removeAttribute("flipped");
								child.style.transform =
									"scaleX(1) translate(0, 0)";
							}

							console.log(child.style.scale);
						} else {
							const y = child.getAttribute("cy");
							child.setAttribute("cy", height - y);
						}
					});
					// }
				},
			);
			spawnLabel();
		});

		function spawnLabel() {
			killLabels(true);
			if (document.getElementById("showLabelsToggle")) {
				if (document.getElementById("showLabelsToggle").checked) {
					var circles = [];
					const group = globalSvgContainer
						.querySelector("svg")
						.querySelector("g");
					console.log(
						globalSvgContainer
							.querySelector("svg")
							.querySelector("g"),
					);
					if (!group) {
					} else if (group instanceof SVGGElement) {
						circles = [].slice.call(
							group.getElementsByTagName("circle"),
						);
					}
					console.log(circles);

					const svgContainer =
						document.getElementById("svg-container");
					const { scaleX, scaleY } = calculateSensitivity(
						globalSvgContainer.querySelector("svg"),
					);
					const { width } = globalSvgContainer
						.querySelector("svg")
						.getBoundingClientRect();
					const labelDiv = document.createElement("div");
					labelDiv.setAttribute("id", "labelDiv");
					labelDiv.style.width = "4096px";
					labelDiv.style.height = "4096px";
					labelDiv.style.position = "absolute";
					labelDiv.style.transform = `scale(${1 / scaleX})`;
					labelDiv.style.left = `-${2048 - 4096 / scaleY / 2}px`;
					labelDiv.style.top = `-${2048 - 4096 / scaleY / 2}px`;
					labelDiv.style.pointerEvents = "none";

					const createParagraph = (className, text, display) => {
						const p = document.createElement("p");
						Object.assign(p.style, {
							color: "white",
							margin: "0",
							pointerEvents: "none",
							lineHeight: "1.5em",
							display,
						});
						p.className = className;
						p.textContent = text;
						return p;
					};

					const createDiv = (e) => {
						const div = document.createElement("div");
						div.setAttribute(
							"data-fullname",
							e.getAttribute("data-fullname"),
						);
						Object.assign(div.style, {
							position: "absolute",
							left: `${e.getAttribute("cx")}px`,
							top: `${e.getAttribute("cy")}px`,
							transform: "translate(-50%, 1%)",
							backgroundColor: "rgba(0, 0, 0, 0.5)",
							border: "2px solid rgba(255, 255, 255, 0.1)",
							padding: "4px 24px",
							borderRadius: "0.75rem",
							marginBottom: "0.25rem",
							zIndex: "10",
							backdropFilter: "blur(10px)",
							pointerEvents: "none",
							cursor: "pointer",
							textAlign: "center",
							fontSize: "2.25rem",
						});

						const idText = e.id
							.replace(/([A-Z0-9])/g, " $1")
							.trim();
						div.appendChild(
							createParagraph("text-normal", idText, "block"),
						);
						div.appendChild(
							createParagraph("text-hover", idText, "none"),
						);

						div.onmouseover = () => toggleHover(div, true);
						div.onmouseout = () => toggleHover(div, false);
						return div;
					};

					const toggleHover = (div, isHovered) => {
						div.style.borderColor = isHovered
							? "rgba(255, 255, 255, 1)"
							: "rgba(255, 255, 255, 0.1)";
						div.querySelector(".text-normal").style.display =
							isHovered ? "none" : "block";
						div.querySelector(".text-hover").style.display =
							isHovered ? "block" : "none";
					};

					circles.forEach((e) => {
						const div = createDiv(e);
						labelDiv.appendChild(div);
						svgContainer.appendChild(labelDiv);
					});
				}
			}
		}

		function killLabels(toggleChecked?) {
			if (document.getElementById("labelDiv")) {
				document.getElementById("labelDiv").remove();
				if (!toggleChecked) {
					document.getElementById("showLabelsToggle").checked = false;
				} else {
					// console.log("toggleChecked true, retaining checked state")
				}
			} else {
				// console.log("labelDiv not found");
			}
		}

		function updateStates(circles, transformedLines, group) {
			if (!group) {
			} else if (group instanceof SVGGElement) {
				console.log("Is group");
				var thisCircles = [].slice.call(
					group.getElementsByTagName("circle"),
				);

				updateValuesModal.set(true);
				console.log("Set updateValuesModal");
				updateValuesList.set(transformedLines);
				currentValuesList.set(thisCircles);
			}
		}

		function updateValues(file) {
			var circles = [];
			const group = globalSvgContainer
				.querySelector("svg")
				.querySelector("g");
			console.log(group);

			const reader = new FileReader();
			reader.onload = (event) => {
				const contents = event.target.result;
				const lines = contents.trim().split("\n");

				// Check the number of columns and decide to transform
				const firstLineFields = lines[0].split(",");
				let transformedLines = lines;

				if (firstLineFields.length > 3) {
					//Camera CSV
					transformedLines = lines.map((line) => {
						const fields = line.split(",");
						const [name, x, y, z] = fields;
						const cleanedName = name.split("_")[1]
							? name.split("_")[1]
							: undefined;
						if (cleanedName) {
							return { name: cleanedName, x: -y, y: -x }; // Swap x and y
						}
					});
					updateStates(circles, transformedLines, group);
				} else {
					//Floorplan CSV
					transformedLines = lines.map((line) => {
						const fields = line.split(",");
						const [name, x, y] = fields;
						const cleanedName = name.split("_")[1]
							? name.split("_")[1]
							: undefined;
						if (cleanedName) {
							return { name: cleanedName, x: x, y: y }; // Swap x and y
						}
					});
					updateStates(circles, transformedLines, group);
				}
				spawnLabel();
			};
			reader.readAsText(file);
		}

		function removeData() {
			const doc = document.querySelector("#svg-container");
			const xml = `<?xml version="1.0" encoding="UTF-8"?>`;
			const defs = doc.querySelector("defs");
			const maskParent = document.querySelector("defs");
			const maskChild = maskParent.children;
			const maskShape = Array.from(maskChild).map((e) => {
				const shape = e.children[0];
				if (shape) {
					if (
						shape.nodeName == "polygon" ||
						shape.nodeName == "path"
					) {
						const className = shape.classList[0];
						shape.classList.remove(className);
						return shape;
					}
				}
			});

			var kvPair = Object.assign(
				{},
				...Array.from(document.styleSheets[1].cssRules).map((e) => {
					// return e.selectorText
					// return e.style.clipPath
					if (e.style.clipPath) {
						var str = e.style.clipPath;
						var regex = /#([\w-]+)/; // \w matches any alphanumeric character
						var match = regex.exec(str); // exec returns an array of matches
						var id = "#" + match[1]; // the first capture group is the ID
						return { [e.selectorText.replace(/[-.]/g, "")]: id };
					}
				}),
			);

			// kvPair = kvPair.filter(element => {
			//     return element !== undefined;
			// })
			var classes = [
				"cls-8158",
				"cls-8167",
				"cls-8163",
				"cls-8166",
				"cls-8165",
			];
			console.log(kvPair);
			const classValues = document
				.getElementById("myClasses")
				.value.replace(/\s/g, "");
			if (classValues) {
				classes = classValues.split(",");
			}

			var units = [];
			if (classes) {
				classes.forEach((e) => {
					doc.querySelectorAll(`.${e}`).forEach((i) => {
						console.log(i);
						const parentClass = String(
							i.parentElement.classList[0],
						);
						const refId = kvPair[parentClass.replace(/[-.]/g, "")];
						console.log(parentClass);
						const refEl = doc
							.querySelector("defs")
							.querySelector(refId);
						var child;
						if (refEl) {
							console.log(refEl);
							child = refEl.children[0];
							child.classList.remove(child.classList[0]);
							child.classList.add(e);
							units.push(child);
							return child;
						}
					});
				});
			}

			console.log("units");
			console.log(units);

			const output = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"g",
			);

			var svg = doc.querySelector("svg");
			console.log(svg);
			while (svg.firstChild) {
				svg.removeChild(svg.firstChild);
			}

			svg.append(defs);
			units.forEach((e) => {
				console.log(e);
				svg.append(e);
			});
		}

		function getStyleSheet(unique_title) {
			for (const sheet of document.styleSheets) {
				if (sheet.title === unique_title) {
					return sheet;
				}
			}
		}
	</script>
</html>
