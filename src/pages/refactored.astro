---
import UpdateValuesModal from "../components/UpdateValuesModal.astro";
import Tutorial from "../components/Tutorial.astro";
import "../styles.css";
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Astro</title>
		<link rel="stylesheet" href="/fonts/poppins.css" />
		<style>
			/* Floor toggle drag styles */
			[data-project-floor] {
				transition: background-color 0.15s ease !important;
			}

			[data-project-floor]:hover {
				background-color: rgba(255, 255, 255, 0.1) !important;
			}

			[data-project-floor].dragging {
				background-color: rgba(0, 150, 255, 0.3) !important;
			}

			/* Toast Notifications */
			.toast {
				position: fixed;
				bottom: 24px;
				right: 24px;
				padding: 16px 24px;
				background-color: #333;
				color: white;
				border-radius: 4px;
				box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
				opacity: 0;
				transform: translateY(20px);
				transition: all 0.3s;
				pointer-events: none;
				max-width: 400px;
				z-index: 1000;
			}

			.toast.show {
				opacity: 1;
				transform: translateY(0);
				pointer-events: auto;
			}

			.toast.success {
				background-color: #28a745;
			}

			.toast.error {
				background-color: #dc3545;
			}

			.toast.warning {
				background-color: #ffc107;
				color: #000;
			}
		</style>
	</head>
	<body class="">
		<div class="drag-drop-prompt">
			<div class="animated-border">
				<h1>Drag and Drop Here</h1>
			</div>
		</div>
		<UpdateValuesModal />
		<main class="toolsets" style="display: flex">
			<div class="toolset-section">
				<a
					href="/"
					class="flex w-fit border-2 pl-2 pr-2 p-1 mb-2 text-center rounded-md content-center hover:bg-neutral-100"
				>
					<div class="align-center content-center">
						<svg
							xmlns="http://www.w3.org/2000/svg"
							fill="none"
							viewBox="0 0 24 24"
							stroke-width="1.5"
							stroke="currentColor"
							class="size-5"
						>
							<path
								stroke-linecap="round"
								stroke-linejoin="round"
								d="m2.25 12 8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25"
							></path>
						</svg>
					</div>

					<p class="ml-2">Home</p>
				</a>
				<section class="container">
					<input
						class="dropdown"
						id="custom-formatting"
						name="formatting"
						type="checkbox"
						style="display: none"
					/>
					<label for="custom-formatting"
						>Custom SVG ID Formatting <span class="arrow">^</span
						></label
					>

					<div class="toggle">
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								id="underscore"
								value="underscore"
							/>Underscore on Last Identifier (NHXX-XX<b>_</b>XX)
						</div>

						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="dash"
								id="dash"
							/>Dash on Last Identifier (NHXX-XX<b>-</b>XX)
						</div>
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="none"
								id="none"
								checked="checked"
							/>None
						</div>
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="fullUnderscore"
								id="fullUnderscore"
							/>Full Underscore
						</div>
					</div>
				</section>

				<section class="container">
					<!-- <h3>2. Then, Import Files here</h3> -->
					<!-- <button class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300" class="button-style">Import </button> -->
					<label for="myFile" class="button-style"
						>Import 						<svg
							xmlns="http://www.w3.org/2000/svg"
							width="24"
							height="24"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-linecap="round"
							stroke-linejoin="round"
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="17 8 12 3 7 8" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="3"
								y2="15"
								stroke-width="2"></line>
						</svg></label
					>
					<input
						type="file"
						class="input-style"
						id="myFile"
						name="filename"
						style="display:none; "
					/>
					<label
						for="updateValues"
						class="flex bg-[#ffffff] hover:bg-[#dddddd] items-center justify-center border border-neutral-700 rounded-[4px] p-0.5 mt-1.5 text-sm text-[#333333] align-center cursor-pointer"
						>Update Names
						<svg
							class="ml-1"
							xmlns="http://www.w3.org/2000/svg"
							width="16"
							height="16"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-linecap="round"
							stroke-linejoin="round"
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="17 8 12 3 7 8" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="3"
								y2="15"
								stroke-width="2"></line>
						</svg></label
					>
					<input
						type="file"
						class="input-style"
						id="updateValues"
						name="filename"
						accept="text/csv"
						style="display:none"
					/>
				</section>

				<section class="container">
					<div
						class="sub-item"
						style="display: flex; flex-direction: column; margin-bottom: 10px;"
					>
						<p class="w-full text-xs m-0 p-0">Edit Points:</p>
						<div
							class="grid grid-cols-2 button-gap gap-1 flex-start"
							id="edit-options"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="flip-x"
							>
								Flip X</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="flip-y"
							>
								Flip Y</button
							>
						</div>
						<p class="w-full text-xs m-0 mt-2 p-0">Edit Canvas:</p>
						<div
							class="grid grid-cols-2 button-gap gap-1 flex-start"
							id="canvas-edit-options"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="canvas-flip-x"
							>
								Canvas Flip X</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="canvas-flip-y"
							>
								Canvas Flip Y</button
							>
							<button
								id="reset-flip"
								class="w-full flex mb-0.5 text-xs p-1 cursor-pointer rounded bg-gray-100 hover:bg-gray-300 opacity-50 col-span-2 hidden"
								>Reset Flip</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="canvas-rotate-left"
							>
								Rotate Left</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="canvas-rotate-right"
							>
								Rotate Right</button
							>
							<button
								id="reset-rotation"
								class="w-full flex mb-0.5 text-xs p-1 cursor-pointer rounded bg-gray-100 hover:bg-gray-300 opacity-50 col-span-2 hidden"
								>Reset Rotation</button
							>
						</div>
					</div>

					<div
						class="sub-item hidden"
						id="show-floors"
						style="display: flex; flex-direction: column; margin-bottom: 10px;"
					>
						<p style="padding: 0 0px 10px 0em; margin: 0px;">
							Floors:
						</p>
					</div>

					<div
						class="sub-item"
						style="display: flex; flex-direction: column; margin-bottom: 10px;"
					>
						<input
							id="group"
							type="text"
							placeholder="Group"
							style="margin-bottom: 10px;"
							class="input-style"
						/>

						<input
							id="unit"
							type="text"
							placeholder="Unit"
							class="input-style"
						/>
						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="set-name">Set</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="set-unit">Apply Units</button
							>
						</div>
					</div>

					<div
						class="sub-item"
						style="display: flex; flex-direction: column;"
					>
						<p style="padding: 0 0px 10px 0em; margin: 0px;">
							Point Properties:
						</p>
						<input
							id="item-id"
							type="text"
							placeholder="ID"
							style="margin-top: 10px;"
							class="input-style"
						/>

						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="set-id">Set</button
							>
						</div>
						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="add-point">Add Point</button
							>
						</div>
						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="delete-point">Delete</button
							>
						</div>
					</div>
				</section>

				<section class="container">
					<input
						type="text"
						placeholder="File Name"
						class="input-style"
						id="export-file-name"
						style="margin-bottom: 10px"
					/>

					<button
						id="export"
						class="button-style"
						style="margin-bottom: 10px"
					>
						Export SVG
						<svg
							xmlns="http://www.w3.org/2000/svg"
							width="24"
							height="24"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-linecap="round"
							stroke-linejoin="round"
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="7 10 12 15 17 10" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="15"
								y2="3"
								stroke-width="2"></line>
						</svg></button
					>
					<div class="">
						<input
							type="checkbox"
							id="yx-flip"
							name="yx-flip"
							value="true"
							checked
						/>
						<label for="yx-flip"> Y/X Flip</label>
					</div>

					<button
						id="export-csv-layer"
						class="button-style"
						style="margin-bottom: 10px"
						>Export CSV <span style="margin-left: 8px" class="boxed"
							>4096px</span
						>
					</button>
					<button id="export-csv-layer-2048" class="button-style"
						>Export CSV <span style="margin-left: 8px" class="boxed"
							>2048px</span
						></button
					>
					
					<label for="batch-dxf-files" class="button-style" style="margin-top: 10px;"
						>Batch Process DXF Files
						<svg
							xmlns="http://www.w3.org/2000/svg"
							width="24"
							height="24"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							stroke-linecap="round"
							stroke-linejoin="round"
							style="display: inline-block; margin-left: 8px; vertical-align: middle;"
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="17 8 12 3 7 8" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="3"
								y2="15"
								stroke-width="2"></line>
						</svg>
					</label>
					<input
						type="file"
						class="input-style"
						id="batch-dxf-files"
						name="batch-dxf-files"
						accept=".dxf"
						multiple
						style="display:none"
					/>
					<div id="dxf-processing-status" style="margin-top: 10px; font-size: 12px; color: #666; display: none;"></div>
				</section>

				<Tutorial x="some data" id="tutorial" />

				<div class="container" id="id-container">
					<div class="id-list-title-container">
						<p
							class="id-list-title"
							style="padding: 0em 0em; font-weight: bold;"
						>
							CTRL + F to look for items
						</p>
						<p class="hide-toggle" id="hide-toggle">^</p>
					</div>
					<ul style="padding-left: 1em;" class="id-list" id="id-list">
					</ul>
				</div>
			</div>
		</main>

		<section class="container editor grid">
			<div id="image-list-container" class="hidden flex-col">
				<div class="flex items-center mb-2 p-2 bg-neutral-50 rounded-sm">
					<input
						type="checkbox"
						id="matching-mode-toggle"
						class="mr-2"
						checked
					/>
					<label for="matching-mode-toggle" class="text-sm cursor-pointer">
						<span id="matching-mode-label">Default Matching (Final 3 elements in image name)</span>
					</label>
				</div>
				
				<div class="flex gap-2">
					<input
					type="text"
					placeholder="To Remove"
					id="text-replacement"
				/>
				<label
					for="check-floorplans-button"
					class="flex w-fit align-center text-center bg-neutral-100 hover:bg-neutral-300 p-1 pl-2 pr-2 rounded-sm text-sm self-end"
				>
					Check Floorplans
				</label>
				<input
					type="file"
					class="input-style"
					id="check-floorplans-button"
					accept="image/jpeg, image/png, image/webp, video/mp4, video/webm, video/ogg"
					name="filename"
					multiple
					style="display:none; "
				/>
				<button id="clear-images"
        class="flex align-center text-center bg-neutral-100 hover:bg-neutral-300 p-1 pl-2 pr-2 rounded-sm text-sm self-end"
        type="button">
  Clear Images
</button>
				</div>
				
				<div class="flex gap-2 mt-2">
					<label
						for="upload-unit-reference-button"
						class="flex w-fit align-center text-center bg-neutral-100 hover:bg-neutral-300 p-1 pl-2 pr-2 rounded-sm text-sm self-end cursor-pointer"
					>
						Upload unit-reference
					</label>
					<input
						type="file"
						class="input-style"
						id="upload-unit-reference-button"
						accept=".json"
						name="unit-reference"
						style="display:none;"
					/>
					<button id="export-unit-reference-button"
						class="flex align-center text-center bg-neutral-100 hover:bg-neutral-300 p-1 pl-2 pr-2 rounded-sm text-sm self-end"
						type="button">
						Export unit-reference
					</button>
				</div>
				
				<div
					id="image-carousel-container"
					class="hidden flex-col p-2 bg-neutral-100 rounded-sm"
				>
					<p class="text-sm mb-2">Image List</p>
					<ul
						class="flex flex-row max-h-20 w-full space-x-2 overflow-x-scroll overflow-y-hidden"
						id="image-list-carousel"
					>
					</ul>
				</div>
			</div>

			<div
				id="editor-button-container"
				style="display: flex; flex-direction: row; justify-content: space-between;"
			>
				<h3>Viewer</h3>
			</div>
			<div
				class="aspect-square max-h-[91vh] max-w-[91vh]"
				id="scalable-canvas"
			>
				<div class="output" id="svg-container">
					<p
						style="padding: 2em; background-color: #00000022; border-radius: 3px; margin: 0px;"
					>
						Import SVG file
					</p>
				</div>
			</div>

			<div class="space-y-4" id="tag">
				<h3 id="label">-</h3>
			</div>
			<svg id="svg" height="0px"></svg>
		</section>

		<!-- Toast notification -->
		<div id="toast" class="toast"></div>

	</body>

	<script>
		// import { onMount } from 'astro/client';
		// import * as svgOp from "./svg-scripts/svg-operations"
		import { transform } from "typescript";
		import {
			currentValuesList,
			updateValuesList,
			updateValuesModal,
			circlesToSpawn,
		} from "../store.js";
		enum format {
			underscore,
			dash,
			none,
			fullUnderscore,
		}

		var flipped = false;
		var canvasFlipX = false;
		var canvasFlipY = false;
		var canvasRotate = 0;
		var multiSelect = false;
		var clusterId = [];
		var canvasScale = 1;

		var idFormat = format.none; //SVG ID format
		var mouseDown = false;
		var globalSvgContainer = document.getElementById("svg-container");
		var mouseInContainer = false;
		var tempSelected;
		var flipYX = true;

		let prevMouseX = 0;
		let prevMouseY = 0;

		let rightMouseDown = false;
		let anchorPoint = { x: 0, y: 0 };
		let typing = false;

		let globalFloors = [];
		let globalFloorsAggregated = [];
		let aggregatePoints = false;
		let checkboxesId = [];

		// Image transformation lookup for preview images
		let imageTransformLookup = {};
		let currentHoveredImageName = null;
		
		// Imported unit-reference data
		let importedUnitReference = null;

		// Asset Delivery API Integration
		const API_BASE_URL = 'http://localhost:9234';

		// Extract project key from URL parameters
		function getProjectKey() {
			const urlParams = new URLSearchParams(window.location.search);
			return urlParams.get('project') || urlParams.get('key') || urlParams.get('id') || 'default';
		}

		// Fetch project assets from API
		async function fetchProjectAssets(projectKey) {
			try {
				const response = await fetch(`${API_BASE_URL}/api/project/${projectKey}`);
				if (!response.ok) {
					throw new Error(`HTTP ${response.status}: ${response.statusText}`);
				}
				return await response.json();
			} catch (error) {
				console.warn('Primary API endpoint failed, trying legacy endpoints:', error);

				// Try legacy endpoints as fallback
				try {
					const [modelsRes, csvRes] = await Promise.allSettled([
						fetch(`${API_BASE_URL}/model`),
						fetch(`${API_BASE_URL}/camera-csv`)
					]);

					const result = { mode: 'roomscale-4', models: [], cameraCSV: null, images: [], unitFloorplans: [] };

					if (modelsRes.status === 'fulfilled' && modelsRes.value.ok) {
						const modelsData = await modelsRes.value.json();
						result.models = modelsData.models || [];
					}

					if (csvRes.status === 'fulfilled' && csvRes.value.ok) {
						const csvData = await csvRes.value.json();
						result.cameraCSV = csvData;
					}

					return result;
				} catch (legacyError) {
					console.error('All API endpoints failed:', legacyError);
					return null;
				}
			}
		}

		// Convert API data formats to application format
		function convertApiData(data) {
			const converted = { ...data };

			// Convert base64 strings to Uint8Array if needed
			if (converted.models) {
				converted.models = converted.models.map(model => ({
					...model,
					data: typeof model.data === 'string' && !model.data.startsWith('data:')
						? Uint8Array.from(atob(model.data), c => c.charCodeAt(0))
						: model.data
				}));
			}

			if (converted.cameraCSV && typeof converted.cameraCSV.data === 'string') {
				converted.cameraCSV.data = converted.cameraCSV.data;
			}

			if (converted.images) {
				console.log('Converting images data:', converted.images.map(img => ({
					name: img.imageName,
					mimeType: img.mimeType,
					dataType: typeof img.data,
					dataLength: img.data?.length,
					dataPreview: typeof img.data === 'string' ? img.data.substring(0, 50) : 'non-string'
				})));

				converted.images = converted.images.map(img => {
					let data = img.data;
					console.log(`Processing image: ${img.imageName}, mimeType: ${img.mimeType}`);

					// For SVG files, if it's base64 encoded, keep as string for direct parsing
					// For other image types, convert to data URLs
					if (img.mimeType !== 'image/svg+xml') {
						console.log(`Converting non-SVG image to data URL: ${img.imageName}`);
						if (typeof data === 'string' && !data.startsWith('data:')) {
							data = `data:${img.mimeType};base64,${data}`;
							console.log(`Converted to data URL, new length: ${data.length}`);
						}
					} else {
						console.log(`Processing SVG image: ${img.imageName}`);
						// For SVG, handle different data formats
						if (data instanceof ArrayBuffer) {
							// Convert ArrayBuffer to string
							console.log('Converting ArrayBuffer to string');
							const decoder = new TextDecoder('utf-8');
							data = decoder.decode(data);
						} else if (data instanceof Uint8Array) {
							// Convert Uint8Array to string
							console.log('Converting Uint8Array to string');
							const decoder = new TextDecoder('utf-8');
							data = decoder.decode(data);
						} else if (typeof data === 'string') {
							console.log(`Processing string data, starts with: ${data.substring(0, 50)}`);
							// Handle data URLs and plain content
							if (data.startsWith('data:image/svg+xml;base64,')) {
								console.log('Decoding base64 data URL');
								const base64Data = data.split(',')[1];
								data = atob(base64Data);
							} else if (data.startsWith('data:image/svg+xml,')) {
								console.log('Decoding plain data URL');
								data = decodeURIComponent(data.split(',')[1]);
							} else {
								// Check if it's a base64-encoded string (not a data URL)
								// Base64 strings typically don't contain spaces and are longer than typical SVG content
								const isLikelyBase64 = /^[A-Za-z0-9+/]+=*$/.test(data) && data.length > 100 && !data.includes('<');
								console.log(`Checking if base64: ${isLikelyBase64}, length: ${data.length}, contains '<': ${data.includes('<')}`);
								if (isLikelyBase64) {
									try {
										console.log('Decoding base64 string');
										data = atob(data);
									} catch (e) {
										// If atob fails, assume it's already decoded SVG content
										console.warn('Failed to decode base64 SVG data, assuming it\'s already decoded');
									}
								} else {
									console.log('Assuming already decoded SVG content');
								}
								// If it's already a string and not a data URL or base64, assume it's SVG content
							}
						}
						console.log(`Final SVG data length: ${data.length}, starts with: ${data.substring(0, 50)}`);
					}
					return { ...img, data };
				});
			}

			if (converted.unitFloorplans) {
				console.log('Converting unitFloorplans data:', converted.unitFloorplans.map(img => ({
					name: img.imageName,
					mimeType: img.mimeType,
					dataType: typeof img.data,
					dataLength: img.data?.length,
					dataPreview: typeof img.data === 'string' ? img.data.substring(0, 50) : 'non-string'
				})));

				converted.unitFloorplans = converted.unitFloorplans.map(img => {
					let data = img.data;
					console.log(`Processing unitFloorplan: ${img.imageName}, mimeType: ${img.mimeType}`);

					// Same logic as images above
					if (img.mimeType !== 'image/svg+xml') {
						console.log(`Converting non-SVG unitFloorplan to data URL: ${img.imageName}`);
						if (typeof data === 'string' && !data.startsWith('data:')) {
							data = `data:${img.mimeType};base64,${data}`;
							console.log(`Converted to data URL, new length: ${data.length}`);
						}
					} else {
						console.log(`Processing SVG unitFloorplan: ${img.imageName}`);
						// For SVG, handle different data formats
						if (data instanceof ArrayBuffer) {
							// Convert ArrayBuffer to string
							console.log('Converting ArrayBuffer to string');
							const decoder = new TextDecoder('utf-8');
							data = decoder.decode(data);
						} else if (data instanceof Uint8Array) {
							// Convert Uint8Array to string
							console.log('Converting Uint8Array to string');
							const decoder = new TextDecoder('utf-8');
							data = decoder.decode(data);
						} else if (typeof data === 'string') {
							console.log(`Processing string data, starts with: ${data.substring(0, 50)}`);
							// Handle data URLs and plain content
							if (data.startsWith('data:image/svg+xml;base64,')) {
								console.log('Decoding base64 data URL');
								const base64Data = data.split(',')[1];
								data = atob(base64Data);
							} else if (data.startsWith('data:image/svg+xml,')) {
								console.log('Decoding plain data URL');
								data = decodeURIComponent(data.split(',')[1]);
							} else {
								// Check if it's a base64-encoded string (not a data URL)
								// Base64 strings typically don't contain spaces and are longer than typical SVG content
								const isLikelyBase64 = /^[A-Za-z0-9+/]+=*$/.test(data) && data.length > 100 && !data.includes('<');
								console.log(`Checking if base64: ${isLikelyBase64}, length: ${data.length}, contains '<': ${data.includes('<')}`);
								if (isLikelyBase64) {
									try {
										console.log('Decoding base64 string');
										data = atob(data);
									} catch (e) {
										// If atob fails, assume it's already decoded SVG content
										console.warn('Failed to decode base64 SVG data, assuming it\'s already decoded');
									}
								} else {
									console.log('Assuming already decoded SVG content');
								}
								// If it's already a string and not a data URL or base64, assume it's SVG content
							}
						}
						console.log(`Final unitFloorplan SVG data length: ${data.length}, starts with: ${data.substring(0, 50)}`);
					}
					return { ...img, data };
				});
			}

			return converted;
		}

		// Process API response and load assets
		async function processApiAssets(apiData) {
			if (!apiData) return;

			console.log('Processing API assets:', apiData);

			const convertedData = convertApiData(apiData);

			// Store assets globally for the application to use
			window.apiAssets = convertedData;

			// Process based on mode
			if (convertedData.mode === 'refactored') {
				console.log('Processing refactored mode assets');

				let backgroundImages = [];

				// Load SVG floorplates and collect background images
				if (convertedData.images && convertedData.images.length > 0) {
					console.log('Processing images array:', convertedData.images.length, 'items');

					// Reset SVG state for API loading
					importedSVGs = [];
					currentSVGIndex = 0;
					globalSvgContainer.innerHTML = "";

					// Separate SVGs from background images (tower floorplates)
					const svgImages = convertedData.images.filter(img => img.mimeType === 'image/svg+xml');
					backgroundImages = convertedData.images.filter(img => img.mimeType !== 'image/svg+xml');

					console.log(`Found ${svgImages.length} SVG files and ${backgroundImages.length} background images in images array`);

					// Process each SVG
					for (const image of svgImages) {
						try {
							console.log(`Loading SVG: ${image.imageName}`);
							// Load SVG using existing logic (data is already processed in convertApiData)
							loadSVGFromData(image.data, image.imageName);
						} catch (error) {
							console.error(`Failed to load SVG ${image.imageName}:`, error);
						}
					}

					// Show image-list-container when SVGs are loaded
					if (svgImages.length > 0) {
						const imageListContainer = document.getElementById("image-list-container");
						if (imageListContainer && imageListContainer.classList.contains("hidden")) {
							console.log('Showing image-list-container after SVG load');
							imageListContainer.classList.remove("hidden");
						}
					}

					// Show navigation if multiple SVGs
					if (importedSVGs.length > 1) {
						console.log('Showing SVG navigation for multiple SVGs');
						spawnSVGNavigation();
					} else if (importedSVGs.length === 1) {
						console.log('Single SVG loaded, no navigation needed');
					} else {
						console.log('No SVGs were loaded');
					}
				}

				// Load unitFloorplans for overlay functionality (hover check)
				if (convertedData.unitFloorplans && convertedData.unitFloorplans.length > 0) {
					console.log('ðŸ“‹ Processing unitFloorplans array:', convertedData.unitFloorplans.length, 'items for overlay functionality');
					// Store unit floorplans for later use
					window.unitFloorplans = convertedData.unitFloorplans;

					// Load unit floorplans into imageList for overlay functionality (hover check)
					loadApiImagesToImageList(convertedData.unitFloorplans, 'unitFloorplans');
				} else {
					console.log('ðŸ“‹ No unitFloorplans found for overlay functionality');
				}

				// Load background images (tower floorplates) via simulated drag-and-drop AFTER SVGs are loaded
				if (backgroundImages.length > 0) {
					console.log(`ðŸ—ï¸ Loading ${backgroundImages.length} background images (tower floorplates) via simulated drag-and-drop`);
					loadApiBackgroundImages(backgroundImages);
				} else {
					console.log('ðŸ—ï¸ No background images found to load');
				}
			} else if (convertedData.mode === 'roomscale-4') {
				// For roomscale mode, store assets but don't auto-load (user can load manually)
				console.log('Roomscale assets loaded via API:', {
					models: convertedData.models?.length || 0,
					csv: convertedData.cameraCSV ? 'present' : 'none',
					images: convertedData.images?.length || 0
				});

				// Store for manual loading by user
				if (convertedData.cameraCSV) {
					window.apiCameraCSV = convertedData.cameraCSV;
				}
				if (convertedData.models && convertedData.models.length > 0) {
					window.apiModels = convertedData.models;
				}
			}
		}

		// Load SVG from data (helper function to integrate with existing logic)
		function loadSVGFromData(svgData, filename) {
			console.log(`loadSVGFromData called for: ${filename}`);
			try {
				// Ensure svgData is a string
				let svgText = svgData;
				console.log(`SVG data type: ${typeof svgText}, length: ${svgText?.length}`);
				if (typeof svgText !== 'string') {
					console.warn(`SVG data for ${filename} is not a string, converting...`);
					if (svgText instanceof ArrayBuffer) {
						const decoder = new TextDecoder('utf-8');
						svgText = decoder.decode(svgText);
					} else if (svgText instanceof Uint8Array) {
						const decoder = new TextDecoder('utf-8');
						svgText = decoder.decode(svgText);
					} else {
						svgText = String(svgText);
					}
				}

				// Basic validation - check if it starts with SVG tag or XML declaration
				if (!svgText.trim().startsWith('<') && !svgText.trim().startsWith('<?xml')) {
					console.error(`SVG content for ${filename} doesn't appear to be valid SVG/XML:`, svgText.substring(0, 200));
					throw new Error('Content does not appear to be valid SVG');
				}

				console.log(`Parsing SVG: ${filename}`);
				// Parse and process the SVG similar to existing file loading
				const parser = new DOMParser();
				const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');

				if (svgDoc.querySelector('parsererror')) {
					console.error(`SVG parsing error for ${filename}:`, svgDoc.querySelector('parsererror'));
					console.error(`First 500 chars of SVG content:`, svgText.substring(0, 500));
					throw new Error('Invalid SVG content');
				}

				const svgElement = svgDoc.documentElement;
				console.log(`SVG parsed successfully: ${filename}, element:`, svgElement.tagName);

				// Use existing SVG processing logic (same as in handleFileChange)
				importedSVGs.push({ name: getBaseName(filename), element: svgElement });
				console.log(`Added SVG to importedSVGs. Total SVGs now: ${importedSVGs.length}`);

				// Process the SVG
				console.log(`Processing SVG with processSVG: ${filename}`);
				processSVG(svgElement);

				// Set up image overlay if images are already loaded
				if (imageList.length > 0) {
					console.log(`Setting up image overlay for ${filename} with ${imageList.length} images`);
					previewBackplate(svgElement);
				} else {
					console.log(`No images in imageList yet for ${filename}`);
				}

				console.log(`Successfully loaded SVG: ${filename}`);

			} catch (error) {
				console.error(`Error loading SVG ${filename}:`, error);
			}
		}

		// Load API background images (tower floorplates) via simulated drag-and-drop
		function loadApiBackgroundImages(apiImages) {
			console.log(`ðŸ—ï¸ loadApiBackgroundImages called with ${apiImages.length} background images`);
			console.log('Available SVGs:', importedSVGs.map(svg => svg.name));

			if (apiImages.length === 0 || importedSVGs.length === 0) {
				console.log('No background images or no SVGs loaded, skipping background image loading');
				return;
			}

			apiImages.forEach((imageData) => {
				console.log(`Processing background image: ${imageData.imageName}`);

				const mediaBaseName = getBaseName(imageData.imageName);
				// Extract last 2 segments from image name
				const mediaNameParts = mediaBaseName.split("_");
				const mediaLastTwoSegments = mediaNameParts.length >= 2
					? mediaNameParts.slice(-2).join("_")
					: mediaBaseName;

				console.log(`Image name: ${imageData.imageName} -> last 2 segments: ${mediaLastTwoSegments}`);

				// Loop through the imported SVG objects to find a matching name
				importedSVGs.forEach((svgObj) => {
					const svgBaseName = getBaseName(svgObj.name);
					// Extract last 2 segments from SVG name
					const svgNameParts = svgBaseName.split("_");
					const svgLastTwoSegments = svgNameParts.length >= 2
						? svgNameParts.slice(-2).join("_")
						: svgBaseName;

					console.log(`Comparing SVG: ${svgObj.name} (${svgLastTwoSegments}) with image (${mediaLastTwoSegments})`);

					if (svgLastTwoSegments === mediaLastTwoSegments) {
						console.log(`Found match! Loading ${imageData.imageName} as background for ${svgObj.name}`);

						const svgElement = svgObj.element;
						const viewBox = svgElement.getAttribute("viewBox").split(" ");

						// Remove any existing background images
						const existingImages = svgElement.querySelectorAll("image");
						existingImages.forEach(img => {
							const imgWidth = img.getAttribute("width");
							const imgHeight = img.getAttribute("height");

							if (imgWidth === viewBox[2] && imgHeight === viewBox[3]) {
								img.remove();
								console.log("Removed existing background image from SVG");
							}
						});

						// Remove existing foreignObject elements (videos)
						const existingForeignObjects = svgElement.querySelectorAll("foreignObject");
						existingForeignObjects.forEach(fo => {
							const foWidth = fo.getAttribute("width");
							const foHeight = fo.getAttribute("height");
							if (foWidth === viewBox[2] && foHeight === viewBox[3]) {
								fo.remove();
								console.log("Removed existing background video from SVG");
							}
						});

						// Create and add the background image
						const imageElement = document.createElementNS("http://www.w3.org/2000/svg", "image");
						imageElement.setAttribute("x", viewBox[0]);
						imageElement.setAttribute("y", viewBox[1]);
						imageElement.setAttribute("width", viewBox[2]);
						imageElement.setAttribute("height", viewBox[3]);
						imageElement.setAttribute("href", imageData.data); // Use the data URL
						imageElement.setAttribute("preserveAspectRatio", "xMidYMid meet");

						// Insert as the first child (background)
						if (svgElement.firstChild) {
							svgElement.insertBefore(imageElement, svgElement.firstChild);
						} else {
							svgElement.appendChild(imageElement);
						}

						console.log(`Successfully added background image ${imageData.imageName} to SVG ${svgObj.name}`);
					}
				});
			});

			console.log(`Finished processing ${apiImages.length} background images`);
		}

		// Load API images into imageList for overlay functionality
		function loadApiImagesToImageList(apiImages, source = 'unknown') {
			console.log(`ðŸ”„ loadApiImagesToImageList called with ${apiImages.length} images from source: ${source}`);
			console.log('API images:', apiImages.map(img => ({ name: img.imageName, mimeType: img.mimeType, dataLength: img.data?.length })));

			if (apiImages.length === 0) {
				console.log('No images to load');
				return;
			}

			// Clear existing images only if this is the first load
			if (imageList.length === 0) {
				console.log('Clearing existing imageList');
				imageList.splice(0, imageList.length);
			}

			// Add API images to imageList
			let addedCount = 0;
			apiImages.forEach(img => {
				console.log(`Adding image: ${img.imageName}, mimeType: ${img.mimeType}, data length: ${img.data?.length}`);
				imageList.push({
					name: img.imageName,
					data: img.data // Already converted to data URL format
				});
				addedCount++;
			});

			console.log(`Added ${addedCount} images to imageList. Total images now: ${imageList.length}`);

			// Show the parent image-list-container first
			const imageListContainer = document.getElementById("image-list-container");
			console.log('Image list container element:', imageListContainer);
			if (imageListContainer) {
				console.log('Image list container classes before:', imageListContainer.classList.value);
				if (imageListContainer.classList.contains("hidden")) {
					console.log('Removing "hidden" class from image-list-container');
					imageListContainer.classList.remove("hidden");
				}
				console.log('Image list container classes after:', imageListContainer.classList.value);
			} else {
				console.error('Image list container not found!');
			}

			// Show the image carousel UI
			const imgCarouselContainer = document.getElementById("image-carousel-container");
			console.log('Image carousel container element:', imgCarouselContainer);
			if (imgCarouselContainer) {
				console.log('Image carousel container classes before:', imgCarouselContainer.classList.value);
				console.log('Contains hidden?', imgCarouselContainer.classList.contains("hidden"));
				console.log('Computed display style:', window.getComputedStyle(imgCarouselContainer).display);

				// Check parent elements
				let parent = imgCarouselContainer.parentElement;
				let depth = 0;
				while (parent && depth < 5) {
					console.log(`Parent ${depth}:`, parent.tagName, parent.id || parent.className, 'display:', window.getComputedStyle(parent).display);
					parent = parent.parentElement;
					depth++;
				}

				// Check sibling elements
				const siblings = Array.from(imgCarouselContainer.parentElement?.children || []);
				console.log('Siblings:', siblings.map(s => `${s.tagName}#${s.id || 'no-id'}.${s.className}`).join(', '));

				console.log('Removing hidden class and setting display to block with !important');
				imgCarouselContainer.classList.remove("hidden");
				imgCarouselContainer.style.setProperty('display', 'block', 'important');

				console.log('Image carousel container classes after:', imgCarouselContainer.classList.value);
				console.log('Image carousel container display style:', imgCarouselContainer.style.display);
				console.log('Computed display style after:', window.getComputedStyle(imgCarouselContainer).display);
			} else {
				console.error('Image carousel container not found!');
			}

			// Update the image carousel display
			const imageListCarousel = document.getElementById("image-list-carousel");
			console.log('Image list carousel element:', imageListCarousel);
			if (imageListCarousel) {
				imageListCarousel.innerHTML = "";
				imageList.forEach((image, index) => {
					console.log(`Creating thumbnail ${index + 1}: ${image.name}`);
					const listItem = document.createElement("li");
					listItem.style.height = "100%";
					const imageElement = document.createElement("img");
					imageElement.src = image.data;
					imageElement.style.height = "60px";
					imageElement.title = image.name; // Add tooltip
					listItem.appendChild(imageElement);
					imageListCarousel.appendChild(listItem);
				});
				console.log('Created thumbnails for all images');
			} else {
				console.error('Image list carousel not found!');
			}

			// Set up image overlay functionality
			// Wait a bit for SVG to be fully loaded into DOM
			setTimeout(() => {
				const currentSVG = document.getElementById("svg-container")?.querySelector("svg");
				console.log('Current SVG element:', currentSVG);
				if (currentSVG) {
					console.log('Setting up previewBackplate for current SVG');
					previewBackplate(currentSVG);
				} else {
					console.log('No current SVG found, previewBackplate not called');
				}

				// Also set up overlay for any existing SVGs in importedSVGs
				if (importedSVGs.length > 0) {
					console.log(`Setting up previewBackplate for ${importedSVGs.length} imported SVGs`);
					importedSVGs.forEach((svgInfo, index) => {
						console.log(`Setting up overlay for imported SVG ${index}: ${svgInfo.name}`);
						previewBackplate(svgInfo.element);
					});
				}
			}, 100);

			console.log(`Successfully loaded ${apiImages.length} images into overlay system from ${source}`);

			// Show toast notification that floorplans are loaded
			showToast(`Loaded ${apiImages.length} floorplan image(s) for overlay`, 'success');
		}

		// Show toast notification
		function showToast(message, type = 'info') {
			const toast = document.getElementById('toast');
			if (!toast) return;

			toast.textContent = message;
			toast.className = `toast ${type} show`;

			setTimeout(() => {
				toast.classList.remove('show');
			}, 5000);
		}

		// Initialize API loading on page load
		document.addEventListener('DOMContentLoaded', async () => {
			const projectKey = getProjectKey();
			console.log('Loading project:', projectKey);

			const apiData = await fetchProjectAssets(projectKey);
			if (apiData) {
				await processApiAssets(apiData);
			} else {
				console.log('No API data available, user can load files manually');
			}
		});

		// Undo/Redo system
		let undoStack = [];
		let redoStack = [];
		const MAX_HISTORY = 50; // Limit history size
		let hasSavedStateForCurrentOperation = false; // Track if we've saved state for current drag/operation
		let hasMovedDuringDrag = false; // Track if we actually moved elements during the current drag

		// Save current SVG state to history
		function saveState() {
			const svgElement = globalSvgContainer.querySelector("svg");
			if (svgElement) {
				const svgClone = svgElement.cloneNode(true) as SVGElement;
				const state = new XMLSerializer().serializeToString(svgClone);
				undoStack.push(state);
				// Limit stack size
				if (undoStack.length > MAX_HISTORY) {
					undoStack.shift();
				}
				// Clear redo stack when new action is performed
				redoStack = [];
			}
		}

		// Restore SVG state from history
		function restoreState(state: string) {
			const svgElement = globalSvgContainer.querySelector("svg");
			if (svgElement && state) {
				const parser = new DOMParser();
				const doc = parser.parseFromString(state, "image/svg+xml");
				const newSvg = doc.querySelector("svg");
				if (newSvg) {
					// Preserve viewBox and other attributes
					const viewBox = svgElement.getAttribute("viewBox");
					const width = svgElement.getAttribute("width");
					const height = svgElement.getAttribute("height");
					
					// Replace the SVG content
					svgElement.innerHTML = newSvg.innerHTML;
					
					// Restore attributes
					if (viewBox) svgElement.setAttribute("viewBox", viewBox);
					if (width) svgElement.setAttribute("width", width);
					if (height) svgElement.setAttribute("height", height);
					
					// Update labels and other UI
					spawnLabel();
				}
			}
		}

		// Undo function
		function undo() {
			if (undoStack.length > 0) {
				const currentState = new XMLSerializer().serializeToString(
					globalSvgContainer.querySelector("svg")?.cloneNode(true) as SVGElement
				);
				redoStack.push(currentState);
				if (redoStack.length > MAX_HISTORY) {
					redoStack.shift();
				}
				
				const previousState = undoStack.pop();
				if (previousState) {
					restoreState(previousState);
				}
			}
		}

		// Redo function
		function redo() {
			if (redoStack.length > 0) {
				const currentState = new XMLSerializer().serializeToString(
					globalSvgContainer.querySelector("svg")?.cloneNode(true) as SVGElement
				);
				undoStack.push(currentState);
				if (undoStack.length > MAX_HISTORY) {
					undoStack.shift();
				}
				
				const nextState = redoStack.pop();
				if (nextState) {
					restoreState(nextState);
				}
			}
		}

		//Multiple SVGs
		var importedSVGs = [];
		var currentSVGIndex = 0;

		//3d objectID
		var object3dCount = 0;

		var formattingButtons = document.querySelectorAll(".formatting");
		formattingButtons.forEach((e) => {
			e.addEventListener("change", (event) =>
				setFormat(event.target.value),
			);
		});

		function setFormat(data) {
			if (data == "underscore") {
				idFormat = format.underscore;
			} else if (data == "dash") {
				idFormat = format.dash;
			} else if (data == "none") {
				idFormat = format.none;
			} else if (data == "fullUnderscore") {
				idFormat = format.fullUnderscore;
			}
		}

		//Attribute Editor
		var groupGlobal = [];

		var fileNameGlobal = "";
		var svg = document.getElementById("svg"); // get the SVG element
		var mouseRect = svg.createSVGRect(); // create a rectangle for the mouse position
		var currentSelected = null;

		// "Show the dialog" button opens the dialog modally

		//New code to interface with SVG
		document
			.getElementById("export-file-name")
			.addEventListener("input", (e) => {
				fileNameGlobal = e.target.value;
				console.log(fileNameGlobal);
			});

		//Check if SVG Container is active
		document
			.getElementById("svg-container")
			.addEventListener("mouseover", (e) => {
				//Set global var MouseInContainer
				mouseInContainer = true;
			});

		document
			.getElementById("svg-container")
			.addEventListener("mouseout", (e) => {
				//Set global var MouseInContainer
				mouseInContainer = false;
			});

		var createNewSVG = () => {
			// Create new SVG if it's not present
			const newSVG = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"svg",
			);
			newSVG.style.width = "100%";
			newSVG.style.height = "100%";
			newSVG.setAttribute("viewBox", "0 0 4096 4096");
			newSVG.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");

			return newSVG;
		};

		const scalableCanvas = document.getElementById("scalable-canvas");
		const svgContainer = document.getElementById("svg-container");

		// Initialize variables for panning
		let isPanning = false;
		let startX, startY;
		let translateX = 0,
			translateY = 0;

		// Handle zooming with the mouse wheel
		scalableCanvas.addEventListener("wheel", (e) => {
			e.preventDefault(); // Prevent default scrolling behavior

			// Get the current scale value or default to 1
			let scale =
				parseFloat(
					svgContainer.style.transform.match(/scale\(([^)]+)\)/)?.[1],
				) || 1;

			// Adjust scale based on wheel delta
			scale -= e.deltaY / 1000; // Scale up for scroll up, down for scroll down

			// Clamp the scale value
			scale = Math.max(1, Math.min(scale, 10)); // Min scale: 0.1, Max scale: 10

			canvasScale = scale;

			// Apply updated scale
			if (scale > 1.2) {
				svgContainer.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
			} else {
				translateX = 0;
				translateY = 0;
				svgContainer.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
			}

			console.log(`Updated scale: ${scale}`);
		});

		// Handle panning
		scalableCanvas.addEventListener("mousedown", (e) => {
			isPanning = true;
			startX = e.clientX - translateX;
			startY = e.clientY - translateY;
			scalableCanvas.style.cursor = "grabbing"; // Change cursor to grabbing
		});

		scalableCanvas.addEventListener("mousemove", (e) => {
			if (!isPanning || tempSelected != null) return;

			// Calculate new translate values
			let newTranslateX = e.clientX - startX;
			let newTranslateY = e.clientY - startY;

			// Dynamically calculate boundaries based on canvas and container sizes
			const canvasRect = scalableCanvas.getBoundingClientRect();
			const svgRect = svgContainer.getBoundingClientRect();

			const scale =
				parseFloat(
					svgContainer.style.transform.match(/scale\(([^)]+)\)/)?.[1],
				) || 1;

			const boundary = {
				minX: Math.min(
					0,
					canvasRect.width - svgRect.width * 0.5 * scale,
				),
				maxX: Math.max(
					0,
					-(canvasRect.width - svgRect.width * 0.5 * scale),
				),
				minY: Math.min(
					0,
					canvasRect.height - svgRect.height * 0.5 * scale,
				),
				maxY: Math.max(
					0,
					-(canvasRect.height - svgRect.height * 0.5 * scale),
				),
			};

			// console.log(boundary)

			// Apply boundaries
			translateX = Math.max(
				boundary.minX,
				Math.min(boundary.maxX, newTranslateX),
			);
			translateY = Math.max(
				boundary.minY,
				Math.min(boundary.maxY, newTranslateY),
			);

			// Apply updated translation
			svgContainer.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;

			// console.log(`Panning: translateX=${translateX}, translateY=${translateY}`);
		});

		scalableCanvas.addEventListener("mouseup", () => {
			isPanning = false;
			scalableCanvas.style.cursor = "default"; // Reset cursor
		});

		scalableCanvas.addEventListener("mouseleave", () => {
			isPanning = false; // Stop panning if the mouse leaves the canvas
		});

		// helper â€“ add one element to the multiselect lists (no duplicates)
		function addToSelection(el) {
		if (!el || el.nodeName.toLowerCase() === 'svg') return;        // ignore root SVG
			if (!el.classList.contains('svg-tool-selected')) {             // not already in set
				el.classList.add('svg-tool-selected');
				el.style.fill = '#87CEEB';
				groupGlobal.push(el);
			}
		}

		// track the primary button
		let primaryMouseIsDown = false;
		document.addEventListener('mousedown', e => {
		if (e.button === 0) primaryMouseIsDown = true;
		});
		document.addEventListener('mouseup',   e => {
		if (e.button === 0) primaryMouseIsDown = false;
		});

		document.getElementById('svg-container')
		.addEventListener('mousemove', e => {
			if (!primaryMouseIsDown || !e.shiftKey) return;              // nothing to do

			const target = e.target;                                     // element under cursor
			const parentIsG = target.parentNode?.nodeName.toLowerCase() === 'g';
			const valid     = parentIsG || target.nodeName.toLowerCase() === 'circle';

			if (valid) addToSelection(target);
		});


		document
			.getElementById("svg-container")
			.addEventListener("mouseover", (e) => {
				if (
					e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
					e.srcElement.nodeName.toLowerCase() == "svg" ||
					e.srcElement.parentNode.nodeName.toLowerCase() == "g" ||
					!e.srcElement.tagName == "image"
				) {
					if (currentSelected != null) {
						currentSelected.classList.remove("hovered");
						if (
							!currentSelected.classList.contains(
								"svg-tool-selected",
							)
						) {
							currentSelected.style.fill = "";
						} else {
							currentSelected.style.fill = "#87CEEB";
						}
					}
					document.getElementById("tag").style.display = "flex";
					document.getElementById("label").innerHTML = "";
					var label = document.createElement("div");
					label.style.display = "flex";
					label.style.flexDirection = "column";
					label.style.alignItems = "flex-start";
					label.style.justifyContent = "flex-start";
					label.style.gap = "10px";
					label.style.padding = "10px";
					label.style.backgroundColor = "#000000";
					if (e.srcElement.id) {
						var idLabel = document.createElement("p");
						idLabel.innerText = `ID: ${e.srcElement.id}`;
						idLabel.style.color = "#007700";
						idLabel.style.marginTop = "10px";
						idLabel.style.marginBottom = "10px";
						label.appendChild(idLabel);
					}

					if (e.srcElement.getAttribute("class")) {
						var classLabel = document.createElement("p");
						var tempClassList = Object.assign(
							{},
							e.srcElement.classList,
						);
						tempClassList = Object.keys(tempClassList).filter(
							(item) =>
								tempClassList[item] !== "svg-tool-selected",
						);
						if (tempClassList.length > 0) {
							var tempString = "";
							tempClassList.forEach((classname) => {
								if (tempString == "") {
									tempString = classname;
								} else {
									tempString += " " + classname;
								}
							});
							classLabel.innerText = `Class: ${tempClassList}`;
							classLabel.style.marginTop = "10px";
							classLabel.style.marginBottom = "10px";
						}

						label.appendChild(classLabel);
					}

					if (e.target.getAttribute("data-floor")) {
						var floorLabel = document.createElement("p");
						floorLabel.innerText = `Floor: ${e.srcElement.getAttribute("data-floor")}`;
						floorLabel.style.color = "#007700";
						floorLabel.style.marginTop = "10px";
						floorLabel.style.marginBottom = "10px";
						label.appendChild(floorLabel);
					}

					document.getElementById("label").append(label);
					currentSelected = e.srcElement;
					e.srcElement.classList.add("hovered");
				} else {
					document.getElementById("tag").style.display = "none";
					mouseInContainer = false;
					// console.log(e.srcElement.parentNode.nodeName);
				}

				document.querySelectorAll(".hovered").forEach((e) => {
					e.style.fill = "#87CEEB66";
				});
			});

		document.getElementById("yx-flip").addEventListener("change", (e) => {
			flipYX = e.target.checked;
		});

		document
			.getElementById("svg-container")
			.addEventListener("mousedown", (e) => {
				spawnLabel();
				if (
					e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
					e.srcElement.nodeName.toLowerCase() == "svg" ||
					e.srcElement.parentNode.nodeName.toLowerCase() == "g"
				) {
					if (mouseInContainer) {
						if (e.button === 0) {
							// Left mouse button
							mouseDown = true;
						} else if (e.button === 1) {
							// Right mouse button
							rightMouseDown = true;
							prevMouseX = e.clientX;
							prevMouseY = e.clientY;
							// Calculate the anchor point for scaling
							anchorPoint =
								calculateBoundingBoxCenter(groupGlobal);
						}
					}
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;
					// if (currentSelected != null) {
					// 	currentSelected.classList.add("hovered");
					// }
					document.getElementById("tag").style.display = "flex";
					document.getElementById("label").innerText =
						e.srcElement.id;
					currentSelected = e.srcElement;

					const groupName = e.srcElement;
					//Get Attributes
					if (!multiSelect) {
						groupGlobal = [];
						document
							.querySelectorAll(".svg-tool-selected")
							.forEach((e) => {
								// console.log(e.classList)
								e.classList.remove("svg-tool-selected");
								// console.log(e.classList)
								e.style.fill = "";
							});

						groupGlobal.push(groupName);
						console.log(groupGlobal);
					} else {
						if (
							!groupName.classList.contains("hovered") &&
							groupName.classList.contains("svg-tool-selected")
						) {
							groupGlobal.push(groupName);
						} else if (groupGlobal.length <= 1) {
							groupGlobal.push(groupName);
						}
						console.log(groupGlobal);
					}

					if (groupGlobal.length < 2) {
						if (
							groupGlobal[0].getAttribute("group-attribute") != ""
						) {
							document.getElementById("group").value =
								groupGlobal[0].getAttribute("group-attribute");
						} else {
							document.getElementById("group").value = "";
						}

						if (
							groupGlobal[0].getAttribute("unit-attribute") != ""
						) {
							document.getElementById("unit").value =
								groupGlobal[0].getAttribute("unit-attribute");
						} else {
							document.getElementById("unit").placeholder =
								"No Attribute";
							document.getElementById("unit").value = "";
						}

						if (groupGlobal[0].getAttribute("id") != "") {
							document.getElementById("item-id").value =
								groupGlobal[0].getAttribute("id");
						} else {
							document.getElementById("item-id").placeholder =
								"No Attribute";
							document.getElementById("item-id").value = "";
						}
					} else {
						document.getElementById("group").placeholder = "Group";
						document.getElementById("unit").placeholder = "Unit";
						document.getElementById("item-id").placeholder = "ID";
					}
					e.srcElement.classList.add("svg-tool-selected");

					// e.srcElement.style.fill = "#ff000055";
				} else {
					document.getElementById("tag").style.display = "none";
				}

				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.style.fill = "#87CEEB";
				});
			});

		document.getElementById("set-name").addEventListener("click", (e) => {
			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				if (
					document.querySelectorAll(".svg-tool-selected").length < 2
				) {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.setAttribute(
						"unit-attribute",
						document.getElementById("unit").value,
					);
					if (
						e.hasAttribute("group-attribute") &&
						e.hasAttribute("unit-attribute")
					) {
						e.id =
							e.getAttribute("group-attribute") +
							"_" +
							e.getAttribute("unit-attribute");
					}
				} else {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.id =
						e.getAttribute("group-attribute") +
						"_" +
						e.getAttribute("unit-attribute");
				}
			});
		});

		document
			.getElementById("delete-point")
			.addEventListener("click", (e) => {
				saveState();
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.remove();
				});
				spawnLabel();
			});

		document.getElementById("set-id").addEventListener("click", (e) => {
			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				if (
					document.querySelectorAll(".svg-tool-selected").length < 2
				) {
					e.setAttribute(
						"id",
						document.getElementById("item-id").value,
					);
				} else {
					e.setAttribute(
						"id",
						document.getElementById("item-id").value,
					);
				}
			});
		});

		document.getElementById("set-unit").addEventListener("click", (e) => {
			setUnit();
		});

		//Tag
		document.addEventListener("mousemove", (e) => {
			document.getElementById("tag").style.left = `${e.x}px`;
			document.getElementById("tag").style.top = `${e.y}px`;
			document.getElementById("tag").style.transform =
				`translate(0%, 150%)`;
		});

		var fileInput = document.getElementById("myFile");
		var type = "";
		fileInput.addEventListener("click", (e) => {
			fileInput.value = null;
		});

		function calculateSensitivity(svgElement) {
			const svgRect = svgElement.getBoundingClientRect(); // Get the on-screen size of the SVG
			// const svgRect = document.getElementById("scalable-canvas").getBoundingClientRect();
			const viewBox = svgElement.viewBox.baseVal; // Get the SVG's viewBox dimensions

			const scaleX = viewBox.width / svgRect.width;
			const scaleY = viewBox.height / svgRect.height;

			return { scaleX, scaleY };
		}

		function calculateLabelOffset(svgElement) {
			// const svgRect = svgElement.getBoundingClientRect(); // Get the on-screen size of the SVG
			const svgRect = document
				.getElementById("scalable-canvas")
				.getBoundingClientRect();
			const viewBox = svgElement.viewBox.baseVal; // Get the SVG's viewBox dimensions

			const scaleX = viewBox.width / svgRect.width;
			const scaleY = viewBox.height / svgRect.height;

			return { scaleX, scaleY };
		}

		function calculateBoundingBoxCenter(elements) {
			if (elements.length === 0) {
				console.log('[Anchor Calculation] No elements selected, returning {x:0, y:0}');
				return { x: 0, y: 0 };
			}

			let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

			elements.forEach((element) => {
				// Try to get cx/cy (for circles), else data-center-x/y (for triangles)
				let cx = parseFloat(element.getAttribute("cx"));
				let cy = parseFloat(element.getAttribute("cy"));
				if (isNaN(cx) || isNaN(cy)) {
					cx = parseFloat(element.getAttribute("data-center-x"));
					cy = parseFloat(element.getAttribute("data-center-y"));
				}
				if (isNaN(cx) || isNaN(cy)) return; // skip if still invalid

				if (cx < minX) minX = cx;
				if (cx > maxX) maxX = cx;
				if (cy < minY) minY = cy;
				if (cy > maxY) maxY = cy;
			});

			// If no valid points, return 0,0
			if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minY) || !isFinite(maxY)) {
				console.log('[Anchor Calculation] No valid points, returning {x:0, y:0}');
				return { x: 0, y: 0 };
			}

			const anchor = {
				x: (minX + maxX) / 2,
				y: (minY + maxY) / 2,
			};
			console.log('[Anchor Calculation]', {
				inputElements: elements,
				minX, maxX, minY, maxY,
				anchor
			});
			return anchor;
		}

		// Tag and mouse move event listener
		document.addEventListener("mousemove", (e) => {
			// Update Tags
			const tag = document.getElementById("tag");
			tag.style.left = `${e.x}px`;
			tag.style.top = `${e.y}px`;
			tag.style.transform = `translate(0%, -40px)`;

			if (mouseDown && mouseInContainer) {
				spawnLabel();
				const svgElement = globalSvgContainer.querySelector("svg");
				if (svgElement != null) {
					// Calculate sensitivity based on SVG resolution and size
					const { scaleX, scaleY } = calculateSensitivity(svgElement);

					// Calculate mouse movement difference once
					const deltaX = (e.clientX - prevMouseX) * scaleX;
					const deltaY = (e.clientY - prevMouseY) * scaleY;

					// Update previous mouse position once
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;

					// Move a single selected item
					if (
						tempSelected != null &&
						!multiSelect &&
						groupGlobal.length < 2
					) {
						console.log("Moving single item");
						moveElement(tempSelected, deltaX, deltaY);
						hasMovedDuringDrag = true; // Track that we moved something
					}
					// Move multiple selected items
					else if (multiSelect && groupGlobal.length > 0) {
						console.log("Moving all items");
						groupGlobal.forEach((item) =>
							moveElement(item, deltaX, deltaY),
						);
						hasMovedDuringDrag = true; // Track that we moved something
					}

					// console.log("Mouse Down + Move");
				}
			} else if (rightMouseDown && mouseInContainer) {
				const svgElement = globalSvgContainer.querySelector("svg");
				if (svgElement != null) {
					// Calculate sensitivity based on SVG resolution and size
					const { scaleX, scaleY } = calculateSensitivity(svgElement);

					// Calculate mouse movement difference
					const movementX = (e.clientX - prevMouseX) * scaleX;
					const movementY = (e.clientY - prevMouseY) * scaleY;

					// Use horizontal movement for scaling factor
					const scaleFactor = 1 + movementX * 0.01; // Adjust sensitivity here

					// Update previous mouse position
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;

					// Scale all selected items
					groupGlobal.forEach((item) =>
						scaleElement(item, scaleFactor, anchorPoint),
					);
					hasMovedDuringDrag = true; // Track that we scaled something

					console.log("Scaling all items");
				}
			}
		});

		//Move SVG with CX and CY
		document.addEventListener("mousedown", (e) => {
			spawnLabel();
			if (mouseInContainer && tempSelected != null) {
				if (e.button === 0) {
					// Left mouse button - save state before starting drag
					if (!hasSavedStateForCurrentOperation) {
						saveState();
						hasSavedStateForCurrentOperation = true;
					}
					mouseDown = true;
				} else if (e.button === 2) {
					// Right mouse button - save state before starting scale
					if (!hasSavedStateForCurrentOperation) {
						saveState();
						hasSavedStateForCurrentOperation = true;
					}
					rightMouseDown = true;
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;
					// Calculate the anchor point for scaling
					anchorPoint = calculateBoundingBoxCenter(groupGlobal);
				}
			}

			//Checks if it's a primitive element, otherwise put in a null,
			//If TempSelected is not cleared, it will get wrongfully selected and moved during MouseDown
			if (e.srcElement.parentNode.nodeName.toLowerCase() == "g") {
				tempSelected = e.srcElement;
				console.log("tempSelected");
				console.log(tempSelected);
			} else {
				tempSelected = null;
			}

			if (
				e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
				e.srcElement.nodeName.toLowerCase() == "svg" ||
				e.srcElement.parentNode.nodeName.toLowerCase() == "g"
			) {
				console.log(e.srcElement.parentNode);
				// if (currentSelected != null) {
				// 	currentSelected.classList.add("hovered");
				// }
				document.getElementById("tag").style.display = "flex";
				document.getElementById("tag").classList.add("leading-loose");
				document.getElementById("label").innerText = e.srcElement.id;
				currentSelected = e.srcElement;

				const groupName = e.srcElement;
				//Get Attributes
				if (!multiSelect) {
					groupGlobal = [];
					document
						.querySelectorAll(".svg-tool-selected")
						.forEach((e) => {
							// console.log(e.classList)
							e.classList.remove("svg-tool-selected");
							// console.log(e.classList)
							e.style.fill = "";
						});
					groupGlobal.push(groupName);
				} else {
					if (!groupGlobal.includes(groupName)) {
						groupGlobal.push(groupName);
					}
				}

				if (groupGlobal.length < 2) {
					if (groupGlobal[0].getAttribute("group-attribute") != "") {
						document.getElementById("group").value =
							groupGlobal[0].getAttribute("group-attribute");
					} else {
						document.getElementById("group").value = "";
					}

					if (groupGlobal[0].getAttribute("unit-attribute") != "") {
						document.getElementById("unit").value =
							groupGlobal[0].getAttribute("unit-attribute");
					} else {
						document.getElementById("unit").placeholder =
							"No Attribute";
						document.getElementById("unit").value = "";
					}
				} else {
					document.getElementById("group").placeholder = "-";
					document.getElementById("unit").placeholder = "-";
				}
				e.srcElement.classList.add("svg-tool-selected");

				// e.srcElement.style.fill = "#ff000055";
			} else {
				document.getElementById("tag").style.display = "none";
			}

			document.querySelectorAll(".selected").forEach((e) => {
				e.style.fill = "#87CEEB";
			});
		});

		document.addEventListener("mouseup", spawnLabel);

		function moveElement(element, deltaX, deltaY) {
			if (
				element.getAttribute("cx") != null &&
				element.getAttribute("cy") != null
			) {
				const currentCx = parseFloat(element.getAttribute("cx"));
				const currentCy = parseFloat(element.getAttribute("cy"));

				const newCx = currentCx + deltaX;
				const newCy = currentCy + deltaY;

				element.setAttribute("cx", newCx);
				element.setAttribute("cy", newCy);
			} else if (element.getAttribute("data-triangle") === "true") {
				// Handle triangle movement
				moveTriangle(element, deltaX, deltaY);
			}
		}

		function moveTriangle(triangle, deltaX, deltaY) {
			const currentCenterX = parseFloat(triangle.getAttribute("data-center-x"));
			const currentCenterY = parseFloat(triangle.getAttribute("data-center-y"));
			
			const newCenterX = currentCenterX + deltaX;
			const newCenterY = currentCenterY + deltaY;
			
			// Update center position
			triangle.setAttribute("data-center-x", newCenterX);
			triangle.setAttribute("data-center-y", newCenterY);
			
			// Recompute triangle points
			updateTrianglePoints(triangle, newCenterX, newCenterY);
		}

		function scaleElement(element, scaleFactor, anchor) {
			if (
				element.getAttribute("cx") != null &&
				element.getAttribute("cy") != null
			) {
				const currentCx = parseFloat(element.getAttribute("cx"));
				const currentCy = parseFloat(element.getAttribute("cy"));

				const newCx = anchor.x + (currentCx - anchor.x) * scaleFactor;
				const newCy = anchor.y + (currentCy - anchor.y) * scaleFactor;

				element.setAttribute("cx", newCx);
				element.setAttribute("cy", newCy);
			} else if (element.getAttribute("data-triangle") === "true") {
				// Handle triangle scaling
				scaleTriangle(element, scaleFactor, anchor);
			}
		}

		function scaleTriangle(triangle, scaleFactor, anchor) {
			const currentCenterX = parseFloat(triangle.getAttribute("data-center-x"));
			const currentCenterY = parseFloat(triangle.getAttribute("data-center-y"));

			// Defensive: Check for NaN in inputs
			if (
				isNaN(currentCenterX) || isNaN(currentCenterY) ||
				!anchor || isNaN(anchor.x) || isNaN(anchor.y) || isNaN(scaleFactor)
			) {
				console.error('scaleTriangle: Invalid input', {
					currentCenterX, currentCenterY, anchor, scaleFactor
				});
				return;
			}

			// Move the center relative to the anchor
			const newCenterX = anchor.x + (currentCenterX - anchor.x) * scaleFactor;
			const newCenterY = anchor.y + (currentCenterY - anchor.y) * scaleFactor;

			// Set new attributes
			triangle.setAttribute("data-center-x", newCenterX);
			triangle.setAttribute("data-center-y", newCenterY);

			// Use the current scale (do not change it)
			const currentScale = parseFloat(triangle.getAttribute("data-scale")) || 1;
			updateTrianglePoints(triangle, newCenterX, newCenterY, currentScale);
		}

		function updateTrianglePoints(triangle, centerX, centerY, scale = null) {
			// Validate inputs
			if (isNaN(centerX) || isNaN(centerY)) {
				console.error('updateTrianglePoints: Invalid center coordinates', centerX, centerY);
				return;
			}

			if (scale === null) {
				scale = parseFloat(triangle.getAttribute("data-scale")) || 1;
			}
			
			if (isNaN(scale) || scale <= 0) {
				console.error('updateTrianglePoints: Invalid scale', scale);
				scale = 1;
			}
			
			// Get direction from data attributes
			const dir = parseFloat(triangle.getAttribute("data-dir")) || 0;
			
			if (isNaN(dir)) {
				console.error('updateTrianglePoints: Invalid direction', triangle.getAttribute("data-dir"));
				return;
			}
			
			// Base triangle shape (points down at 0deg)
			const tri = [
				{ x: 0, y: 50 },
				{ x: -30, y: -30 },
				{ x: 30, y: -30 }
			];
			
			// Apply scale and rotation
			const angle = dir * Math.PI / 180;
			const scaledTri = tri.map(p => {
				// Scale first
				const scaledX = p.x * scale;
				const scaledY = p.y * scale;
				
				// Then rotate
				const rotatedX = scaledX * Math.cos(angle) - scaledY * Math.sin(angle);
				const rotatedY = scaledX * Math.sin(angle) + scaledY * Math.cos(angle);
				
				// Then translate to center
				const finalX = centerX + rotatedX;
				const finalY = centerY + rotatedY;
				
				// Validate final coordinates
				if (isNaN(finalX) || isNaN(finalY)) {
					console.error('updateTrianglePoints: NaN in final coordinates', finalX, finalY);
					return '0,0';
				}
				
				return `${finalX},${finalY}`;
			});
			
			triangle.setAttribute('points', scaledTri.join(' '));
		}

		document.addEventListener("mouseup", (e) => {
			// If we moved or scaled something during the drag, save the final state
			// This creates the "after" state for undo/redo
			if (hasMovedDuringDrag) {
				// Save the state after the move/scale operation completes
				saveState();
			} else if (hasSavedStateForCurrentOperation) {
				// If we saved state on mouse down but didn't move, remove it to avoid clutter
				// (user just clicked without dragging)
				if (undoStack.length > 0) {
					undoStack.pop();
				}
			}
			
			tempSelected = null;
			mouseDown = false;
			rightMouseDown = false;
			hasSavedStateForCurrentOperation = false; // Reset flag for next operation
			hasMovedDuringDrag = false; // Reset move tracking flag
		});

		document.getElementById("add-point").addEventListener("click", (e) => {
			svg = document.getElementById("svg");
			const layers = Array.from(svg.children);

			// Find the layer with the most circle elements
			let maxCircleCount = 0;
			let layerWithMostCircles = null;

			layers.forEach((layer) => {
				const circleCount = layer.querySelectorAll("circle").length;

				if (circleCount > maxCircleCount) {
					maxCircleCount = circleCount;
					layerWithMostCircles = layer;
				}
			});

			if (document.getElementById("item-id").value.length > 0) {
				console.log(document.getElementById("item-id").value);
				const values = document
					.getElementById("item-id")
					.value.split(",");
				values.map((e, i) => {
					console.log(e);
					const circle = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"circle",
					);
					circle.setAttribute("cx", `${30 * i}`);
					circle.setAttribute("cy", "30");
					circle.setAttribute("r", "30");
					circle.setAttribute("id", e);
					if (layerWithMostCircles) {
						layerWithMostCircles.appendChild(circle);
						console.log(layerWithMostCircles);
					} else {
						try {
							if (
								globalSvgContainer
									.querySelector("svg")
									.querySelector("g")
							) {
								globalSvgContainer
									.querySelector("svg")
									.querySelector("g")
									.appendChild(circle);
							} else {
								let svgInstance =
									globalSvgContainer.querySelector("svg");

								const gElement = document.createElementNS(
									"http://www.w3.org/2000/svg",
									"g",
								);
								gElement.appendChild(circle);
								svgInstance.appendChild(gElement);
							}
						} catch (e) {
							console.log(globalSvgContainer);
							let svgInstance =
								globalSvgContainer.querySelector("svg");

							if (!svgInstance) {
								svgInstance = createNewSVG();
								globalSvgContainer.appendChild(svgInstance);
							}

							const gElement = document.createElementNS(
								"http://www.w3.org/2000/svg",
								"g",
							);
							gElement.appendChild(circle);
							svgInstance.appendChild(gElement);
						}
					}
				});
				labelToggle();
			} else {
				alert("Please add a name for the point");
			}
		});

		function spawnCircle(id, cx, cy, data) {
			const g = globalSvgContainer.querySelector("g");
			const circle = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"circle",
			);
			circle.setAttribute("id", id);
			circle.setAttribute("cx", cx);
			circle.setAttribute("cy", cy);
			circle.setAttribute("r", "30");
			data.forEach((e) => {
				circle.setAttribute(e.field, e.value);
			});
			g.appendChild(circle);

			return circle;
		}

		//Listen to the UpdateValeusModal for circle spawn updates
		circlesToSpawn.listen((circles) => {
			console.log("New Circles!");
			const spacing = 2000 / circles.length;
			circles.map((e, id) => {
				console.log(circles);
				spawnCircle(e, id * spacing + 40, 70, []);
			});
			spawnLabel();
		});

		//Scale from center / scale from bounding box
		const scaleBoundingBoxToFitInstance = (svgElement, elArray) => {
			const circles = elArray;
			if (circles.length === 0) return;

			let minX = Infinity,
				maxX = -Infinity,
				minY = Infinity,
				maxY = -Infinity;

			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));
				const r = parseFloat(circle.getAttribute("r"));

				if (cx - r < minX) minX = cx - r;
				if (cx + r > maxX) maxX = cx + r;
				if (cy - r < minY) minY = cy - r;
				if (cy + r > maxY) maxY = cy + r;
			});

			const bboxWidth = maxX - minX;
			const bboxHeight = maxY - minY;

			const viewBox = svgElement.viewBox.baseVal;
			const svgWidth = viewBox.width;
			const svgHeight = viewBox.height;

			const margin = 0.2; // 1/5 margin

			const maxAllowedWidth = svgWidth * (1 - margin);
			const maxAllowedHeight = svgHeight * (1 - margin);

			const widthScale = maxAllowedWidth / bboxWidth;
			const heightScale = maxAllowedHeight / bboxHeight;

			const scale = Math.min(widthScale, heightScale, 1); // Scale down if necessary

			// Calculate the offset to center the scaled bounding box
			const offsetX = (svgWidth - bboxWidth * scale) / 2 - minX * scale;
			const offsetY = (svgHeight - bboxHeight * scale) / 2 - minY * scale;

			// Apply scaling and translation to each circle
			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));

				const newCx = cx * scale + offsetX;
				const newCy = cy * scale + offsetY;

				circle.setAttribute("cx", newCx.toFixed(4));
				circle.setAttribute("cy", newCy.toFixed(4));
				circle.setAttribute("r", 30);
			});

			spawnLabel();
		};

		// function startListeningForServerChanges() {
		// 	const eventSource = new EventSource('http://localhost:9234/events');

		// 	eventSource.onmessage = (event) => {
		// 		console.log('Server data changed:', event.data);
		// 		fetchDataFromServer(); // Call your function to fetch updated data
		// 	};

		// 	eventSource.onerror = (error) => {
		// 		console.error('EventSource error:', error);
		// 		eventSource.close(); // Optional: Close the connection on error
		// 	};
		// }

		async function fetchDataFromServer() {
			try {
				// Fetch the image data
				const imageResponse = await fetch(
					"http://localhost:9234/image",
				);
				if (!imageResponse.ok) throw new Error("Failed to fetch image");
				const { image, imageName } = await imageResponse.json();
				console.log({ image, imageName });

				// Convert the image buffer to a Blob
				const imageBlob = new Blob([new Uint8Array(image.data)], {
					type: "image/webp",
				}); // Update type if necessary
				const imageFile = new File([imageBlob], imageName, {
					type: "image/webp",
				});

				// Pass the image File object to handleFileChange
				handleFileChange(imageFile);
			} catch (error) {
				console.error("Error fetching image data from server:", error);
			}

			try {
				// Fetch the CSV data
				const csvResponse = await fetch("http://localhost:9234/csv");
				if (!csvResponse.ok) throw new Error("Failed to fetch CSV");
				const { csv, csvName } = await csvResponse.json();
				console.log({ csv, csvName });

				// Convert the CSV buffer to a Blob
				const csvBlob = new Blob([new Uint8Array(csv.data)], {
					type: "text/csv",
				});
				const csvFile = new File([csvBlob], csvName, {
					type: "text/csv",
				});

				// Pass the CSV File object to handleFileChange
				handleFileChange(csvFile);
			} catch (error) {
				console.error("Error fetching CSV data from server:", error);
			}
		}

		fetchDataFromServer();

		function spawnSVGNavigation() {
			// Check if navigation already exists and remove if needed
			let navContainer = document.getElementById("svg-nav");
			if (!navContainer) {
				navContainer = document.createElement("div");
				navContainer.id = "svg-nav";
				// Style the container as desired (here we center the arrows)
				navContainer.style.display = "flex";
				navContainer.style.justifyContent = "center";
				navContainer.style.marginTop = "1em";

				// Create left arrow button
				const leftArrow = document.createElement("button");
				leftArrow.id = "svg-prev";
				leftArrow.innerHTML = "&#8592;"; // left arrow symbol
				leftArrow.style.marginRight = "1em";

				// Create right arrow button
				const rightArrow = document.createElement("button");
				rightArrow.id = "svg-next";
				rightArrow.innerHTML = "&#8594;"; // right arrow symbol

				// Append the buttons to the nav container
				navContainer.appendChild(leftArrow);
				navContainer.appendChild(rightArrow);

				// Append the nav container to the document, e.g. just below your svg-container
				const svgContainer = document.getElementById("svg-container");
				svgContainer.parentNode.insertBefore(
					navContainer,
					svgContainer.nextSibling,
				);

				// Add event listeners to change the current SVG
				leftArrow.addEventListener("click", () => {
					if (currentSVGIndex > 0) {
						currentSVGIndex--;
						processSVG(importedSVGs[currentSVGIndex].element);
					}
				});
				rightArrow.addEventListener("click", () => {
					if (currentSVGIndex < importedSVGs.length - 1) {
						currentSVGIndex++;
						processSVG(importedSVGs[currentSVGIndex].element);
					}
				});
			}
		}

		// SVG Context Menu
		let svgContextMenu = null;
		let currentSVGElement = null;
		let svgFlipX = 1;
		let svgFlipY = 1;

		function createSVGContextMenu() {
			if (svgContextMenu) return svgContextMenu;

			svgContextMenu = document.createElement('div');
			svgContextMenu.id = 'svg-context-menu';
			Object.assign(svgContextMenu.style, {
				position: 'fixed',
				background: '#fff',
				border: '1px solid #ccc',
				borderRadius: '4px',
				boxShadow: '0 2px 10px rgba(0,0,0,.2)',
				zIndex: '10001',
				display: 'none',
				minWidth: '150px',
				padding: '4px 0'
			});

			const flipXItem = document.createElement('button');
			flipXItem.textContent = 'Flip X';
			Object.assign(flipXItem.style, {
				display: 'block',
				width: '100%',
				padding: '8px 12px',
				textAlign: 'left',
				background: 'none',
				border: 'none',
				cursor: 'pointer',
				fontSize: '14px',
				fontFamily: 'inherit'
			});
			flipXItem.addEventListener('mouseenter', () => {
				flipXItem.style.background = '#f0f0f0';
			});
			flipXItem.addEventListener('mouseleave', () => {
				flipXItem.style.background = 'none';
			});
			flipXItem.addEventListener('click', () => {
				flipSVGX();
				svgContextMenu.style.display = 'none';
			});

			const flipYItem = document.createElement('button');
			flipYItem.textContent = 'Flip Y';
			Object.assign(flipYItem.style, {
				display: 'block',
				width: '100%',
				padding: '8px 12px',
				textAlign: 'left',
				background: 'none',
				border: 'none',
				cursor: 'pointer',
				fontSize: '14px',
				fontFamily: 'inherit',
				borderTop: '1px solid #eee'
			});
			flipYItem.addEventListener('mouseenter', () => {
				flipYItem.style.background = '#f0f0f0';
			});
			flipYItem.addEventListener('mouseleave', () => {
				flipYItem.style.background = 'none';
			});
			flipYItem.addEventListener('click', () => {
				flipSVGY();
				svgContextMenu.style.display = 'none';
			});

			svgContextMenu.appendChild(flipXItem);
			svgContextMenu.appendChild(flipYItem);
			document.body.appendChild(svgContextMenu);

			return svgContextMenu;
		}

		function updateSVGTransform() {
			if (!currentSVGElement) return;
			
			// Use CSS transform instead of SVG transform to keep it within bounds
			const svgContainer = document.getElementById("svg-container");
			if (!svgContainer) return;
			
			// Ensure container has overflow hidden to prevent going out of bounds
			svgContainer.style.overflow = 'hidden';
			
			// Apply CSS transform to the SVG element
			currentSVGElement.style.transform = `scale(${svgFlipX}, ${svgFlipY})`;
			currentSVGElement.style.transformOrigin = 'center center';
		}

		function flipSVGX() {
			svgFlipX *= -1;
			updateSVGTransform();
		}

		function flipSVGY() {
			svgFlipY *= -1;
			updateSVGTransform();
		}

		function setupSVGContextMenu(svgElement) {
			if (!svgElement) return;

			createSVGContextMenu();
			currentSVGElement = svgElement;
			svgFlipX = 1;
			svgFlipY = 1;

			const preventContextMenu = (e) => {
				e.preventDefault();
				e.stopPropagation();
				if (svgContextMenu && currentSVGElement) {
					svgContextMenu.style.left = `${e.clientX}px`;
					svgContextMenu.style.top = `${e.clientY}px`;
					svgContextMenu.style.display = 'block';
				}
			};

			svgElement.addEventListener('contextmenu', preventContextMenu);
			
			const allChildren = svgElement.querySelectorAll('*');
			allChildren.forEach(child => {
				child.addEventListener('contextmenu', preventContextMenu);
			});
		}

		const processSVG = (svgElement) => {
			const list = svgElement.querySelectorAll(`[id]`);
			svgElement.setAttribute("data-csv-editor", "svg");
			document.getElementById("id-list").innerHTML = "";

			const processIdList = (idFormat) => {
				const regexLastUnderscore = /_(?=[^_]*$)/g;
				const regexLastDash = /-(?=[^-]*$)/g;
				const regexDashUnderscore = /\w+-\w+_\w+/;
				const regexText = /^[^-]*/;
				const regexGroupName = /^([A-Z]{2}\d{2}-\d{1,2})/;
				const regexUnitNumber = /(\d{1,3})\D*$/;

				const handleId = (currentId) => {
					const listItem = document.createElement("li");

					const regexResult =
						idFormat === format.fullUnderscore
							? currentId.replaceAll("-", "_")
							: !regexDashUnderscore.test(currentId)
								? currentId.replace(regexLastDash, "_")
								: currentId;

					const selected = svgElement.getElementById(`${currentId}`);
					const groupMatched = selected.id.match(regexGroupName);
					const unitMatched = selected.id.match(regexUnitNumber);

					if (groupMatched) {
						selected.setAttribute(
							"group-attribute",
							groupMatched[1],
						);
					}

					if (unitMatched) {
						selected.setAttribute("unit-attribute", unitMatched[1]);
					}

					selected.id = regexResult;
					listItem.innerHTML = regexResult;
					clusterId.push({
						id: object3dCount,
						clusterId: regexText.exec(regexResult)[0],
						unitId: regexResult,
					});

					object3dCount++;
					listItem.style.listStyle = "none";
					listItem.style.padding = "0.5em 0em";
					document.getElementById("id-list").append(listItem);
				};

				list.forEach((i) => {
					const currentId = i.id;

					if (idFormat === format.underscore) {
						handleId(currentId);
					} else if (idFormat === format.dash) {
						handleId(
							regexDashUnderscore.test(currentId)
								? currentId.replace(regexLastUnderscore, "-")
								: currentId,
						);
					} else if (
						idFormat === format.none ||
						idFormat === format.fullUnderscore
					) {
						handleId(currentId);
					}
				});
			};

			processIdList(idFormat);

			// Append the SVG element to the div element
			const svgContainer = document.getElementById("svg-container");
			svgContainer.innerHTML = "";
			// Ensure container has overflow hidden to prevent going out of bounds
			svgContainer.style.overflow = 'hidden';
			svgElement.setAttributeNS(null, "width", "100%");
			svgElement.setAttributeNS(null, "height", "100%");
			svgContainer.appendChild(svgElement);

			// Setup context menu for the SVG
			setupSVGContextMenu(svgElement);

			console.log(imageList.length)

			if (imageList.length > 0) {
					previewBackplate(
						document
							.getElementById("svg-container")
							.querySelector("svg"),
					)
			}

			// Set type for export filename
			type =
				idFormat === format.underscore
					? "underscore"
					: idFormat === format.dash
						? "dash"
						: "";
		};

		function getBaseName(fileName) {
			return fileName.replace(/\.[^/.]+$/, "").toLowerCase();
		}

		function handleDraggedImages(files) {
			const mediaFiles = Array.from(files).filter((file) =>
				file.type.startsWith("image/") || file.type.startsWith("video/"),
			);
			if (mediaFiles.length === 0) return;

			mediaFiles.forEach((mediaFile) => {
				const reader = new FileReader();
				const isVideo = mediaFile.type.startsWith("video/");
				reader.onload = (event) => {
					const contents = event.target.result;
					console.log(isVideo ? "Video File" : "Image File")
					console.log(mediaFile.name)
					const mediaBaseName = getBaseName(mediaFile.name);
					// Extract last 2 segments from media name
					// Example: "backplate_image_tower-floorplate_b1_01.webp" -> "b1_01"
					const mediaNameParts = mediaBaseName.split("_");
					const mediaLastTwoSegments = mediaNameParts.length >= 2 
						? mediaNameParts.slice(-2).join("_")
						: mediaBaseName;
					
					console.log(isVideo ? "Video name:" : "Image name:", mediaFile.name, "-> last 2 segments:", mediaLastTwoSegments)
					console.log(importedSVGs)
					// Loop through the imported SVG objects to find a matching name
					importedSVGs.forEach((svgObj) => {
						console.log("SVGOBJ")
						console.log(svgObj)
						const svgBaseName = getBaseName(svgObj.name);
						// Extract last 2 segments from SVG name
						// Example: "fahidbeachresidencesii_b1_01.svg" -> "b1_01"
						const svgNameParts = svgBaseName.split("_");
						const svgLastTwoSegments = svgNameParts.length >= 2 
							? svgNameParts.slice(-2).join("_")
							: svgBaseName;
						
						console.log("SVG name:", svgObj.name, "-> last 2 segments:", svgLastTwoSegments);
						
						if (svgLastTwoSegments === mediaLastTwoSegments) {
							console.log(svgBaseName)
							console.log(mediaBaseName)
							const svgElement = svgObj.element;
							const viewBox = svgElement.getAttribute("viewBox").split(" ");
							
							// Remove any existing background media (images, videos, foreignObject) before adding new one
							const existingImages = svgElement.querySelectorAll("image");
							existingImages.forEach(img => {
								// Only remove images that appear to be background images (full size)
								const imgWidth = img.getAttribute("width");
								const imgHeight = img.getAttribute("height");
								
								if (imgWidth === viewBox[2] && imgHeight === viewBox[3]) {
									img.remove();
									console.log("Removed existing background image from SVG");
								}
							});
							
							// Remove existing foreignObject elements (videos)
							const existingForeignObjects = svgElement.querySelectorAll("foreignObject");
							existingForeignObjects.forEach(fo => {
								const foWidth = fo.getAttribute("width");
								const foHeight = fo.getAttribute("height");
								if (foWidth === viewBox[2] && foHeight === viewBox[3]) {
									fo.remove();
									console.log("Removed existing background video from SVG");
								}
							});
							
							if (isVideo) {
								// Create a <foreignObject> to contain HTML video element
								const foreignObject = document.createElementNS(
									"http://www.w3.org/2000/svg",
									"foreignObject",
								);
								foreignObject.setAttributeNS(null, "x", "0");
								foreignObject.setAttributeNS(null, "y", "0");
								foreignObject.setAttributeNS(null, "width", viewBox[2]);
								foreignObject.setAttributeNS(null, "height", viewBox[3]);
								
								// Create video element
								const video = document.createElement("video");
								video.src = contents;
								video.style.width = "100%";
								video.style.height = "100%";
								video.style.objectFit = "cover";
								video.setAttribute("loop", "");
								video.setAttribute("muted", "");
								video.setAttribute("autoplay", "");
								video.setAttribute("playsinline", "");
								
								foreignObject.appendChild(video);
								console.log("Adding new background video to SVG");
								svgElement.insertBefore(foreignObject, svgElement.firstChild);
							} else {
								// Create an <image> element for the SVG
								const svgImage = document.createElementNS(
									"http://www.w3.org/2000/svg",
									"image",
								);
								svgImage.setAttributeNS(null, "href", contents);
								svgImage.setAttributeNS(null, "x", "0");
								svgImage.setAttributeNS(null, "y", "0");
								svgImage.setAttributeNS(null, "width", viewBox[2]);
								svgImage.setAttributeNS(null, "height", viewBox[3]);
								// Insert the image as the first child (or adjust position as needed)
								console.log("Adding new background image to SVG");
								svgElement.insertBefore(svgImage, svgElement.firstChild);
							}
						}
					});
				};
				reader.readAsDataURL(mediaFile);
			});
		}

		function handleFileChange(files) {
			console.log(files);
			const file = files[0];
			// Determine if this is a raster image or video import (jpeg/png/webp/mp4/webm)
			const isRasterMedia =
				file && (file.type === "image/jpeg" || file.type === "image/png" || file.type === "image/webp" || file.type.startsWith("video/"));

			// Only reset global states when not importing a raster media (image/video)
			if (!isRasterMedia) {
				flipped = false;
				object3dCount = 0;
				globalFloors = [];
				globalFloorsAggregated = [];
				canvasFlipX = false;
				canvasFlipY = false;
				canvasRotate = 0;
			}
			// if(!document.getElementById("image-list-container").classList.contains("hidden")){
			// 	document.getElementById("image-list-container").classList.add("hidden")
			// }

			// if (files.length === 1) {
			// 	importedSVGs = [];
			// 	currentSVGIndex = 0;
			// 	globalSvgContainer.innerHTML = "";
			// }
			// importedSVGs = []; // Reset the array
			let filesToProcess = Array.from(files).filter(
				(file) => file.type === "image/svg+xml",
			);

			// if (filesToProcess.length === 0) {
			// 	alert("Please import valid SVG files.");
			// 	return;
			// }

			// Only reset UI/toggles when not importing a raster media (jpeg/png/webp/video)
			if (!isRasterMedia) {
				updateResetButtons();

				// Refresh show floors section
				const floorSection = document.getElementById("show-floors");
				floorSection.querySelectorAll("div").forEach((e) => {
					e.remove();
				});
				if (!floorSection.classList.contains("hidden")) {
					floorSection.classList.add("hidden");
				}

				if (document.getElementById("showLabelsDiv")) {
					document.getElementById("showLabelsDiv").remove();
				}
			}
			console.log(files.length)
			if(files.length > 1){
				
				if (file.type === "image/svg+xml") {
					if(document.getElementById("image-list-container").classList.contains("hidden")){
						document.getElementById("image-list-container").classList.remove("hidden")
					}
				Array.from(files).forEach((fileToProcess, index) => {
					const reader = new FileReader();
					reader.onload = () => {
						const svgString = reader.result;
						const parser = new DOMParser();
						const svgDoc = parser.parseFromString(
							svgString,
							"image/svg+xml",
						);
						// For each file, we assume the root element is the SVG element
						const svgElement = svgDoc.documentElement;
						importedSVGs.push({ name: getBaseName(fileToProcess.name), element: svgElement });

						// Once all files have been processed, show the first one and spawn navigation
						if (importedSVGs.length === filesToProcess.length) {
							currentSVGIndex = 0;
							processSVG(importedSVGs[currentSVGIndex].element);
							if (importedSVGs.length > 1) {
								spawnSVGNavigation();
							} else {
								// Remove navigation if only one SVG is imported
								const existingNav =
									document.getElementById("svg-nav");
								if (existingNav) existingNav.remove();
							}
						}
					};
					reader.readAsText(fileToProcess);
				});
			} else if (
				file.type === "image/jpeg" ||
				file.type === "image/png" ||
				file.type === "image/webp" ||
				file.type.startsWith("video/")
			) {
				handleDraggedImages(files)
			} else if (file.type === "text/csv") {
			}
			} else {
				if (file.type === "image/svg+xml") {
					if(document.getElementById("image-list-container").classList.contains("hidden")){
						document.getElementById("image-list-container").classList.remove("hidden")
					}
					    importedSVGs = [];
					currentSVGIndex = 0;
					globalSvgContainer.innerHTML = "";

				filesToProcess.forEach((fileToProcess, index) => {
					const reader = new FileReader();
					reader.onload = () => {
						const svgString = reader.result;
						const parser = new DOMParser();
						const svgDoc = parser.parseFromString(
							svgString,
							"image/svg+xml",
						);
						// For each file, we assume the root element is the SVG element
						const svgElement = svgDoc.documentElement;
						importedSVGs.push({ name: getBaseName(file.name), element: svgElement });

						// Once all files have been processed, show the first one and spawn navigation
						if (importedSVGs.length === filesToProcess.length) {
							currentSVGIndex = 0;
							processSVG(importedSVGs[currentSVGIndex].element);
							if (importedSVGs.length > 1) {
								spawnSVGNavigation();
							} else {
								// Remove navigation if only one SVG is imported
								const existingNav =
									document.getElementById("svg-nav");
								if (existingNav) existingNav.remove();
							}
						}
					};
					reader.readAsText(fileToProcess);
				});
			} else if (
				file.type === "image/jpeg" ||
				file.type === "image/png" ||
				file.type === "image/webp" ||
				file.type.startsWith("video/")
			) {
				const isVideo = file.type.startsWith("video/");
				fileNameGlobal = file.name
					.replace("backplate_image_camera", "csv_floorplan")
					.replace("backplate_image_floorplan", "csv_floorplan")
					.replace("camera", "floorplan");
				document.getElementById("export-file-name").value =
					fileNameGlobal;
				const reader = new FileReader();
				reader.onload = (event) => {
					const contents = event.target.result;
					const svgContainer =
						document.getElementById("svg-container");
					// Use any existing SVG (including one created by CSV import). Do not clear container if found.
					var internalSVG = svgContainer.querySelector("svg");

					if (!internalSVG) {
						// No SVG yet; create a new one
						const newSVG = createNewSVG();
						svgContainer.appendChild(newSVG);
						internalSVG = newSVG;
					}

					const svgViewbox = internalSVG.getAttribute("viewBox").split(" ");

					// Remove any existing background images before adding new one
					const existingImages = internalSVG.querySelectorAll("image");
					existingImages.forEach(img => {
						// Only remove images that appear to be background images (full size)
						const imgWidth = img.getAttribute("width");
						const imgHeight = img.getAttribute("height");
						
						if (imgWidth === svgViewbox[2] && imgHeight === svgViewbox[3]) {
							img.remove();
							console.log("Removed existing background image");
						}
					});

					// Remove existing foreignObject elements (videos)
					const existingForeignObjects = internalSVG.querySelectorAll("foreignObject");
					existingForeignObjects.forEach(fo => {
						const foWidth = fo.getAttribute("width");
						const foHeight = fo.getAttribute("height");
						if (foWidth === svgViewbox[2] && foHeight === svgViewbox[3]) {
							fo.remove();
							console.log("Removed existing background video");
						}
					});

					if (isVideo) {
						// Create a <foreignObject> to contain HTML video element
						const foreignObject = document.createElementNS(
							"http://www.w3.org/2000/svg",
							"foreignObject",
						);
						foreignObject.setAttributeNS(null, "x", "0");
						foreignObject.setAttributeNS(null, "y", "0");
						foreignObject.setAttributeNS(null, "width", svgViewbox[2]);
						foreignObject.setAttributeNS(null, "height", svgViewbox[3]);
						
						// Create video element
						const video = document.createElement("video");
						video.src = contents;
						video.style.width = "100%";
						video.style.height = "100%";
						video.style.objectFit = "cover";
						video.setAttribute("loop", "");
						video.setAttribute("muted", "");
						video.setAttribute("autoplay", "");
						video.setAttribute("playsinline", "");
						
						foreignObject.appendChild(video);
						console.log("Adding new background video");
						internalSVG.insertBefore(foreignObject, internalSVG.firstChild);
					} else {
						const svgImage = document.createElementNS(
							"http://www.w3.org/2000/svg",
							"image",
						);
						svgImage.setAttributeNS(null, "href", contents);
						svgImage.setAttributeNS(null, "x", "0");
						svgImage.setAttributeNS(null, "y", "0");
						svgImage.setAttributeNS(null, "width", svgViewbox[2]);
						svgImage.setAttributeNS(null, "height", svgViewbox[3]);

						console.log("Adding new background image");
						internalSVG.insertBefore(svgImage, internalSVG.firstChild);
					}
				};
				reader.readAsDataURL(file);
			} else if (file.type === "text/csv") {
				if (
					document
						.getElementById("svg-container")
						.getElementsByTagName("p").length > 0
				) {
					Array.from(
						document
							.getElementById("svg-container")
							.getElementsByTagName("p"),
					).forEach((e) => {
						e.remove();
					});
				}

				fileNameGlobal = file.name
					.replace("backplate_image_camera", "csv_floorplan")
					.replace("backplate_image_floorplan", "csv_floorplan")
					.replace("camera", "floorplan");

				document.getElementById("export-file-name").value =
					fileNameGlobal;
				const reader = new FileReader();
				reader.onload = (event) => {
					const contents = event.target.result;
					const lines = contents.trim().split("\n");

					// Check the number of columns and decide to transform
					const firstLineFields = lines[0].split(",");
					let transformedLines = lines;
					let scaleToFit = false;
					//column > 3
					if (firstLineFields.length > 3) {
						// Transform the data if more than three columns
						transformedLines = lines.map((line) => {
							const fields = line.split(",");

							const [name, x, y, z] = fields;
							const cleanedName = `${name.split("_")[0]}~${name.split("_")[1]}`; //Curly line for easier text separation
							scaleToFit = true;

							return `${cleanedName},${-y},${-x},${name}`; // Swap x and y
						});
					}

					var gInstance = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"g",
					); //Create group to contain all points
					gInstance.setAttribute("id", "g-instance");
					const svgContainer =
						document.getElementById("svg-container");

					if (svgContainer.querySelector("svg")) {
						//If SVG already exists
						svgContainer
							.querySelector("svg")
							.querySelectorAll("g")
							.forEach((g) => {
								if (g.id !== "Reference") {
									g.remove();
									console.log(g);
									console.log("^ removed");
								}
							});
					} else {
						const newSVG = createNewSVG();
						newSVG.appendChild(gInstance);
						svgContainer.appendChild(newSVG);

						if (svgContainer.querySelector("img")) {
							const tempImage = svgContainer.querySelector("img");
							const svgimg = document.createElementNS(
								"http://www.w3.org/2000/svg",
								"image",
							);
							svgimg.style.width = "100%";
							svgimg.style.height = "100%";
							svgimg.setAttributeNS(
								"http://www.w3.org/1999/xlink",
								"xlink:href",
								tempImage.src,
							);
							newSVG.append(svgimg);
							tempImage.remove();
						}
					}

					svgContainer.querySelector("svg").appendChild(gInstance); //Add g into the svg

					// Check if this is a project CSV (has Position_X_Meters header)
					const isProjectCSV = lines[0] && lines[0].toLowerCase().includes('position_x_meters');
					
					if (isProjectCSV) {
						console.log('Project CSV detected - processing as Project CSV');
						renderProjectCsvPreview(contents);
						return; // Skip simple CSV processing
					}

					//Floors
					for (let i = 0; i < transformedLines.length; i++) {
						const fields = transformedLines[i].split(",");

						if (Number(fields[1]) || Number(fields[2])) {
							const floor = fields[0].includes("~")
								? fields[0].split("~")[0]
								: null;
							const name = fields[0].includes("~")
								? fields[0].split("~")[1]
								: fields[0];

							const data = [];
							if (floor) {
								const floorData = {
									field: "data-floor",
									value: floor,
								};
								data.push(floorData);
							}

							const fullName = {
								// Custom attribute to be used as unique identifier for functions
								field: "data-fullname",
								value: fields[3],
							};
							data.push(fullName);

							globalFloors.push({
								floor: floor,
								circle: spawnCircle(
									name,
									Number(fields[flipYX ? 2 : 1]).toFixed(4),
									Number(fields[flipYX ? 1 : 2]).toFixed(4),
									data,
								),
							});
						} else {
							console.error(
								`${
									fields[0]
										? fields[0]
										: `(Nameless), Row ${i + 1}`
								} does not contain any cx, cy data`,
							);
						}
					}

					//Floor section
					//Dynamically add Floors section
					var floorNumbers = [];
					const labelDivInstance =
						document.getElementById("labelDiv");
					if (labelDivInstance) {
						labelDivInstance.remove();
					}
					globalFloors.forEach((e) => {
						if (!floorNumbers.includes(e.floor)) {
							floorNumbers.push(e.floor);
						}
					});

					console.log(floorNumbers);
					console.log(globalFloors);

					if (floorNumbers.length > 0) {
						const floorSection =
							document.getElementById("show-floors");
						if (floorSection.classList.contains("hidden")) {
							floorSection.classList.remove("hidden");
						}

						checkboxesId = [];

						floorNumbers.forEach((e) => {
							const div = document.createElement("div");
							const checkbox = document.createElement("input");
							const label = document.createElement("label");

							label.innerText = `Floor ${e}`;
							label.htmlFor = `floor-${e}-checkbox`;
							checkbox.type = "checkbox";
							checkbox.checked = true;
							checkbox.id = `floor-${e}-checkbox`;

							checkboxesId.push(`floor-${e}-checkbox`);
							div.appendChild(checkbox);
							div.appendChild(label);

							checkbox.addEventListener("change", (e) => {
								toggleFloors(aggregatePoints);
								spawnLabel();
							});

							floorSection.appendChild(div);
						});
					}

					//globalFloorsAggregated contains average positioned circle of multicamera points
					const globalFloorsCopy = Object.assign(globalFloors);
					globalFloorsAggregated =
						getAveragedCircles(globalFloorsCopy);

					if (document.getElementById("aggregate-points-parent")) {
						document
							.getElementById("aggregate-points-parent")
							.remove();
					}
					const editOptions = document.getElementById("edit-options");
					const div = document.createElement("div");
					div.id = "aggregate-points-parent";
					const aggregateOptionsCheckbox =
						document.createElement("input");
					const label = document.createElement("label");
					div.classList.add("col-span-2");
					div.classList.add("mt-2");
					label.innerText = `Aggregate points`;
					label.classList.add("ml-1");
					label.htmlFor = `aggregate-points`;
					aggregateOptionsCheckbox.type = "checkbox";
					aggregateOptionsCheckbox.checked = true; // Default to checked
					aggregateOptionsCheckbox.id = `aggregate-points`;
					div.appendChild(aggregateOptionsCheckbox);
					div.appendChild(label);
					editOptions.appendChild(div);

					// Set aggregate points to true by default and apply it
					aggregatePoints = true;
					toggleFloors(aggregatePoints);
					spawnLabel();

					aggregateOptionsCheckbox.addEventListener("change", (e) => {
						aggregatePoints = e.target.checked;
						toggleFloors(aggregatePoints);
						spawnLabel();
					});

					// Scale bounding box to fit within the SVG frame
					if (scaleToFit) {
						const globalCircle = globalFloors.map(
							(item) => item.circle,
						);
						const globalAggregateCircle =
							globalFloorsAggregated.map((item) => item.circle);
						const totalCircles = [
							...globalCircle,
							...globalAggregateCircle,
						];
						scaleBoundingBoxToFitInstance(
							svgContainer.querySelector("svg"),
							totalCircles,
						);
					}
					// scaleBoundingBoxToFit(svgContainer.querySelector("svg"));
				};
				reader.readAsText(file);

				labelToggle();

				//Lord will spite me for this method
				setTimeout((e) => {
					spawnLabel();
				}, 50);
			}
			}


		}

		function labelToggle() {
			if (!document.getElementById("showLabelsDiv")) {
				//Add Toggle Label Checkbox
				const showLabelsDiv = document.createElement("div");
				showLabelsDiv.id = "showLabelsDiv";
				const showLabelsToggle = document.createElement("input");
				const showLabelsLabel = document.createElement("label");
				showLabelsLabel.textContent = "Toggle Labels";
				showLabelsLabel.setAttribute("for", "showLabelsToggle");

				showLabelsToggle.type = "checkbox";
				showLabelsToggle.style.padding = "0.5em";
				showLabelsToggle.style.height = "fit-content";
				showLabelsToggle.id = "showLabelsToggle";

				showLabelsDiv.appendChild(showLabelsToggle);
				showLabelsDiv.appendChild(showLabelsLabel);
				document
					.getElementById("editor-button-container")
					.appendChild(showLabelsDiv);

				showLabelsToggle.addEventListener("change", (e) => {
					if (e.target.checked) {
						spawnLabel();
					} else {
						killLabels();
					}
				});

				showLabelsToggle.checked = true;
			}
		}

		const imageList = [];
		let useDefaultMatching = true; // Default matching mode enabled by default
		
		// Toggle for matching mode
		document.getElementById("matching-mode-toggle").addEventListener("change", (e) => {
			useDefaultMatching = e.target.checked;
			const label = document.getElementById("matching-mode-label");
			if (useDefaultMatching) {
				label.textContent = "Default Matching (Final 3 elements in image name)";
			} else {
				label.textContent = "Custom Matching (Text replacement + substring)";
			}

		});
		
		document.getElementById("check-floorplans-button").addEventListener("change", (e) => {
			console.log("Change") 
			uploadImages(e)
		});

		// Upload unit-reference handler
		document.getElementById("upload-unit-reference-button").addEventListener("change", (e: any) => {
			const file = e.target.files[0];
			if (!file) return;
			
			const reader = new FileReader();
			reader.onload = (event: any) => {
				try {
					const jsonData = JSON.parse(event.target.result);
					let unitsArray = null;
					
					// Handle different JSON structures
					if (Array.isArray(jsonData)) {
						// Direct array format: [{...}, {...}]
						unitsArray = jsonData;
					} else if (jsonData.unitReference && Array.isArray(jsonData.unitReference.units)) {
						// Wrapped in unitReference.units: {"unitReference": {"units": [{...}]}}
						unitsArray = jsonData.unitReference.units;
					} else if (Array.isArray(jsonData.units)) {
						// Wrapped in units: {"units": [{...}]}
						unitsArray = jsonData.units;
					} else {
						console.error("Unexpected JSON structure:", jsonData);
						alert("Invalid format: Expected an array of unit objects, or an object with 'units' or 'unitReference.units' property");
						return;
					}
					
					if (unitsArray && unitsArray.length > 0) {
						importedUnitReference = unitsArray;
						console.log("ðŸ“¥ Imported unit-reference:", {
							count: unitsArray.length,
							units: unitsArray.map((unit: any) => ({
								name: unit.name,
								type: unit.type,
								rotation: unit.rotation,
								flip: unit.flip,
								identifier: getUnitIdentifier(unit.name || "")
							}))
						});
						
						// Update preview if currently showing an image
						if (currentHoveredImageName) {
							const transform = getImageTransform(currentHoveredImageName);
							updatePreviewText(currentHoveredImageName, transform);
						}
						
						console.log(`Successfully imported ${unitsArray.length} unit(s)`);
					} else {
						console.log("No units found in the file");
					}
				} catch (error) {
					console.error("Error parsing unit-reference JSON:", error);
					console.log("Error parsing JSON file. Please check the format.");
				}
			};
			reader.readAsText(file);
		});

		// Export unit-reference handler
		document.getElementById("export-unit-reference-button").addEventListener("click", () => {
			if (!importedUnitReference || importedUnitReference.length === 0) {
				console.log("No imported unit-reference data to export. Please upload a unit-reference file first.");
				return;
			}
			
			// Merge imported data with current transform values
			const mergedData = importedUnitReference.map((unit: any) => {
				const unitName = unit.name || "";
				const identifier = getUnitIdentifier(unitName);
				
				// Get imported rotation
				let importedRotation = typeof unit.rotation === 'string' ? parseInt(unit.rotation) : unit.rotation;
				
				// Find matching transform by identifier
				const transform = identifier && imageTransformLookup[identifier] ? imageTransformLookup[identifier] : null;
				
				// Calculate final rotation: importedRotation + change (if transform exists)
				let rotation = importedRotation;
				let flip = unit.flip;
				
			if (transform) {
				// Final rotation = importedRotation + change
				const rotationChange = transform.rotation || 0;
				rotation = importedRotation + rotationChange;
				
				// Normalize rotation to -90 to 180 degrees
				while (rotation < -90) rotation += 360;
				while (rotation > 180) rotation -= 360;
				
				// For flip: apply change relative to imported (XOR logic)
				// transform.flip represents whether user has toggled it (change)
				const importedFlipBool = typeof unit.flip === 'string' ? unit.flip === 'true' : unit.flip;
				flip = importedFlipBool !== transform.flip; // XOR: final = imported XOR change
			} else {
				// Use imported values as-is
				if (typeof rotation === 'string') {
					rotation = parseInt(rotation);
				}
				// Normalize rotation even if no transform
				while (rotation < -90) rotation += 360;
				while (rotation > 180) rotation -= 360;
			}
				
				// Convert flip to string format ("true" or "false")
				const flipString = typeof flip === 'boolean' ? flip.toString() : (flip === 'true' || flip === true ? 'true' : 'false');
				
				return {
					name: unit.name,
					type: unit.type,
					flip: flipString,
					rotation: rotation
				};
			});
			
			// Create and download JSON file
			const jsonString = JSON.stringify(mergedData, null, 2);
			const blob = new Blob([jsonString], { type: "application/json" });
			const url = URL.createObjectURL(blob);
			const a = document.createElement("a");
			a.href = url;
			a.download = "unit-reference.json";
			document.body.appendChild(a);
			a.click();
			document.body.removeChild(a);
			URL.revokeObjectURL(url);
			
			console.log("Exported unit-reference:", mergedData);
			console.log(`Successfully exported ${mergedData.length} unit(s)`);
		});

		document.getElementById("clear-images").addEventListener("click", () => {
			// 1. empty the array that the previewer uses
			imageList.splice(0, imageList.length);

			// 2. remove thumbnails
			const carousel = document.getElementById("image-list-carousel");
			if (carousel) carousel.innerHTML = "";

			// 3. hide the image-list UI if it's open
			const imgListContainer = document.getElementById("image-carousel-container");
			if (imgListContainer && imgListContainer.classList.contains("flex")) {
				imgListContainer.classList.remove("flex");
				imgListContainer.classList.add("hidden");
			}

			// 4. hide the floating previewer if it exists
			const previewer = document.getElementById("image-previewer-container");
			if (previewer) previewer.style.display = "none";
			
		});


		function uploadImages(e) {
			const files = Array.from(e.target.files);

			const readFile = (file) => {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onload = (data) =>
						resolve({ name: file.name, data: data.target.result });
					reader.onerror = (error) => reject(error);
					reader.readAsDataURL(file);
				});
			};

			if (
				document
					.getElementById("image-carousel-container")
					.classList.contains("hidden")
			) {
				document
					.getElementById("image-carousel-container")
					.classList.remove("hidden");
				document
					.getElementById("image-carousel-container")
					.classList.add("flex");
			}

			Promise.all(Array.from(files).map(readFile))
				.then((results) => {
					imageList.splice(0, imageList.length);
					imageList.push(...results);
					const imageListCarousel = document.getElementById(
						"image-list-carousel",
					);
					imageListCarousel.innerHTML = "";
					imageList.forEach((image) => {
						const listItem = document.createElement("li");
						listItem.style.height = "100%";
						const imageElement = document.createElement("img");
						imageElement.src = image.data;
						imageElement.style.height = "60px";
						// imageElement.setAttribute("data-name", image.name)
						listItem.appendChild(imageElement);
						imageListCarousel.appendChild(listItem);
					});
					previewBackplate(
						document
							.getElementById("svg-container")
							.querySelector("svg"),
					);
				})
				.catch((error) =>
					console.error("Error loading images:", error),
				);
		}

		// Helper function to parse image name and extract the 4th segment (with 2 dashes)
		function parseImageName(imageName) {
			if (!imageName) return null;
			const parts = imageName.split("_");
			if (parts.length < 4) return null;
			
			// Find the 4th segment (index 3) that contains exactly 2 dashes
			const fourthSegment = parts[3];
			if (!fourthSegment) return null;
			
			// Count dashes in the 4th segment
			const dashCount = (fourthSegment.match(/-/g) || []).length;
			if (dashCount === 2) {
				return fourthSegment;
			}
			
			return null;
		}

		// Helper function to get the unit identifier from a name (handles both image names and unit names)
		function getUnitIdentifier(name) {
			if (!name) return null;
			
			// First try parsing as image name (has 4+ segments with _)
			const parsedFromImage = parseImageName(name);
			if (parsedFromImage) return parsedFromImage;
			
			// If not found, check if the name itself is already in the format (e.g., "a-01-01")
			// Check if it has exactly 2 dashes (unit identifier format)
			const dashCount = (name.match(/-/g) || []).length;
			if (dashCount === 2 && !name.includes("_")) {
				// It's already a unit identifier (e.g., "a-01-01")
				return name;
			}
			
			return null;
		}

		// Helper function to get or create transformation entry
		function getImageTransform(imageName) {
			const identifier = getUnitIdentifier(imageName);
			if (!identifier) return null;
			
			if (!imageTransformLookup[identifier]) {
				imageTransformLookup[identifier] = {
					name: identifier,
					flip: false,
					rotation: 0
				};
			}
			
			return imageTransformLookup[identifier];
		}

		// Helper function to apply transformation to image element
		function applyImageTransform(imgElement, transform, importedRotation = null, importedFlip = null) {
			if (!imgElement || !transform) return;
			
			// Set transform origin to center (50% 50%) for rotation around center
			imgElement.style.transformOrigin = "center center";
			imgElement.style.transformOrigin = "50% 50%";
			
			// Calculate final rotation: importedRotation + change (if imported exists)
			const rotationChange = transform.rotation || 0;
			const finalRotation = importedRotation !== null ? importedRotation + rotationChange : rotationChange;
			
			// Calculate final flip: importedFlip XOR change (if imported exists)
			const finalFlip = importedFlip !== null ? (importedFlip !== transform.flip) : transform.flip;
			
			// Build transform string - apply rotation and flip
			let transformParts = [];
			
			// Apply final rotation
			if (finalRotation !== 0) {
				transformParts.push(`rotate(${finalRotation}deg)`);
			}
			
			// Apply final flip
			if (finalFlip) {
				transformParts.push(`scaleX(-1)`);
			}
			
			// Combine all transforms
			const transformString = transformParts.join(" ");
			imgElement.style.transform = transformString || "none";
		}

		// Helper function to update preview text with transform values
		function updatePreviewText(imageName, transform) {
			const previewTextEl = document.getElementById("image-previewer-text");
			if (!previewTextEl || !imageName) return;
			
			// Find the original image to get its name
			const selectedImage = imageList.find((img) => img.name === imageName);
			if (!selectedImage) return;
			
			// Check if this unit exists in imported unit-reference
			// Match by the 4th segment (with 2 dashes) from the image name, or direct match for unit names
			// NOTE: Sequence of loading doesn't matter - matching happens on hover after all data is available
			const imageIdentifier = getUnitIdentifier(imageName);
			let importedUnit = null;
			
			console.log("ðŸ” Hover - Unit Matching:", {
				imageName: imageName,
				imageIdentifier: imageIdentifier,
				hasImportedData: !!importedUnitReference,
				importedDataCount: importedUnitReference?.length || 0,
				imageListCount: imageList.length
			});
			
			if (imageIdentifier && importedUnitReference) {
				// Try to find matching unit by identifier (handles both image names and unit names)
				importedUnit = importedUnitReference.find((unit: any) => {
					const unitIdentifier = getUnitIdentifier(unit.name || "");
					const matches = unitIdentifier === imageIdentifier;
					if (matches) {
						console.log("âœ… Match found:", {
							unitName: unit.name,
							unitIdentifier: unitIdentifier,
							imageIdentifier: imageIdentifier,
							unitData: {
								name: unit.name,
								type: unit.type,
								rotation: unit.rotation,
								flip: unit.flip
							}
						});
					}
					return matches;
				});
				
				if (!importedUnit && imageIdentifier) {
					const availableIdentifiers = importedUnitReference
						.map((u: any) => getUnitIdentifier(u.name || ""))
						.filter(Boolean);
					console.log("âŒ No match found for imageIdentifier:", imageIdentifier, "Available identifiers:", availableIdentifiers);
				}
			} else if (imageIdentifier) {
				console.log("âš ï¸ No imported unit-reference data available yet");
			} else {
				console.log("âš ï¸ Could not extract identifier from image name:", imageName);
			}
			
			// Get rotation CHANGE from transform (this is the delta, not the absolute value)
			const rotationChange = transform?.rotation || 0;
			const currentFlip = transform?.flip || false;
			
			// Get imported rotation (convert string to number if needed)
			const importedRotation = importedUnit ? 
				(typeof importedUnit.rotation === 'string' ? parseInt(importedUnit.rotation) : importedUnit.rotation) : 
				null;
			const importedFlip = importedUnit ? 
				(typeof importedUnit.flip === 'string' ? importedUnit.flip === 'true' : importedUnit.flip) : 
				null;
			
			// Calculate final rotation: importedRotation + rotationChange (change is added to imported)
			const finalRotation = importedRotation !== null ? importedRotation + rotationChange : rotationChange;
			
			// Log offsets and changes
			console.log("ðŸ“Š Unit Offsets & Changes:", {
				unitName: imageName,
				imageIdentifier: imageIdentifier,
				importedUnit: importedUnit ? {
					name: importedUnit.name,
					type: importedUnit.type,
					rotation: importedUnit.rotation,
					flip: importedUnit.flip
				} : null,
				currentTransform: transform ? {
					rotationChange: rotationChange,
					flipChange: currentFlip
				} : null,
				offsets: {
					rotation: importedRotation !== null ? {
						imported: importedRotation,
						change: rotationChange,
						final: finalRotation
					} : null,
					flip: importedFlip !== null ? {
						imported: importedFlip,
						change: currentFlip,
						final: importedFlip !== currentFlip // XOR: final flip
					} : null
				}
			});
			
			// Format transform values
			let transformParts = [];
			let rotationDisplay = "";
			
			// If imported data exists AND transform has been applied, show change format
			if (importedRotation !== null && transform) {
				// Show: importedRotation -> finalRotation (where finalRotation = importedRotation + change)
				rotationDisplay = `rot:${importedRotation}Â° -> ${finalRotation}Â°`;
				transformParts.push(rotationDisplay);
			} else if (transform && rotationChange !== 0) {
				// No imported data, just show the change as final rotation
				rotationDisplay = `rot:${finalRotation}Â°`;
				transformParts.push(rotationDisplay);
			} else if (importedRotation !== null) {
				// Show imported rotation even if no transform applied yet
				rotationDisplay = `rot:${importedRotation}Â°`;
				transformParts.push(rotationDisplay);
			}
			
			// Add flip if present - show final flip value (imported XOR change)
			if (transform) {
				const finalFlip = importedFlip !== null ? (importedFlip !== transform.flip) : transform.flip;
				if (finalFlip) {
					if (importedFlip !== null) {
						// Show imported -> final format
						transformParts.push(`<br>flip:${importedFlip} -> ${finalFlip}`);
					} else {
						transformParts.push("<br>flip:true");
					}
				}
			} else if (importedFlip !== null && importedFlip) {
				// Show imported flip if no transform
				transformParts.push("<br>flip:true");
			}
			
			// Determine if rotation display should be blue (exists in imported data)
			const rotationStyle = importedUnit && importedRotation !== null ? "color: #3b82f6; font-weight: normal;" : "font-weight: normal; color: #666;";
			const nameStyle = "font-weight: normal;";
			
			// Create structure with flex layout for spacing
			if (transformParts.length > 0) {
				previewTextEl.innerHTML = `
					<div style="display: flex; justify-content: space-between; align-items: center; width: 100%; font-size: 10px; font-weight: normal;">
						<span style="${nameStyle}">${selectedImage.name}</span>
						<span style="${rotationStyle}">${transformParts.join(", ")}</span>
					</div>
				`;
			} else {
				previewTextEl.innerHTML = `<div style="font-size: 10px; font-weight: normal;"><span style="${nameStyle}">${selectedImage.name}</span></div>`;
			}
		}

		// Function to get the image transformation lookup object
		function getImageTransformLookup() {
			// Return array of transformation objects
			return Object.values(imageTransformLookup);
		}

		// Expose lookup on window for debugging/export
		(window as any).getImageTransformLookup = getImageTransformLookup;

		function previewBackplate(parentSVG) {
			const listeners = [];
			listeners.forEach((e) => {
				removeEventListener("hover", e);
			});

			let previewerInstance = document.getElementById("image-previewer");
			console.log("previewing")
			if (!previewerInstance) {
				const newPreviewer = document.createElement("div");
				const previewerImg = document.createElement("img");
				const previewerText = document.createElement("p");
				newPreviewer.id = "image-previewer-container";
				newPreviewer.style.padding = "5px";
				newPreviewer.style.position = "fixed";
				newPreviewer.style.display = "flex";
				newPreviewer.style.flexDirection = "flex-column";
				newPreviewer.style.backgroundColor = "#cccccccc";
				newPreviewer.style.borderRadius = "10px";
				newPreviewer.style.alignContent = "align-center";
				newPreviewer.style.justifyContent = "justify-center";
				newPreviewer.style.justifyItems = "justify-center";
				newPreviewer.style.transform = "translate(-50%, -113%)";
				newPreviewer.style.width = "310px";
				previewerImg.id = "image-previewer-image";
				previewerImg.style.width = "300px";
				previewerImg.style.marginBottom = "10px";
				newPreviewer.appendChild(previewerImg);
				previewerText.id = "image-previewer-text";
				previewerText.style.fontSize = "10px";
				previewerText.style.fontWeight = "normal";
				newPreviewer.appendChild(previewerText);
				document.querySelector("body").appendChild(newPreviewer);
			}

			parentSVG.querySelectorAll("path").forEach((path) => {
				const listener = path.addEventListener("mouseover", (e) => {
					document.getElementById(
						"image-previewer-container",
					).style.display = "block";
					const textReplacement = document.getElementById("text-replacement").value;
					
					let selectedImage;
					
					if (useDefaultMatching) {
						// DEFAULT MATCHING LOGIC:
						// Extract final 3 elements from Path ID (separated by _)
						// Match to 4th element of image name (separated by _)
						// Remove all separators (space, -, _) during matching
						
						const pathIdParts = e.target.id.split("_");
						const pathFinalThreeElements = pathIdParts.slice(-3).join("_");
						const pathNormalized = pathFinalThreeElements.replace(/[\s\-_]/g, "").toLowerCase();
						
						selectedImage = imageList.filter((image) => {
							// Normalize the entire image name
							const imageNormalized = image.name.replace(/[\s\-_]/g, "").toLowerCase();
							
							// Check if normalized path appears in normalized image name
							return imageNormalized.includes(pathNormalized);
						})[0];
						
						// FALLBACK: Use custom logic if default matching fails
						if (!selectedImage) {
							selectedImage = imageList.filter((image) => {
								return image.name
									.split("_")
									.join("")
									.split("-")
									.join("")
									.includes(
										e.target.id
											.split("_")
											.join("")
											.split("-")
											.join("")
											.replace(textReplacement, ""),
									);
							})[0];
						}
					} else {
						// CUSTOM MATCHING LOGIC (Original "To Remove" logic):
						selectedImage = imageList.filter((image) => {
							return image.name
								.split("_")
								.join("")
								.split("-")
								.join("")
								.includes(
									e.target.id
										.split("_")
										.join("")
										.split("-")
										.join("")
										.replace(textReplacement, ""),
								);
						})[0];
					}

					if (selectedImage) {
						// console.log(selectedImage)
						const previewImg = document.getElementById("image-previewer-image") as HTMLImageElement;
						previewImg.src = selectedImage.data;
						
						// Track current hovered image name
						currentHoveredImageName = selectedImage.name;
						
						// Get or create transformation entry
						const transform = getImageTransform(selectedImage.name);
						
						// Get imported rotation and flip for this image
						const imageIdentifier = getUnitIdentifier(selectedImage.name);
						let importedRotationForImage = null;
						let importedFlipForImage = null;
						if (imageIdentifier && importedUnitReference) {
							const importedUnit = importedUnitReference.find((unit: any) => {
								const unitIdentifier = getUnitIdentifier(unit.name || "");
								return unitIdentifier === imageIdentifier;
							});
							if (importedUnit) {
								importedRotationForImage = typeof importedUnit.rotation === 'string' ? parseInt(importedUnit.rotation) : importedUnit.rotation;
								importedFlipForImage = typeof importedUnit.flip === 'string' ? importedUnit.flip === 'true' : importedUnit.flip;
							}
						}
						
						// Update preview text with transform values
						updatePreviewText(selectedImage.name, transform);
						
						// Apply saved transformation after image loads
						previewImg.onload = () => {
							if (transform) {
								applyImageTransform(previewImg, transform, importedRotationForImage, importedFlipForImage);
								updatePreviewText(selectedImage.name, transform);
							}
						};
						
						// If image is already loaded, apply immediately
						if (previewImg.complete) {
							if (transform) {
								applyImageTransform(previewImg, transform, importedRotationForImage, importedFlipForImage);
								updatePreviewText(selectedImage.name, transform);
							}
						}
					} else {
						document.getElementById("image-previewer-image").src =
							"";
						document.getElementById(
							"image-previewer-text",
						).innerHTML = "";
						currentHoveredImageName = null;
					}
				});

				const listener2 = path.addEventListener("mouseout", (e) => {
					document.getElementById(
						"image-previewer-container",
					).style.display = "none";
				});

				listeners.push(listener);
				listeners.push(listener2);
			});
			globalSvgContainer.addEventListener("mousemove", (e) => {
				document.getElementById(
					"image-previewer-container",
				).style.left = `${e.clientX}px`;
				document.getElementById("image-previewer-container").style.top =
					`${e.clientY}px`;
			});

			// Keyboard handlers for image transformation
			// Remove any existing preview keyboard handler to avoid duplicates
			const existingPreviewKeyHandler = (window as any).previewKeyHandler;
			if (existingPreviewKeyHandler) {
				document.removeEventListener("keydown", existingPreviewKeyHandler);
			}

			// Create new keyboard handler
			(window as any).previewKeyHandler = (e: KeyboardEvent) => {
				// Check if previewer is visible and an image is hovered
				const previewContainer = document.getElementById("image-previewer-container");
				if (!previewContainer || previewContainer.style.display === "none" || !currentHoveredImageName) {
					return; // Let other handlers process the key
				}

				// Check if focus is on an input-like element
				const activeEl = document.activeElement;
				const isInputLike = activeEl && (
					activeEl.tagName === "INPUT" || 
					activeEl.tagName === "TEXTAREA" || 
					activeEl.tagName === "SELECT" || 
					(activeEl as HTMLElement).isContentEditable
				);
				if (isInputLike) {
					return; // Don't interfere with input fields
				}

				const previewImg = document.getElementById("image-previewer-image") as HTMLImageElement;
				if (!previewImg || !previewImg.src) {
					return;
				}

				const transform = getImageTransform(currentHoveredImageName);
				if (!transform) {
					return;
				}

				// Get imported rotation and flip for this image to calculate final values and limits
				const imageIdentifier = getUnitIdentifier(currentHoveredImageName);
				let importedRotationForImage = null;
				let importedFlipForImage = null;
				if (imageIdentifier && importedUnitReference) {
					const importedUnit = importedUnitReference.find((unit: any) => {
						const unitIdentifier = getUnitIdentifier(unit.name || "");
						return unitIdentifier === imageIdentifier;
					});
					if (importedUnit) {
						importedRotationForImage = typeof importedUnit.rotation === 'string' ? parseInt(importedUnit.rotation) : importedUnit.rotation;
						importedFlipForImage = typeof importedUnit.flip === 'string' ? importedUnit.flip === 'true' : importedUnit.flip;
					}
				}

				// Handle ArrowLeft: rotate -90 degrees (change)
				if (e.key === "ArrowLeft") {
					e.preventDefault();
					e.stopPropagation();
					// Calculate new change value
					const newChange = transform.rotation - 90;
					// Calculate final rotation with new change
					const finalRotation = importedRotationForImage !== null ? importedRotationForImage + newChange : newChange;
					// Limit final rotation to -90 to 180
					if (finalRotation >= -90 && finalRotation <= 180) {
						transform.rotation = newChange;
						applyImageTransform(previewImg, transform, importedRotationForImage, importedFlipForImage);
						updatePreviewText(currentHoveredImageName, transform);
						console.log("Image transform updated:", transform);
					}
					return;
				}

				// Handle ArrowRight: rotate +90 degrees (change)
				if (e.key === "ArrowRight") {
					e.preventDefault();
					e.stopPropagation();
					// Calculate new change value
					const newChange = transform.rotation + 90;
					// Calculate final rotation with new change
					const finalRotation = importedRotationForImage !== null ? importedRotationForImage + newChange : newChange;
					// Limit final rotation to -90 to 180
					if (finalRotation >= -90 && finalRotation <= 180) {
						transform.rotation = newChange;
						applyImageTransform(previewImg, transform, importedRotationForImage, importedFlipForImage);
						updatePreviewText(currentHoveredImageName, transform);
						console.log("Image transform updated:", transform);
					}
					return;
				}

				// Handle F key: flip image (toggle the change)
				if (e.key === "f" || e.key === "F") {
					e.preventDefault();
					e.stopPropagation();
					transform.flip = !transform.flip; // Toggle the change
					applyImageTransform(previewImg, transform, importedRotationForImage, importedFlipForImage);
					updatePreviewText(currentHoveredImageName, transform);
					console.log("Image transform updated:", transform);
					return;
				}
			};

			// Add the keyboard handler
			document.addEventListener("keydown", (window as any).previewKeyHandler);
		}

		fileInput.addEventListener("change", () => {
			handleFileChange(fileInput.files[0]);
		});

		document
			.getElementById("updateValues")
			.addEventListener("click", (e) => {
				updateValuesList.set([]);
				currentValuesList.set([]);
				updateValuesModal.set(false);
				console.log("UpdateValues clicked");
			});

		document
			.getElementById("updateValues")
			.addEventListener("change", () => {
				updateValues(document.getElementById("updateValues").files[0]);
			});

		var animationTimeout;
		document.body.addEventListener("dragover", (e) => {
			event.preventDefault(); // Prevent the default behavior
			document.querySelector(".drag-drop-prompt").classList.add("appear");
			if (animationTimeout != null) {
				clearTimeout(animationTimeout);
				animationTimeout = setTimeout((e) => {
					document
						.querySelector(".drag-drop-prompt")
						.classList.remove("appear");
				}, 500);
			} else {
				animationTimeout = setTimeout((e) => {
					document
						.querySelector(".drag-drop-prompt")
						.classList.remove("appear");
				}, 500);
			}
		});

		document.body.addEventListener("dragend", (e) => {
			event.preventDefault(); // Prevent the default behavior
			document
				.querySelector(".drag-drop-prompt")
				.classList.remove("appear");
		});

		document.body.addEventListener("drop", (e) => {
			e.preventDefault();
			console.log(e);
			const files = Array.from(e.dataTransfer.files);
			console.log("Dropped files:", files);
			
			// Separate files by type
			const backplateImages: File[] = [];
			const unitReferenceFiles: File[] = [];
			const otherFiles: File[] = [];
			
			files.forEach((file) => {
				const fileName = file.name.toLowerCase();
				// Check if file name contains "backplate_image_floorplan" (case-insensitive)
				if (fileName.includes("backplate_image_floorplan")) {
					backplateImages.push(file);
				}
				// Check if file is unit-reference.json
				else if (fileName === "unit-reference.json" || fileName.endsWith("unit-reference.json")) {
					unitReferenceFiles.push(file);
				}
				// All other files
				else {
					otherFiles.push(file);
				}
			});
			
			// Handle backplate images - load into Check Floorplans
			if (backplateImages.length > 0) {
				console.log(`Loading ${backplateImages.length} backplate image(s) into Check Floorplans`);
				// Create a FileList-like object for the uploadImages function
				const dt = new DataTransfer();
				backplateImages.forEach(file => dt.items.add(file));
				const fakeEvent = {
					target: {
						files: dt.files
					}
				};
				uploadImages(fakeEvent as any);
			}
			
			// Handle unit-reference files - load into Upload unit-reference
			if (unitReferenceFiles.length > 0) {
				console.log(`Loading ${unitReferenceFiles.length} unit-reference file(s)`);
				// Use the first unit-reference file
				const file = unitReferenceFiles[0];
				const reader = new FileReader();
				reader.onload = (event: any) => {
					try {
						const jsonData = JSON.parse(event.target.result);
						let unitsArray = null;
						
						// Handle different JSON structures
						if (Array.isArray(jsonData)) {
							unitsArray = jsonData;
						} else if (jsonData.unitReference && Array.isArray(jsonData.unitReference.units)) {
							unitsArray = jsonData.unitReference.units;
						} else if (Array.isArray(jsonData.units)) {
							unitsArray = jsonData.units;
						} else {
							console.error("Unexpected JSON structure:", jsonData);
							console.log("Invalid format: Expected an array of unit objects, or an object with 'units' or 'unitReference.units' property");
							return;
						}
						
						if (unitsArray && unitsArray.length > 0) {
							importedUnitReference = unitsArray;
							console.log("ðŸ“¥ Imported unit-reference:", {
								count: unitsArray.length,
								units: unitsArray.map((unit: any) => ({
									name: unit.name,
									type: unit.type,
									rotation: unit.rotation,
									flip: unit.flip,
									identifier: getUnitIdentifier(unit.name || "")
								}))
							});
							
							// Update preview if currently showing an image
							if (currentHoveredImageName) {
								const transform = getImageTransform(currentHoveredImageName);
								updatePreviewText(currentHoveredImageName, transform);
							}
							
							console.log(`Successfully imported ${unitsArray.length} unit(s)`);
						} else {
							console.log("No units found in the file");
						}
					} catch (error) {
						console.error("Error parsing unit-reference JSON:", error);
						console.log("Error parsing JSON file. Please check the format.");
					}
				};
				reader.readAsText(file);
			}
			
			// Handle other files with default behavior (SVG, etc.)
			if (otherFiles.length > 0) {
				const dt = new DataTransfer();
				otherFiles.forEach(file => dt.items.add(file));
				handleFileChange(dt.files);
			}
			
			document
				.querySelector(".drag-drop-prompt")
				.classList.remove("appear");
		});

		//To check globally if is typing
		document.addEventListener("focusin", (event) => {
			if (
				event.target.tagName === "INPUT" ||
				event.target.tagName === "TEXTAREA"
			) {
				typing = true;
				console.log("Input is active");
			}
		});

		document.addEventListener("focusout", (event) => {
			if (
				event.target.tagName === "INPUT" ||
				event.target.tagName === "TEXTAREA"
			) {
				typing = false;
				console.log("Input is not active");
			}
		});

		document.addEventListener("keydown", (e) => {
			// Undo/Redo handlers
			if (e.ctrlKey || e.metaKey) {
				if (e.key === "z" || e.key === "Z") {
					// Check if input is focused - don't override browser undo in inputs
					const activeEl = document.activeElement as HTMLElement;
					const isInputLike = activeEl && (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA" || activeEl.isContentEditable);
					
					if (!isInputLike) {
						e.preventDefault();
						if (e.shiftKey) {
							redo(); // Ctrl+Shift+Z for redo
						} else {
							undo(); // Ctrl+Z for undo
						}
						return;
					}
				}
				if (e.key === "y" || e.key === "Y") {
					// Check if input is focused
					const activeEl = document.activeElement as HTMLElement;
					const isInputLike = activeEl && (activeEl.tagName === "INPUT" || activeEl.tagName === "TEXTAREA" || activeEl.isContentEditable);
					
					if (!isInputLike) {
						e.preventDefault();
						redo(); // Ctrl+Y for redo
						return;
					}
				}
			}

			// Guard: if focus is on an input-like element, let Backspace/Delete act normally
			const targetEl = (e.target as HTMLElement) || null;
			const activeEl = (document.activeElement as HTMLElement) || null;
			const isInputLike = (el: HTMLElement | null) =>
				!!el && (el.tagName === "INPUT" || el.tagName === "TEXTAREA" || el.tagName === "SELECT" || el.isContentEditable);
			if ((e.key === "Backspace" || e.key === "Delete") && (isInputLike(targetEl) || isInputLike(activeEl))) {
				return;
			}
			if (e.key == "Escape") {
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.classList.remove("svg-tool-selected");
					e.style.fill = "";
					groupGlobal = [];
					document.querySelectorAll("#group").value = "";
				});

				if (multiSelect) {
					groupGlobal.forEach((e) => {
						e.classList.remove("svg-tool-selected");
						e.style.fill = "";
					});

					multiSelect = false;
				}
			}

			if (
				e.key === "a" &&
				e.ctrlKey &&
				document.activeElement.tagName === "INPUT" &&
				document.activeElement.type === "text"
			) {
				document.activeElement.select();
				console.log(document.activeElement);
			}

			if (e.key == "Shift") {
				multiSelect = true;
			}

			if (e.key == "Enter") {
				document.querySelector("#set-name").click();
			}

			if (e.key == "q") {
				document.querySelector("#set-unit").click();
			}

			if (e.key == "Delete" || e.key === "Backspace") {
				// Only delete points if not typing in an input field
				if (!typing) {
					document.querySelector("#delete-point").click();
				}
			}

			if (event.key === "ArrowLeft") {
				if (!typing) {
					rotateCircles(-45);
				}
			} else if (event.key === "ArrowRight") {
				if (!typing) {
					rotateCircles(45);
				}
			}

			if (e.key == "l") {
				console.log(e.key);
				if (document.getElementById("showLabelsToggle")) {
					document.getElementById("showLabelsToggle").click();
				}
			}

			if (e.ctrlKey && e.key === "a") {
				e.preventDefault(); // Prevent the default browser select all behavior

				const svgElement = globalSvgContainer.querySelector("svg");
				if (svgElement != null) {
					// Select all circles and triangles (polygons) in the SVG
					const circles = Array.from(svgElement.querySelectorAll("circle"));
					const triangles = Array.from(svgElement.querySelectorAll("polygon[data-triangle='true']"));
					
					groupGlobal = [...circles, ...triangles];

					groupGlobal.forEach((element) => {
						element.classList.add("svg-tool-selected");
						element.style.fill = "#87CEEB";
					});

					// Indicate multi-selection mode
					multiSelect = true;

					console.log("All elements selected:", groupGlobal.length, "elements (", circles.length, "circles,", triangles.length, "triangles)");
				}
			}

			if (e.key == "Delete") {
				// Only delete points if not typing in an input field
				if (!typing) {
					document.querySelector("delete-point").click();
					spawnLabel();
				}
			}

			spawnLabel();
		});

		window.addEventListener("resize", (e) => {
			spawnLabel();
		});

		function setUnit() {
			for (var i = 0; i < groupGlobal.length; i++) {
				console.log(i);
				groupGlobal[i].setAttribute("unit-attribute", pad(i + 1));
			}

			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				if (
					document.querySelectorAll(".svg-tool-selected").length < 2
				) {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.setAttribute(
						"unit-attribute",
						document.getElementById("unit").value,
					);
					if (
						e.hasAttribute("group-attribute") &&
						e.hasAttribute("unit-attribute")
					) {
						e.id =
							e.getAttribute("group-attribute") +
							"_" +
							e.getAttribute("unit-attribute");
					}
				} else {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.id =
						e.getAttribute("group-attribute") +
						"_" +
						e.getAttribute("unit-attribute");
				}
			});
		}

		function rotateCircles(angle, customMidpoint = null) {
			const svgElement = document.querySelector("#svg-container svg");
			if (!svgElement) {
				console.error("SVG element not found.");
				return;
			}

			const circles = svgElement.querySelectorAll("circle");
			if (circles.length === 0) {
				console.warn("No circles found in the SVG.");
				return;
			}

			let bboxCenterX, bboxCenterY;

			if (customMidpoint) {
				// Use the custom midpoint
				bboxCenterX = customMidpoint.x;
				bboxCenterY = customMidpoint.y;
			} else {
				// Calculate bounding box midpoint
				let minX = Infinity,
					maxX = -Infinity,
					minY = Infinity,
					maxY = -Infinity;

				circles.forEach((circle) => {
					const cx = parseFloat(circle.getAttribute("cx"));
					const cy = parseFloat(circle.getAttribute("cy"));
					const r = parseFloat(circle.getAttribute("r"));

					if (cx - r < minX) minX = cx - r;
					if (cx + r > maxX) maxX = cx + r;
					if (cy - r < minY) minY = cy - r;
					if (cy + r > maxY) maxY = cy + r;
				});

				bboxCenterX = minX + (maxX - minX) / 2;
				bboxCenterY = minY + (maxY - minY) / 2;
			}

			const radians = (angle * Math.PI) / 180;

			// Rotate each circle around the chosen midpoint
			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));

				const dx = cx - bboxCenterX;
				const dy = cy - bboxCenterY;

				const newCx =
					bboxCenterX +
					dx * Math.cos(radians) -
					dy * Math.sin(radians);
				const newCy =
					bboxCenterY +
					dx * Math.sin(radians) +
					dy * Math.cos(radians);

				circle.setAttribute("cx", newCx.toFixed(4));
				circle.setAttribute("cy", newCy.toFixed(4));
			});

			console.log(
				`Rotated circles around midpoint (${bboxCenterX.toFixed(
					4,
				)}, ${bboxCenterY.toFixed(4)}) by ${angle} degrees.`,
			);
		}

		function getAveragedCircles(data) {
			console.log("data");
			console.log(data);
			const grouped = {};
			data.forEach((item) => {
				const { floor, circle } = item;
				console.log(circle.attributes[1].textContent);
				const idLocal = circle.getAttribute("id");
				const cxLocal = parseFloat(circle.attributes[1].value);
				const cyLocal = parseFloat(circle.attributes[2].value);
				console.log({ floor, circle, cxLocal, cyLocal });

				// Grouping by floor and id
				if (!grouped[floor]) {
					grouped[floor] = {};
				}
				if (!grouped[floor][idLocal]) {
					grouped[floor][idLocal] = {
						totalCx: 0,
						totalCy: 0,
						count: 0,
						idLocal,
					};
				}

				// Summing cx, cy positions
				grouped[floor][idLocal].totalCx += cxLocal;
				grouped[floor][idLocal].totalCy += cyLocal;
				grouped[floor][idLocal].count += 1;
			});

			console.log(grouped);

			const averagedCircles = [];

			for (const floor in grouped) {
				for (const id in grouped[floor]) {
					const { totalCx, totalCy, count } = grouped[floor][id];
					const avgCx = totalCx / count;
					const avgCy = totalCy / count;

					// Clone the original DOM element and update its attributes
					const originalCircle = data.find(
						(item) => item.circle.getAttribute("id") === id,
					).circle;
					const newCircle = originalCircle.cloneNode(true);
					newCircle.setAttribute("cx", avgCx);
					newCircle.setAttribute("cy", avgCy);

					averagedCircles.push({
						floor,
						circle: newCircle,
					});
				}
			}

			return averagedCircles;
		}

		function toggleFloors(aggregated) {
			const globalG = globalSvgContainer.querySelector("g");
			const localFloors = globalFloors;
			const localFloorsAggregated = globalFloorsAggregated;

			checkboxesId.forEach((i) => {
				const floor = i.split("-")[1];
				if (aggregated) {
					console.log(globalFloorsAggregated);
					localFloors.forEach((e) => {
						e.circle.remove();
					});
					const selectedFloorCirclesAggregated =
						localFloorsAggregated.filter((e) =>
							e.floor.includes(floor),
						);

					if (document.getElementById(i).checked) {
						selectedFloorCirclesAggregated.forEach((e) => {
							globalG.appendChild(e.circle);
						});
						console.log({ Added: selectedFloorCirclesAggregated });
					} else {
						selectedFloorCirclesAggregated.forEach((e) => {
							e.circle.remove();
						});
						console.log({
							Removed: selectedFloorCirclesAggregated,
						});
					}
				} else {
					localFloorsAggregated.forEach((e) => {
						e.circle.remove();
					});
					const selectedFloorCircles = localFloors.filter((e) =>
						e.floor.includes(floor),
					);

					if (document.getElementById(i).checked) {
						selectedFloorCircles.forEach((e) => {
							globalG.appendChild(e.circle);
						});
						console.log({ Added: selectedFloorCircles });
					} else {
						selectedFloorCircles.forEach((e) => {
							e.circle.remove();
						});
						console.log({ Removed: selectedFloorCircles });
					}
				}
			});
		}

		//Add zero to single digit
		function pad(d) {
			return d < 10 ? "0" + d.toString() : d.toString();
		}

		document.addEventListener("keydown", (e) => {
			if (e.key == "Escape") {
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.classList.remove("svg-tool-selected");
					e.style.fill = "";
					groupGlobal = [];
					document.querySelectorAll("#group").value = "";
				});
			}

			if (e.key == "Shift") {
				multiSelect = true;
			}
		});

		document.addEventListener("keyup", (e) => {
			if (e.key == "Shift") {
				multiSelect = false;
				console.log(multiSelect);
			}
		});

		document
			.getElementById("hide-toggle")
			.addEventListener("click", (e) => {
				if (
					document.getElementById("id-list").style.display == "none"
				) {
					document.getElementById("id-list").style.display = "block";
					document
						.getElementById("hide-toggle")
						.classList.remove("expand");
				} else {
					document.getElementById("id-list").style.display = "none";
					document
						.getElementById("hide-toggle")
						.classList.add("expand");
				}
			});

		// document.getElementById("export-csv").addEventListener("click", (e) => {
		// 	exportCSV();
		// });

		// document.getElementById("remove").addEventListener("click", (e) => {
		// 	removeData();
		// });

		// document
		// 	.getElementById("export-csv-count")
		// 	.addEventListener("click", (e) => {
		// 		exportCSVId();
		// 	});

		document.getElementById("export").addEventListener("click", (e) => {
			exportSVG();
		});

		document
			.getElementById("export-csv-layer")
			.addEventListener("click", (e) => {
				exportFloorNamePosition();
			});

		document
			.getElementById("export-csv-layer-2048")
			.addEventListener("click", (e) => {
				exportFloorNamePosition2048();
			});

		// Helper function to get selected floor number
		function getSelectedFloorNumber() {
			let selectedFloors = [];
			
			// Check for floor checkboxes (floor-0-checkbox, floor-1-checkbox, etc.)
			if (typeof checkboxesId !== 'undefined' && checkboxesId && checkboxesId.length > 0) {
				for (const checkboxId of checkboxesId) {
					const checkbox = document.getElementById(checkboxId) as HTMLInputElement;
					if (checkbox && checkbox.checked) {
						const floor = checkboxId.split("-")[1]; // Extract floor number from "floor-0-checkbox"
						const floorNum = parseInt(floor, 10);
						if (!isNaN(floorNum)) {
							selectedFloors.push(floorNum);
						}
					}
				}
			}
			
			// Check for project floor checkboxes (project-floor-${zLevel}-checkbox)
			const projectFloorCheckboxes = document.querySelectorAll('[id^="project-floor-"][id$="-checkbox"]');
			if (projectFloorCheckboxes.length > 0) {
				for (const checkbox of projectFloorCheckboxes) {
					const inputCheckbox = checkbox as HTMLInputElement;
					if (inputCheckbox && inputCheckbox.checked) {
						const id = inputCheckbox.id;
						const match = id.match(/project-floor-([\d.]+)-checkbox/);
						if (match) {
							// Get the index of this floor in sorted order
							const zLevel = parseFloat(match[1]);
							if (!isNaN(zLevel) && typeof floorLevels !== 'undefined' && floorLevels) {
								const sortedFloors = Array.from(floorLevels.keys()).sort((a, b) => b - a);
								const index = sortedFloors.indexOf(zLevel);
								if (index !== -1 && index >= 0) {
									selectedFloors.push(index);
								}
							}
						}
					}
				}
			}
			
			// Filter out any NaN values and return the lowest floor number, or default to 0
			const validFloors = selectedFloors.filter(f => !isNaN(f) && typeof f === 'number');
			if (validFloors.length > 0) {
				const minFloor = Math.min(...validFloors);
				return isNaN(minFloor) ? 0 : minFloor;
			}
			
			// Default to 0 if no floor is selected
			return 0;
		}

		// Helper function to format filename with proper segments
		function formatExportFilename(baseFilename) {
			// Remove file extension
			const nameWithoutExt = baseFilename.replace(/\.[^/.]+$/, "");
			
			// Split by underscore to count segments
			const segments = nameWithoutExt.split("_");
			
			// Get selected floor number, default to 0 if invalid
			let floorNumber = getSelectedFloorNumber();
			if (isNaN(floorNumber) || typeof floorNumber !== 'number') {
				floorNumber = 0;
			}
			
			// Check if we have 8 segments
			if (segments.length < 8) {
				// Add floor number suffix
				return nameWithoutExt + `_${floorNumber}`;
			} else {
				// Replace the last segment with floor number
				segments[segments.length - 1] = floorNumber.toString();
				return segments.join("_");
			}
		}

		//SVG Conversion
		function exportSVG() {
			const file = fileNameGlobal;
			var svg = document
				.querySelector("#svg-container")
				.querySelector("svg");
			document.querySelectorAll("[id]").forEach((e) => {
				const str = e.getAttribute("id");
				e.setAttribute("data-name", str.replace(/\s+/g, "_"));
			});
			document.querySelectorAll("[group-attribute]").forEach((e) => {
				e.removeAttribute("group-attribute");
			});
			document.querySelectorAll("[unit-attribute]").forEach((e) => {
				e.removeAttribute("unit-attribute");
			});
			if (svg) {
				var serializer = new XMLSerializer();
				var svgString = serializer.serializeToString(svg);
				var blob = new Blob([svgString], { type: "image/svg+xml" });
				var url = URL.createObjectURL(blob);
				var link = document.createElement("a");
				link.href = url;
				
				// Build filename with suffix
				const baseName = file.replace(/\.[^/.]+$/, "");
				const typeSuffix = type ? "_" + type : "";
				
				// Add flip suffix if SVG has been flipped
				let flipSuffix = "";
				if (svgFlipX === -1 && svgFlipY === -1) {
					flipSuffix = "_flipped-xy";
				} else if (svgFlipX === -1) {
					flipSuffix = "_flipped-x";
				} else if (svgFlipY === -1) {
					flipSuffix = "_flipped-y";
				}
				
				link.download = baseName + typeSuffix + flipSuffix + ".svg";
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			} else {
				alert("Import an SVG to start!");
			}
		}
		//SVG Conversion
		function exportFloorNamePosition() {
			// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
			if (document.querySelector("#svg-container").querySelector("svg")) {
				const parser = new DOMParser();
				var doc = null;
				doc = document
					.querySelector("#svg-container")
					.querySelector("svg");

				const layers = Array.from(doc.querySelectorAll("g"))
					.map((layer, index) => {
						if (
							layer.getAttribute("id") != null ||
							layer.getAttribute("id") != undefined
						) {
							if (
								layer.getAttribute("id").toLowerCase() !=
								"reference"
							) {
								console.log("Layer ID is found");
								const id = layer
									.getAttribute("id")
									.replace("_", "");
								const children = Array.from(layer.children).map(
									(child) => {
										console.log(child);
										const childId = child.getAttribute(
											"data-name",
										)
											? decodeHtml(
													child.getAttribute(
														"data-name",
													),
												)
											: child.getAttribute("id");

										const x = child.getAttribute("cx");
										const y = child.getAttribute("cy");
										return { id: childId, x, y };
									},
								);
								console.log(id, children);
								return { id, children };
							}
						} else {
							console.log("Layer ID is null");
							console.log(layer);
							const id = `item-${index}`;
							const children = Array.from(layer.children).map(
								(child) => {
									console.log(child);
									const childId = child.getAttribute(
										"data-name",
									)
										? decodeHtml(
												child.getAttribute("data-name"),
											)
										: child.getAttribute("id");

									const x = child.getAttribute("cx");
									const y = child.getAttribute("cy");
									return { id: childId, x, y };
								},
							);
							console.log(id, children);
							return { id, children };
						}
					})
					.filter((layer) => layer !== undefined);

				var csv;
				if (layers.length < 2) {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				} else {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				}

				const file = fileNameGlobal;
				var blob = new Blob([csv], { type: "text/csv" });
				var link = document.createElement("a");
				link.href = URL.createObjectURL(blob);
				link.download = formatExportFilename(file) + ".csv";
				link.click();
			} else {
				alert("Import an SVG to start!");
			}
		}

		//SVG Conversion
		function exportFloorNamePosition2048() {
			// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
			if (document.querySelector("#svg-container").querySelector("svg")) {
				const parser = new DOMParser();
				var doc = null;

				doc = document
					.querySelector("#svg-container")
					.querySelector("svg");
				const height = doc.viewBox.baseVal.height;
				const width = doc.viewBox.baseVal.width;

				const layers = Array.from(doc.querySelectorAll("g"))
					.map((layer) => {
						if (
							layer.getAttribute("id").toLowerCase() !=
							"reference"
						) {
							const id = layer
								.getAttribute("id")
								.replace("_", "");
							const children = Array.from(layer.children).map(
								(child) => {
									console.log(child);
									const childId = child.getAttribute(
										"data-name",
									)
										? decodeHtml(
												child.getAttribute("data-name"),
											)
										: child.getAttribute("id");

									const x =
										(child.getAttribute("cx") / width) *
										2048;
									const y =
										(child.getAttribute("cy") / height) *
										2048;
									return { id: childId, x, y };
								},
							);
							console.log(id, children);
							return { id, children };
						}
					})
					.filter((layer) => layer !== undefined);

				var csv;
				if (layers.length < 2) {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				} else {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				}

				console.log(csv);

				const file = fileNameGlobal;
				var blob = new Blob([csv], { type: "text/csv" });
				var link = document.createElement("a");
				link.href = URL.createObjectURL(blob);
				link.download = formatExportFilename(file) + ".csv";
				link.click();
			} else {
				alert("Import an SVG to start!");
			}
		}

		function decodeHtml(html) {
			var txt = document.createElement("textarea");
			txt.innerHTML = html;
			return txt.value;
		}

		//Flip Points only
		function flipPointsX() {
			flipped = !flipped;

			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");
			const width = doc.viewBox.baseVal.width;
			const layers = Array.from(doc.querySelectorAll("g")).map(
				(layer) => {
					// if(layer.getAttribute("id").toLowerCase() != 'reference'){
					// const id = layer.getAttribute("id").replace('_', "");
					const children = Array.from(layer.children).map((child) => {
						if (child.tagName == "image") {
							// child.getAttribute("transform")
							// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
							if (!child.hasAttribute("flipped")) {
								child.setAttribute("flipped", "");
								child.style.transform =
									"scaleX(-1) translate(-100%, 0)";
							} else {
								child.removeAttribute("flipped");
								child.style.transform =
									"scaleX(1) translate(0, 0)";
							}

							console.log(child.style.scale);
						} else {
							const x = child.getAttribute("cx");
							child.setAttribute("cx", width - x);
						}
					});
					// }
				},
			);
			spawnLabel();
		}

		function flipPointsY() {
			// var svg = document.querySelector("#svg-container").querySelector("svg");
			// svg.style.scale = "-1 1"
			flipped = !flipped;

			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");
			const height = doc.viewBox.baseVal.height;
			const layers = Array.from(doc.querySelectorAll("g")).map(
				(layer) => {
					// if(layer.getAttribute("id").toLowerCase() != 'reference'){
					// const id = layer.getAttribute("id").replace('_', "");
					const children = Array.from(layer.children).map((child) => {
						if (child.tagName == "image") {
							// child.getAttribute("transform")
							// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
							if (!child.hasAttribute("flipped")) {
								child.setAttribute("flipped", "");
								child.style.transform =
									"scaleY(-1) translate(0, -100%)";
							} else {
								child.removeAttribute("flipped");
								child.style.transform =
									"scaleX(1) translate(0, 0)";
							}

							console.log(child.style.scale);
						} else {
							const y = child.getAttribute("cy");
							child.setAttribute("cy", height - y);
						}
					});
					// }
				},
			);
			spawnLabel();
		}

		function transformImages() {
			// Select the SVG element
			var svgElement = document
				.querySelector("#svg-container")
				.querySelector("svg");
			if (!svgElement) {
				console.error(
					`SVG element not found for selector: ${svgElement}`,
				);
				return;
			}

			// Get all <image> elements within the SVG
			const imageNodes = svgElement.querySelectorAll("image");
			if (imageNodes.length === 0) {
				console.warn("No <image> nodes found in the SVG.");
				return;
			}

			// Iterate through each <image> node
			console.log(imageNodes);
			imageNodes.forEach((imageNode) => {
				// Get current attributes for width and x
				const width = parseFloat(imageNode.getAttribute("width")) || 0;
				const height =
					parseFloat(imageNode.getAttribute("height")) || 0;
				const x = parseFloat(imageNode.getAttribute("x")) || 0;
				const y = parseFloat(imageNode.getAttribute("y")) || 0;

				// Calculate the transformation
				const translateX = canvasFlipX ? width : 0;
				const translateY = canvasFlipY ? height : 0;
				const scaleX = canvasFlipX ? -1 : 1;
				const scaleY = canvasFlipY ? -1 : 1;
				const rotate = canvasRotate % 360;

				const transformValue = `translate(${translateX}, ${translateY}) scale(${scaleX}, ${scaleY}) rotate(${rotate}, ${width / 2}, ${height / 2})`;

				// Apply the transformation
				const existingTransform =
					imageNode.getAttribute("transform") || "";
				imageNode.setAttribute("transform", `${transformValue}`.trim());

				console.log(
					`Flipped <image> node with x: ${x}, width: ${width}, y: ${y}, height: ${height}`,
				);
			});
		}

		document
			.getElementById("flip-x")
			.addEventListener("click", flipPointsX);
		document
			.getElementById("flip-y")
			.addEventListener("click", flipPointsY);
		document
			.getElementById("canvas-flip-x")
			.addEventListener("click", () => {
				canvasFlipX = !canvasFlipX;
				console.log(canvasFlipX);
				transformImages();
				flipPointsX();
				updateResetButtons();
			});
		document
			.getElementById("canvas-flip-y")
			.addEventListener("click", () => {
				canvasFlipY = !canvasFlipY;
				console.log(canvasFlipY);
				transformImages();
				flipPointsY();
				updateResetButtons();
			});

		document
			.getElementById("canvas-rotate-left")
			.addEventListener("click", () => {
				canvasRotate -= 90;
				transformImages();
				const svgElement = document
					.querySelector("#svg-container")
					.querySelector("svg");
				const midpoint = {
					x: svgElement.viewBox.baseVal.width / 2,
					y: svgElement.viewBox.baseVal.height / 2,
				};
				rotateCircles(-90, midpoint);
				spawnLabel();
				updateResetButtons();
				// flipPointsX()
			});
		document
			.getElementById("canvas-rotate-right")
			.addEventListener("click", () => {
				canvasRotate += 90;
				transformImages();
				const svgElement = document
					.querySelector("#svg-container")
					.querySelector("svg");
				const midpoint = {
					x: svgElement.viewBox.baseVal.width / 2,
					y: svgElement.viewBox.baseVal.height / 2,
				};
				rotateCircles(90, midpoint);
				spawnLabel();
				updateResetButtons();
				// flipPointsY()
			});

		document
			.getElementById("reset-rotation")
			.addEventListener("click", (e) => {
				const tempCanvasRotation = canvasRotate;
				canvasRotate = 0;
				transformImages();

				const svgElement = document
					.querySelector("#svg-container")
					.querySelector("svg");
				const midpoint = {
					x: svgElement.viewBox.baseVal.width / 2,
					y: svgElement.viewBox.baseVal.height / 2,
				};

				rotateCircles(-tempCanvasRotation, midpoint);
				spawnLabel();
				updateResetButtons();
			});

		document.getElementById("reset-flip").addEventListener("click", (e) => {
			transformImages();
			if (canvasFlipX) {
				flipPointsX();
				canvasFlipX = false;
			}

			if (canvasFlipY) {
				flipPointsY();
				canvasFlipY = false;
			}

			updateResetButtons();
		});

		function updateResetButtons() {
			if (canvasRotate != 0) {
				if (
					document
						.getElementById("reset-rotation")
						.classList.contains("hidden")
				) {
					document
						.getElementById("reset-rotation")
						.classList.remove("hidden");
					document
						.getElementById("reset-rotation")
						.classList.add("flex");
				}
			} else {
				if (
					document
						.getElementById("reset-rotation")
						.classList.contains("flex")
				) {
					document
						.getElementById("reset-rotation")
						.classList.remove("flex");
					document
						.getElementById("reset-rotation")
						.classList.add("hidden");
				}
			}

			if (canvasFlipX || canvasFlipY) {
				if (
					document
						.getElementById("reset-flip")
						.classList.contains("hidden")
				) {
					document
						.getElementById("reset-flip")
						.classList.remove("hidden");
					document.getElementById("reset-flip").classList.add("flex");
				}
			} else if (!canvasFlipX && !canvasFlipY) {
				if (
					document
						.getElementById("reset-flip")
						.classList.contains("flex")
				) {
					document
						.getElementById("reset-flip")
						.classList.remove("flex");
					document
						.getElementById("reset-flip")
						.classList.add("hidden");
				}
			}
		}

		function spawnLabel() {
			killLabels(true);
			if (document.getElementById("showLabelsToggle")) {
				if (document.getElementById("showLabelsToggle").checked) {
					var circles = [];
					const group = globalSvgContainer
						.querySelector("svg")
						.querySelector("g");
					// console.log(
					// 	globalSvgContainer
					// 		.querySelector("svg")
					// 		.querySelector("g"),
					// );
					if (!group) {
					} else if (group instanceof SVGGElement) {
						// Get both circles and triangles (polygons with data-triangle attribute)
						const circleElements = [].slice.call(
							group.getElementsByTagName("circle"),
						);
						const triangleElements = [].slice.call(
							group.querySelectorAll("polygon[data-triangle='true']"),
						);
						circles = [...circleElements, ...triangleElements];
					}
					// console.log(circles);

					const svgContainer =
						document.getElementById("svg-container");
					const { scaleX, scaleY } = calculateLabelOffset(
						globalSvgContainer.querySelector("svg"),
					);

					const { width } = globalSvgContainer
						.querySelector("svg")
						.getBoundingClientRect();
					const labelDiv = document.createElement("div");
					labelDiv.setAttribute("id", "labelDiv");
					labelDiv.style.width = "4096px";
					labelDiv.style.height = "4096px";
					// labelDiv.style.width = "100%";
					// labelDiv.style.height = "100%";
					labelDiv.style.position = "absolute";
					labelDiv.style.transform = `scale(${1 / scaleX})`;
					labelDiv.style.left = `-${2048 - 4096 / scaleY / 2}px`;
					labelDiv.style.top = `-${2048 - 4096 / scaleY / 2}px`;
					labelDiv.style.pointerEvents = "none";

					const createParagraph = (
						className,
						text,
						display,
						color = "white",
					) => {
						const p = document.createElement("p");
						Object.assign(p.style, {
							color: color,
							margin: "0px",
							pointerEvents: "none",
							lineHeight: "1.2em",
						});
						// Only set display if className doesn't include Tailwind display classes
						if (!className.includes("hidden") && !className.includes("block")) {
							p.style.display = display;
						}
						p.className = className;
						p.innerHTML = text; // Changed from textContent to innerHTML to support line breaks
						return p;
					};

					// Helper function to format text with line breaks for more than 3 words
					const formatTextWithLineBreaks = (text) => {
						// Extract room name from pattern like "0_Balcony_1" -> "Balcony"
						// or "0_MasterBedroomBathroom_1" -> "MasterBedroomBathroom"
						let cleanedText = text;
						
						// If the text contains underscores, extract the middle part(s)
						if (text.includes('_')) {
							const parts = text.split('_');
							// Remove first and last parts if they are numbers
							const isFirstPartNumber = /^\d+$/.test(parts[0]);
							const isLastPartNumber = /^\d+$/.test(parts[parts.length - 1]);
							
							if (isFirstPartNumber && isLastPartNumber && parts.length >= 3) {
								// Take everything except first and last part
								cleanedText = parts.slice(1, -1).join('');
							} else if (isFirstPartNumber && parts.length >= 2) {
								// Only remove first part if it's a number
								cleanedText = parts.slice(1).join('');
							}
						}
						
						// Add spaces before capital letters and numbers
						const spacedText = cleanedText
							.replace(/([A-Z0-9])/g, " $1")
							.trim();
						
						const words = spacedText.split(' ').filter(word => word.length > 0);
						if (words.length > 2) {
							// Split roughly in half
							const midPoint = Math.ceil(words.length / 2);
							const firstLine = words.slice(0, midPoint).join(' ');
							const secondLine = words.slice(midPoint).join(' ');
							return `${firstLine}<br>${secondLine}`;
						}
						return spacedText;
					};

					const createDiv = (e) => {
						const div = document.createElement("div");
						div.setAttribute(
							"data-fullname",
							e.getAttribute("data-fullname"),
						);
						
						// Handle both circles (cx/cy) and triangles (data-center-x/y)
						const cx = e.getAttribute("cx") || e.getAttribute("data-center-x");
						const cy = e.getAttribute("cy") || e.getAttribute("data-center-y");
						
						Object.assign(div.style, {
							position: "absolute",
							left: `${cx}px`,
							top: `${cy}px`,
							transform: "translate(-50%, 0.25rem)",
							backgroundColor: "rgba(0, 0, 0, 0.5)",
							border: "2px solid rgba(255, 255, 255, 0.1)",
							padding: "0.5rem 1rem",
							borderRadius: "0.75rem",
							marginBottom: "0.25rem",
							zIndex: "10",
							backdropFilter: "blur(10px)",
							pointerEvents: "none",
							textAlign: "center",
							fontSize: "36px",
							fontWeight: "400",
							whiteSpace: "nowrap",
							width: "auto",
						});
						
						// Set font-family with !important to override global Gabarito font
						div.style.setProperty("font-family", "Poppins, sans-serif", "important");

						const formattedText = formatTextWithLineBreaks(e.id);
						
						// Create paragraph with text
						const p = document.createElement("p");
						p.style.color = "white";
						p.style.margin = "0px";
						p.style.pointerEvents = "none";
						p.style.lineHeight = "40px";
						p.style.textAlign = "center";
						// Set font-family with !important on paragraph as well
						p.style.setProperty("font-family", "Poppins, sans-serif", "important");
						p.innerHTML = formattedText;
						div.appendChild(p);
						
						return div;
					};

					const createPreviewDiv1 = (e) => {
						const div = document.createElement("div");
						div.setAttribute(
							"data-fullname",
							e.getAttribute("data-fullname"),
						);
						
						// Handle both circles (cx/cy) and triangles (data-center-x/y)
						const cx = e.getAttribute("cx") || e.getAttribute("data-center-x");
						const cy = e.getAttribute("cy") || e.getAttribute("data-center-y");
						
						Object.assign(div.style, {
							position: "absolute",
							color: "rgba(0, 0, 0, 255)",
							left: `${cx}px`,
							top: `${cy}px`,
							transform: "translate(-50%, -101%)",
							backgroundColor: "rgba(0, 0, 0, 0)",
							border: "2px solid rgba(0, 0, 0, 1)",
							padding: "4px 24px",
							borderRadius: "0.75rem",
							marginBottom: "0.25rem",
							zIndex: "10",
							pointerEvents: "none",
							cursor: "pointer",
							textAlign: "center",
							fontSize: "2.25rem",
						});

						const formattedText = formatTextWithLineBreaks(e.id);
						div.appendChild(
							createParagraph(
								"text-normal",
								formattedText,
								"block",
								"rgba(0,0,0,0)",
							),
						);
						return div;
					};

					const createPreviewDiv2 = (e) => {
						const div = document.createElement("div");
						div.setAttribute(
							"data-fullname",
							e.getAttribute("data-fullname"),
						);

						// Handle both circles (cx/cy) and triangles (data-center-x/y)
						const cx = parseFloat(e.getAttribute("cx") || e.getAttribute("data-center-x"));
						const cy = parseFloat(e.getAttribute("cy") || e.getAttribute("data-center-y"));

						// Apply initial styles for measurement
						Object.assign(div.style, {
							position: "absolute",
							visibility: "hidden", // Prevents flickering during measurement
							whiteSpace: "nowrap", // Ensure proper size calculation
							fontSize: "2.25rem", // Match intended font size
							padding: "6px 28px",
						});

						const formattedText = formatTextWithLineBreaks(e.id);
						div.appendChild(
							createParagraph(
								"text-normal",
								formattedText,
								"block",
								"rgba(0,0,0,0)",
							),
						);

						// Append to document for measurement
						document.body.appendChild(div);
						const { width, height } = div.getBoundingClientRect();
						document.body.removeChild(div); // Remove after measuring
						div.querySelectorAll("p").forEach((e) => e.remove());

						// // Calculate the adjusted offsets based on rotation
						// const adjustedLeft = cx - height; // Use height for horizontal adjustment
						// const adjustedTop = cy - width / 2;  // Use width for vertical adjustment

						// Final styles with rotation and alignment
						Object.assign(div.style, {
							position: "absolute",
							color: "rgba(0, 0, 0, 255)",
							left: `${cx}px`,
							top: `${cy - width / 2}px`,
							width: `${height}px`,
							height: `${width}px`,
							// transform: `rotate(90deg)`, // Rotate around the center
							backgroundColor: "rgba(0, 0, 0, 0)",
							border: "2px solid rgba(0, 0, 0, 1)",
							borderRadius: "0.75rem",
							marginBottom: "0.25rem",
							zIndex: "10",
							pointerEvents: "none",
							cursor: "pointer",
							textAlign: "center",
							fontSize: "2.25rem",
							visibility: "visible", // Make visible after measurement
						});

						return div;
					};

					const createPreviewDiv3 = (e) => {
						const div = document.createElement("div");
						div.setAttribute(
							"data-fullname",
							e.getAttribute("data-fullname"),
						);

						// Handle both circles (cx/cy) and triangles (data-center-x/y)
						const cx = parseFloat(e.getAttribute("cx") || e.getAttribute("data-center-x"));
						const cy = parseFloat(e.getAttribute("cy") || e.getAttribute("data-center-y"));

						// Apply initial styles for measurement
						Object.assign(div.style, {
							position: "absolute",
							visibility: "hidden", // Prevents flickering during measurement
							whiteSpace: "nowrap", // Ensure proper size calculation
							fontSize: "2.25rem", // Match intended font size
							padding: "6px 28px",
						});

						const formattedText = formatTextWithLineBreaks(e.id);
						div.appendChild(
							createParagraph(
								"text-normal",
								formattedText,
								"block",
								"rgba(0,0,0,0)",
							),
						);

						// Append to document for measurement
						document.body.appendChild(div);
						const { width, height } = div.getBoundingClientRect();
						document.body.removeChild(div); // Remove after measuring
						div.querySelectorAll("p").forEach((e) => e.remove());

						// // Calculate the adjusted offsets based on rotation
						// const adjustedLeft = cx - height; // Use height for horizontal adjustment
						// const adjustedTop = cy - width / 2;  // Use width for vertical adjustment

						// Final styles with rotation and alignment
						Object.assign(div.style, {
							position: "absolute",
							color: "rgba(0, 0, 0, 255)",
							left: `${cx - height}px`,
							top: `${cy - width / 2}px`,
							width: `${height}px`,
							height: `${width}px`,
							// transform: `rotate(90deg)`, // Rotate around the center
							backgroundColor: "rgba(0, 0, 0, 0)",
							border: "2px solid rgba(0, 0, 0, 1)",
							borderRadius: "0.75rem",
							marginBottom: "0.25rem",
							zIndex: "10",
							pointerEvents: "none",
							cursor: "pointer",
							textAlign: "center",
							fontSize: "2.25rem",
							visibility: "visible", // Make visible after measurement
						});

						return div;
					};

					const toggleHover = (div, isHovered) => {
						div.style.borderColor = isHovered
							? "rgba(255, 255, 255, 1)"
							: "rgba(255, 255, 255, 0.1)";
						div.querySelector(".text-normal").style.display =
							isHovered ? "none" : "block";
						div.querySelector(".text-hover").style.display =
							isHovered ? "block" : "none";
					};

					// Helper function to get bounding box of an element relative to labelDiv
					function getBoundingBox(element) {
						// Get position from style (in labelDiv coordinate system, before labelDiv's scale transform)
						const left = parseFloat(element.style.left) || 0;
						const top = parseFloat(element.style.top) || 0;
						
						// Get the canvas zoom scale from svgContainer's transform
						const svgContainerTransform = svgContainer.style.transform || '';
						const canvasZoomScale = parseFloat(
							svgContainerTransform.match(/scale\(([^)]+)\)/)?.[1]
						) || 1;
						
						// Get dimensions from getBoundingClientRect (screen coordinates)
						const rect = element.getBoundingClientRect();
						
						// Convert screen dimensions back to labelDiv coordinate system
						// labelDiv has transform: scale(1/scaleX), and svgContainer has zoom scale
						// So we need to multiply by scaleX and divide by canvasZoomScale
						// to get the dimensions in labelDiv's coordinate system
						const width = (rect.width * scaleX) / canvasZoomScale;
						const height = (rect.height * scaleX) / canvasZoomScale;
						
						// Parse transform to get offset (translate affects position)
						const transform = element.style.transform || '';
						let offsetX = 0, offsetY = 0;
						
						if (transform.includes('translate')) {
							const translateMatch = transform.match(/translate\(([^)]+)\)/);
							if (translateMatch) {
								const parts = translateMatch[1].split(',').map(s => s.trim());
								const xVal = parts[0];
								const yVal = parts[1] || parts[0];
								
								// Handle percentage or pixel values
								// For percentages, use the element's width/height in labelDiv coordinates
								if (xVal.includes('%')) {
									offsetX = (parseFloat(xVal) / 100) * width;
								} else {
									offsetX = parseFloat(xVal.replace('px', '')) || 0;
								}
								
								if (yVal.includes('%')) {
									offsetY = (parseFloat(yVal) / 100) * height;
								} else {
									offsetY = parseFloat(yVal.replace('px', '')) || 0;
								}
							}
						}
						
						// Calculate actual bounding box in labelDiv coordinate system
						const actualLeft = left + offsetX;
						const actualTop = top + offsetY;
						
						return {
							left: actualLeft,
							top: actualTop,
							right: actualLeft + width,
							bottom: actualTop + height,
							width: width,
							height: height
						};
					}

					// Helper function to check if two bounding boxes overlap
					function boxesOverlap(box1, box2, padding = 8) {
						return !(
							box1.right + padding < box2.left ||
							box1.left - padding > box2.right ||
							box1.bottom + padding < box2.top ||
							box1.top - padding > box2.bottom
						);
					}

					// Function to highlight colliding labels in red
					function highlightCollisions(labelCircleMap) {
						if (labelCircleMap.length === 0) return;
						
						// Track which labels are colliding
						const collidingLabels = new Set();
						
						// Check for collisions
						for (let i = 0; i < labelCircleMap.length; i++) {
							const currentLabel = labelCircleMap[i].label;
							const currentBox = getBoundingBox(currentLabel);
							
							for (let j = i + 1; j < labelCircleMap.length; j++) {
								const otherLabel = labelCircleMap[j].label;
								const otherBox = getBoundingBox(otherLabel);
								
								if (boxesOverlap(currentBox, otherBox)) {
									// Mark both labels as colliding
									collidingLabels.add(currentLabel);
									collidingLabels.add(otherLabel);
								}
							}
						}
						
						// Apply highlighting to colliding labels, restore original styles for others
						labelCircleMap.forEach(({ label }) => {
							if (collidingLabels.has(label)) {
								// Highlight colliding labels in red
								label.style.borderColor = "red";
								label.style.borderWidth = "3px";
								label.style.backgroundColor = "rgba(255, 0, 0, 0.2)";
							} else {
								// Restore original border width
								label.style.borderWidth = "2px";
								// Border color and background will be restored by their original styles
								// or by the toggleHover function for bottom labels
							}
						});
					}

					// Create all labels and group them by position type
					const labelGroups = {
						top: [],
						bottom: [],
						left: [],
						right: []
					};

					circles.forEach((e) => {
						const div = createDiv(e); // Bottom label
						const previewDiv1 = createPreviewDiv1(e); // Top label
						const previewDiv2 = createPreviewDiv2(e); // Right label
						const previewDiv3 = createPreviewDiv3(e); // Left label
						
						// Add to labelDiv
						labelDiv.appendChild(div);
						labelDiv.appendChild(previewDiv1);
						labelDiv.appendChild(previewDiv2);
						labelDiv.appendChild(previewDiv3);
						
						// Group labels by position type for collision detection
						labelGroups.bottom.push({ label: div });
						labelGroups.top.push({ label: previewDiv1 });
						labelGroups.right.push({ label: previewDiv2 });
						labelGroups.left.push({ label: previewDiv3 });
					});

					// Append labelDiv to container so measurements work
					svgContainer.prepend(labelDiv);

					// Highlight collisions after labels are fully rendered
					// Use double RAF to ensure layout is complete
					requestAnimationFrame(() => {
						requestAnimationFrame(() => {
							// Highlight collisions for each group
							highlightCollisions(labelGroups.top);
							highlightCollisions(labelGroups.bottom);
							highlightCollisions(labelGroups.left);
							highlightCollisions(labelGroups.right);
						});
					});
				}
			} else {
				console.log("No labels toggle found");
			}
		}

		function killLabels(toggleChecked?) {
			if (document.getElementById("labelDiv")) {
				document.getElementById("labelDiv").remove();
				if (!toggleChecked) {
					document.getElementById("showLabelsToggle").checked = false;
				} else {
					// console.log("toggleChecked true, retaining checked state")
				}
			} else {
				// console.log("labelDiv not found");
			}
		}

		function updateStates(circles, transformedLines, group) {
			if (!group) {
			} else if (group instanceof SVGGElement) {
				console.log("Is group");
				var thisCircles = [].slice.call(
					group.getElementsByTagName("circle"),
				);

				updateValuesModal.set(true);
				console.log("Set updateValuesModal");
				updateValuesList.set(transformedLines);
				currentValuesList.set(thisCircles);
			}
		}

		function updateValues(file) {
			var circles = [];
			const group = globalSvgContainer
				.querySelector("svg")
				.querySelector("g");
			console.log(group);

			const reader = new FileReader();
			reader.onload = (event) => {
				const contents = event.target.result;
				const lines = contents.trim().split("\n");

				// Check the number of columns and decide to transform
				const firstLineFields = lines[0].split(",");
				let transformedLines = lines;

				if (firstLineFields.length > 3) {
					//Camera CSV
					transformedLines = lines.map((line) => {
						const fields = line.split(",");
						const [name, x, y, z] = fields;
						const cleanedName = name.split("_")[1]
							? name.split("_")[1]
							: undefined;
						if (cleanedName) {
							return { name: cleanedName, x: -y, y: -x }; // Swap x and y
						}
					});
					updateStates(circles, transformedLines, group);
				} else {
					//Floorplan CSV
					transformedLines = lines.map((line) => {
						const fields = line.split(",");
						const [name, x, y] = fields;
						const cleanedName = name.split("_")[1]
							? name.split("_")[1]
							: undefined;
						if (cleanedName) {
							return { name: cleanedName, x: x, y: y }; // Swap x and y
						}
					});
					updateStates(circles, transformedLines, group);
				}
				spawnLabel();
			};
			reader.readAsText(file);
		}

		function removeData() {
			const doc = document.querySelector("#svg-container");
			const xml = `<?xml version="1.0" encoding="UTF-8"?>`;
			const defs = doc.querySelector("defs");
			const maskParent = document.querySelector("defs");
			const maskChild = maskParent.children;
			const maskShape = Array.from(maskChild).map((e) => {
				const shape = e.children[0];
				if (shape) {
					if (
						shape.nodeName == "polygon" ||
						shape.nodeName == "path"
					) {
						const className = shape.classList[0];
						shape.classList.remove(className);
						return shape;
					}
				}
			});

			var kvPair = Object.assign(
				{},
				...Array.from(document.styleSheets[1].cssRules).map((e) => {
					// return e.selectorText
					// return e.style.clipPath
					if (e.style.clipPath) {
						var str = e.style.clipPath;
						var regex = /#([\w-]+)/; // \w matches any alphanumeric character
						var match = regex.exec(str); // exec returns an array of matches
						var id = "#" + match[1]; // the first capture group is the ID
						return { [e.selectorText.replace(/[-.]/g, "")]: id };
					}
				}),
			);

			// kvPair = kvPair.filter(element => {
			//     return element !== undefined;
			// })
			var classes = [
				"cls-8158",
				"cls-8167",
				"cls-8163",
				"cls-8166",
				"cls-8165",
			];
			console.log(kvPair);
			const classValues = document
				.getElementById("myClasses")
				.value.replace(/\s/g, "");
			if (classValues) {
				classes = classValues.split(",");
			}

			var units = [];
			if (classes) {
				classes.forEach((e) => {
					doc.querySelectorAll(`.${e}`).forEach((i) => {
						console.log(i);
						const parentClass = String(
							i.parentElement.classList[0],
						);
						const refId = kvPair[parentClass.replace(/[-.]/g, "")];
						console.log(parentClass);
						const refEl = doc
							.querySelector("defs")
							.querySelector(refId);
						var child;
						if (refEl) {
							console.log(refEl);
							child = refEl.children[0];
							child.classList.remove(child.classList[0]);
							child.classList.add(e);
							units.push(child);
							return child;
						}
					});
				});
			}

			console.log("units");
			console.log(units);

			const output = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"g",
			);

			var svg = doc.querySelector("svg");
			console.log(svg);
			while (svg.firstChild) {
				svg.removeChild(svg.firstChild);
			}

			svg.append(defs);
			units.forEach((e) => {
				console.log(e);
				svg.append(e);
			});
		}

		function getStyleSheet(unique_title) {
			for (const sheet of document.styleSheets) {
				if (sheet.title === unique_title) {
					return sheet;
				}
			}
		}

		// Project CSV data storage

		let projectData = [];
		let floorLevels = new Map(); // Map of Z value to floor data

		function renderProjectCsvPreview(csvText) {
			projectData = [];
			floorLevels.clear();

			const rows = csvText.trim().split(/\r?\n/);
			console.log('CSV rows:', rows.length);
			if (rows.length < 2) return;
			
			const headers = rows[0].split(',');
			console.log('Headers:', headers);
			
			// Find relevant columns
			const idxX = headers.findIndex(h => h.trim().toLowerCase() === 'position_x_meters');
			const idxY = headers.findIndex(h => h.trim().toLowerCase() === 'position_y_meters');
			const idxZ = headers.findIndex(h => h.trim().toLowerCase() === 'position_z_meters');
			const idxDir = headers.findIndex(h => h.trim().toLowerCase() === 'cardinal_direction');
			
			console.log('Column indices:', { idxX, idxY, idxZ, idxDir });
			
			// Try to find ID column (Index or FileName)
			let idxId = headers.findIndex(h => h.toLowerCase() === 'filename');
			if (idxId === -1) idxId = headers.findIndex(h => h.toLowerCase() === 'index');
			if (idxId === -1) idxId = 0; // fallback to first column

			if (idxX === -1 || idxY === -1 || idxZ === -1 || idxDir === -1) {
				console.error('Missing required columns (Position_X_Meters, Position_Y_Meters, Position_Z_Meters, Cardinal_Direction)');
				console.error('Available headers:', headers);
				return;
			}

			// Parse data and group by Z levels
			for (let i = 1; i < rows.length; i++) {
				const cols = rows[i].split(',');
				const x = parseFloat(cols[idxX]);
				const y = parseFloat(cols[idxY]);
				const z = parseFloat(cols[idxZ]);
				
				// Convert cardinal direction to degrees
				let dir = parseFloat(cols[idxDir]);
				if (isNaN(dir)) {
					const cardinalStr = cols[idxDir].trim().toUpperCase();
					switch (cardinalStr) {
						case 'NORTH': dir = 180; break;
						case 'SOUTH': dir = 0; break;
						case 'EAST': dir = 270; break;
						case 'WEST': dir = 90; break;
						default: 
							console.log(`Row ${i} - unknown cardinal direction: ${cardinalStr}`);
							continue;
					}
				}
				
				const id = cols[idxId];

				console.log(`Row ${i}:`, { x, y, z, dir, id });

				if (isNaN(x) || isNaN(y) || isNaN(z) || isNaN(dir)) {
					console.log(`Row ${i} skipped - invalid data:`, cols[idxX], cols[idxY], cols[idxZ], cols[idxDir]);
					continue;
				}

				const point = { x, y, z, dir, id, visible: true };
				projectData.push(point);

				// Group by Z level
				if (!floorLevels.has(z)) {
					floorLevels.set(z, { points: [], visible: true });
				}
				floorLevels.get(z).points.push(point);
			}

			console.log('Project CSV parsed:', projectData.length, 'points');
			
			// Create floor toggles using existing floor system
			createProjectFloorToggles();
			renderProjectTriangles();
		}

		function createProjectFloorToggles() {
			const floorSection = document.getElementById("show-floors");
			if (floorSection.classList.contains("hidden")) {
				floorSection.classList.remove("hidden");
			}

			// Get unique Z levels
			const sortedFloors = Array.from(floorLevels.keys()).sort((a, b) => b - a);
			
			// Track drag state for floor toggles
			let isDraggingFloors = false;
			let dragToggleState = null; // true for enabling, false for disabling
			
			// Add toggles for each floor level
			sortedFloors.forEach((zLevel, index) => {
				const pointCount = floorLevels.get(zLevel).points.length;
				const div = document.createElement("div");
				const checkbox = document.createElement("input");
				const label = document.createElement("label");

				label.innerText = `Floor ${index} (${zLevel}m)`;
				label.htmlFor = `project-floor-${zLevel}-checkbox`;
				checkbox.type = "checkbox";
				checkbox.checked = true;
				checkbox.id = `project-floor-${zLevel}-checkbox`;

				div.appendChild(checkbox);
				div.appendChild(label);

				checkbox.addEventListener("change", (e) => {
					toggleProjectFloorVisibility(zLevel, (e.target as HTMLInputElement).checked);
				});

				// Add drag-to-toggle functionality
				div.addEventListener("mousedown", function(e) {
					// Only start drag if NOT clicking directly on the checkbox
					if (e.target === checkbox) return;
					e.preventDefault();
					isDraggingFloors = true;
					dragToggleState = !checkbox.checked; // Toggle to opposite state
					checkbox.checked = dragToggleState;
					toggleProjectFloorVisibility(zLevel, dragToggleState);
					div.classList.add('dragging');
				});

				div.addEventListener("mouseenter", function(e) {
					if (isDraggingFloors && dragToggleState !== null) {
						checkbox.checked = dragToggleState;
						toggleProjectFloorVisibility(zLevel, dragToggleState);
						div.classList.add('dragging');
					}
				});

				div.addEventListener("mouseleave", function(e) {
					div.classList.remove('dragging');
				});

				// Style the div for better drag interaction
				div.style.cursor = 'pointer';
				div.style.userSelect = 'none';
				div.style.borderRadius = '4px';
				div.style.transition = 'background-color 0.15s';
				div.setAttribute('data-project-floor', zLevel.toString());

				floorSection.appendChild(div);
			});

			// Global mouse up to end dragging
			document.addEventListener("mouseup", function() {
				if (isDraggingFloors) {
					isDraggingFloors = false;
					dragToggleState = null;
					// Remove dragging class from all floor divs
					const draggingDivs = floorSection.querySelectorAll('.dragging');
					draggingDivs.forEach(div => div.classList.remove('dragging'));
				}
			});
		}

		function toggleProjectFloorVisibility(zLevel, visible) {
			floorLevels.get(zLevel).visible = visible;
			floorLevels.get(zLevel).points.forEach(point => {
				point.visible = visible;
			});
			renderProjectTriangles();
			spawnLabel(); // Update labels
		}

		function renderProjectTriangles() {
			// Debug: Log entry
			console.log('renderProjectTriangles called');

			// Ensure main SVG exists
			let mainSvg = svgContainer.querySelector('svg');
			if (!mainSvg) {
				console.log('No main SVG found, creating new SVG');
				mainSvg = createNewSVG();
				svgContainer.appendChild(mainSvg);
			}

			// Clear existing triangles in main SVG
			let gInstance = mainSvg.querySelector('#g-instance');
			if (!gInstance) {
				// If not present, create and append to main SVG
				gInstance = document.createElementNS('http://www.w3.org/2000/svg', 'g');
				gInstance.setAttribute('id', 'g-instance');
				mainSvg.appendChild(gInstance);
			}
			gInstance.innerHTML = '';

			// Debug: Log SVG and g-instance
			console.log('mainSvg:', mainSvg);
			console.log('gInstance:', gInstance);

			// Get visible points
			const visiblePoints = projectData.filter(p => p.visible);
			console.log('visiblePoints:', visiblePoints.length);
			if (visiblePoints.length === 0) return;

			// Calculate bounds for normalization
			let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
			visiblePoints.forEach(pt => {
				if (pt.x < minX) minX = pt.x;
				if (pt.x > maxX) maxX = pt.x;
				if (pt.y < minY) minY = pt.y;
				if (pt.y > maxY) maxY = pt.y;
			});

			// Triangle shape (points down at 0deg) - bigger size
			const tri = [
				{ x: 0, y: 50 },
				{ x: -30, y: -30 },
				{ x: 30, y: -30 }
			];

			// Color map for different Z levels
			const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#34495e'];
			const sortedZLevels = Array.from(floorLevels.keys()).sort();

			const svgNS = 'http://www.w3.org/2000/svg';
			const mainW = 4096, mainH = 4096;
			const pad = 40;

			visiblePoints.forEach(pt => {
				// Convert cardinal direction to degrees
				let angle = 0;
				if (typeof pt.dir === 'string') {
					switch (pt.dir.toUpperCase()) {
						case 'NORTH': angle = 180; break;
						case 'SOUTH': angle = 0; break;
						case 'EAST': angle = 270; break;
						case 'WEST': angle = 90; break;
						default: angle = parseFloat(pt.dir) || 0;
					}
				} else {
					angle = pt.dir;
				}

				// Map coordinates to main SVG coordinates (4096x4096)
				const mainPx = ((pt.x - minX) / (maxX - minX || 1)) * (mainW - 2*pad) + pad;
				const mainPy = mainH - (((pt.y - minY) / (maxY - minY || 1)) * (mainH - 2*pad) + pad);

				// Log all parameters used for calculating mainPx and mainPy
				console.log('[Triangle Center Calculation]', {
					'pt.x': pt.x,
					'pt.y': pt.y,
					minX,
					maxX,
					minY,
					maxY,
					mainW,
					mainH,
					pad,
					mainPx,
					mainPy
				});

				// Guard: skip if center is invalid
				if (isNaN(mainPx) || isNaN(mainPy)) {
					console.error('Skipping triangle: Invalid center coordinates', {pt, minX, maxX, minY, maxY, mainPx, mainPy});
					return;
				}

				const mainTri = tri.map(p => {
					const rad = angle * Math.PI / 180;
					const rx = p.x * Math.cos(rad) - p.y * Math.sin(rad);
					const ry = p.x * Math.sin(rad) + p.y * Math.cos(rad);
					return `${mainPx + rx},${mainPy + ry}`;
				}).join(' ');
				const mainPolygon = document.createElementNS(svgNS, 'polygon');
				mainPolygon.setAttribute('points', mainTri);
				const colorIndex = sortedZLevels.indexOf(pt.z) % colors.length;
				mainPolygon.setAttribute('fill', colors[colorIndex]);
				mainPolygon.setAttribute('stroke', '#333');
				mainPolygon.setAttribute('stroke-width', '1');
				
				// Make triangles selectable like circles
				mainPolygon.setAttribute('id', String(pt.id));
				mainPolygon.setAttribute('data-floor', String(pt.z));
				mainPolygon.setAttribute('data-fullname', String(pt.id));
				mainPolygon.setAttribute('data-id', String(pt.id));
				mainPolygon.setAttribute('data-dir', String(angle)); // Store the numeric angle, not the original string
				mainPolygon.setAttribute('data-z', String(pt.z));
				
				// Add triangle-specific attributes for scaling/moving
				mainPolygon.setAttribute('data-triangle', 'true');
				mainPolygon.setAttribute('data-center-x', String(mainPx));
				mainPolygon.setAttribute('data-center-y', String(mainPy));
				mainPolygon.setAttribute('data-scale', '1');
				
				mainPolygon.style.cursor = 'pointer';
				console.log('Adding triangle to gInstance:', mainPolygon);
				gInstance.appendChild(mainPolygon);
			});
			
			console.log('gInstance children count:', gInstance.children.length);
		}

		function showProjectLabel(x, y, id, dir, z) {
			hideProjectLabel();
			const label = document.createElement('div');
			label.id = 'project-csv-label';
			label.style.position = 'absolute';
			label.style.left = `${x + 12}px`;
			label.style.top = `${y - 12}px`;
			label.style.background = 'rgba(0,0,0,0.85)';
			label.style.color = '#fff';
			label.style.padding = '6px 12px';
			label.style.borderRadius = '6px';
			label.style.fontSize = '12px';
			label.style.pointerEvents = 'none';
			label.style.zIndex = '10';
			label.innerHTML = `<b>ID:</b> ${id}<br><b>Direction:</b> ${dir}<br><b>Level:</b> ${z}m`;
			document.body.appendChild(label);
		}

		function hideProjectLabel() {
			const label = document.getElementById('project-csv-label');
			if (label) label.remove();
		}

		// Close context menu when clicking elsewhere (anywhere except the menu itself)
		document.addEventListener('click', (e) => {
			if (svgContextMenu && svgContextMenu.style.display === 'block') {
				if (!svgContextMenu.contains(e.target as Node)) {
					svgContextMenu.style.display = 'none';
				}
			}
		});

		// Also close on right-click outside the menu
		document.addEventListener('contextmenu', (e) => {
			if (svgContextMenu && svgContextMenu.style.display === 'block') {
				if (!svgContextMenu.contains(e.target as Node)) {
					svgContextMenu.style.display = 'none';
				}
			}
		});

		// Initialize context menu on page load
		createSVGContextMenu();

		// DXF Batch Processing
		// Load dxf-parser from CDN (using unpkg which exposes it as a global)
		let DxfParser = null;
		let dxfParserLoaded = false;
		
		function loadDxfParser() {
			return new Promise<void>((resolve, reject) => {
				if (dxfParserLoaded && DxfParser) {
					resolve();
				return;
			}
			
				// Check if already loading
				if (document.querySelector('script[data-dxf-parser]')) {
					const checkInterval = setInterval(() => {
						if (dxfParserLoaded && DxfParser) {
							clearInterval(checkInterval);
							resolve();
						}
					}, 100);
					setTimeout(() => {
						clearInterval(checkInterval);
						if (!dxfParserLoaded) {
							reject(new Error('DXF parser loading timeout'));
						}
					}, 10000);
				return;
			}
			
				const dxfParserScript = document.createElement('script');
				dxfParserScript.setAttribute('data-dxf-parser', 'true');
				// Try multiple CDN sources
				dxfParserScript.src = 'https://unpkg.com/dxf-parser@1.4.0/dist/dxf-parser.js';
				dxfParserScript.onload = () => {
					// Try to get the parser from different possible global names
					DxfParser = (window as any).DxfParser || (window as any).dxfParser || (window as any).DXFParser;
					if (DxfParser) {
						dxfParserLoaded = true;
						console.log('DXF Parser loaded');
						resolve();
					} else {
						reject(new Error('DXF Parser not found in global scope'));
					}
				};
				dxfParserScript.onerror = () => {
					reject(new Error('Failed to load DXF parser from CDN'));
				};
				document.head.appendChild(dxfParserScript);
			});
		}

		// Helper function to strip MTEXT formatting codes
		function stripMtextFormatting(text) {
			if (!text) return text;
			// Remove line break codes like \A1;
			return text.replace(/\\A\d+;/g, '');
		}

		// Helper function to extract dimension data from DXF
		function extractDimensionData(dxf) {
			const dimensionData = {};
			
			if (!dxf || !dxf.entities) return dimensionData;
			
			// Find all DIMENSION entities
			const dimensions = dxf.entities.filter(e => e.type === 'DIMENSION');
			
			dimensions.forEach(dim => {
				// Get measurement
				const measurement = dim.measurement || dim.actualMeasurement || 0;
				
				// Get text from dimension block if available
				let text = dim.text || '';
				
				// Try to get text from associated block
				if (dxf.blocks && dim.block) {
					const block = dxf.blocks[dim.block];
					if (block && block.entities) {
						for (const entity of block.entities) {
							if (entity.type === 'MTEXT' || entity.type === 'TEXT') {
								text = stripMtextFormatting(entity.text || '');
								break;
							}
						}
					}
				}
				
				if (text) {
					dimensionData[text] = measurement;
				}
			});
			
			return dimensionData;
		}

		// Convert DXF entities to SVG paths
		function dxfEntitiesToSVG(dxf, layerNames = null) {
			if (!dxf || !dxf.entities) return '';
			
			let svgPaths = '';
			
			// Filter entities by layer if specified
			const filteredEntities = layerNames 
				? dxf.entities.filter(e => layerNames.includes(e.layer))
				: dxf.entities;
			
			filteredEntities.forEach(entity => {
				let path = '';
				
				switch (entity.type) {
					case 'LINE':
						if (entity.start && entity.end) {
							path = `M ${entity.start.x} ${entity.start.y} L ${entity.end.x} ${entity.end.y}`;
						}
						break;
					case 'LWPOLYLINE':
					case 'POLYLINE':
						if (entity.vertices && entity.vertices.length > 0) {
							path = `M ${entity.vertices[0].x} ${entity.vertices[0].y}`;
							for (let i = 1; i < entity.vertices.length; i++) {
								path += ` L ${entity.vertices[i].x} ${entity.vertices[i].y}`;
							}
							if (entity.closed) {
								path += ' Z';
							}
						}
						break;
					case 'ARC':
						if (entity.center && entity.radius !== undefined) {
							const startAngle = (entity.startAngle || 0) * Math.PI / 180;
							const endAngle = (entity.endAngle || 360) * Math.PI / 180;
							const startX = entity.center.x + entity.radius * Math.cos(startAngle);
							const startY = entity.center.y + entity.radius * Math.sin(startAngle);
							const endX = entity.center.x + entity.radius * Math.cos(endAngle);
							const endY = entity.center.y + entity.radius * Math.sin(endAngle);
							const largeArc = (endAngle - startAngle) > Math.PI ? 1 : 0;
							path = `M ${startX} ${startY} A ${entity.radius} ${entity.radius} 0 ${largeArc} 1 ${endX} ${endY}`;
						}
						break;
					case 'CIRCLE':
						if (entity.center && entity.radius !== undefined) {
							// Convert circle to path
							const cx = entity.center.x;
							const cy = entity.center.y;
							const r = entity.radius;
							path = `M ${cx + r} ${cy} A ${r} ${r} 0 1 1 ${cx - r} ${cy} A ${r} ${r} 0 1 1 ${cx + r} ${cy}`;
						}
						break;
					case 'SPLINE':
						if (entity.controlPoints && entity.controlPoints.length > 0) {
							path = `M ${entity.controlPoints[0].x} ${entity.controlPoints[0].y}`;
							for (let i = 1; i < entity.controlPoints.length; i++) {
								path += ` L ${entity.controlPoints[i].x} ${entity.controlPoints[i].y}`;
							}
						}
						break;
				}
				
				if (path) {
					// Create a group for each entity with its layer name
					const groupId = `patch-${entity.handle || Math.random().toString(36).substr(2, 9)}`;
					svgPaths += `<g id="${groupId}" stroke="white" stroke-width="1" fill="none">
						<path d="${path}"/>
					</g>`;
				}
			});
			
			return svgPaths;
		}

		// Process a single DXF file
		async function processDXFFile(file) {
			return new Promise((resolve, reject) => {
				const reader = new FileReader();
				reader.onload = (e) => {
					try {
						if (!DxfParser) {
							reject(new Error('DXF Parser not loaded yet. Please wait a moment and try again.'));
				return;
			}
			
						const parser = new DxfParser();
						const dxf = parser.parseSync(e.target.result);
						
						// Extract dimension data
						const dimensionData = extractDimensionData(dxf);
						
						// Convert to SVG (only KT-Dim layer)
						const svgPaths = dxfEntitiesToSVG(dxf, ['KT-Dim']);
						
						// Calculate bounding box
						let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
						if (dxf.entities) {
							dxf.entities.filter(e => e.layer === 'KT-Dim').forEach(entity => {
								if (entity.start) {
									minX = Math.min(minX, entity.start.x);
									maxX = Math.max(maxX, entity.start.x);
									minY = Math.min(minY, entity.start.y);
									maxY = Math.max(maxY, entity.start.y);
								}
								if (entity.end) {
									minX = Math.min(minX, entity.end.x);
									maxX = Math.max(maxX, entity.end.x);
									minY = Math.min(minY, entity.end.y);
									maxY = Math.max(maxY, entity.end.y);
								}
								if (entity.vertices) {
									entity.vertices.forEach(v => {
										minX = Math.min(minX, v.x);
										maxX = Math.max(maxX, v.x);
										minY = Math.min(minY, v.y);
										maxY = Math.max(maxY, v.y);
									});
								}
							});
						}
						
						// Default viewBox if no entities found
						if (!isFinite(minX)) {
							minX = 0; maxX = 4096; minY = 0; maxY = 4096;
						}
						
						const width = maxX - minX || 4096;
						const height = maxY - minY || 4096;
						
						// Create SVG with comments
						let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="${minX} ${minY} ${width} ${height}" width="${width}" height="${height}">
`;
						
						// Add dimension comments to groups
						const groups = svgPaths.match(/<g[^>]*>[\s\S]*?<\/g>/g) || [];
						groups.forEach(group => {
							const groupIdMatch = group.match(/id="([^"]+)"/);
							if (groupIdMatch) {
								const groupId = groupIdMatch[1];
								// Find matching dimension text
								for (const [text, measurement] of Object.entries(dimensionData)) {
									if (groupId.includes('patch')) {
										svgContent += `  <!-- Dimension: ${text} | Measurement: ${measurement} | Group Id: ${groupId} -->\n`;
										break;
				}
								}
							}
							svgContent += `  ${group}\n`;
						});
						
						svgContent += '</svg>';
						
						// Create download
						const blob = new Blob([svgContent], { type: 'image/svg+xml' });
						const url = URL.createObjectURL(blob);
						const link = document.createElement('a');
						link.href = url;
						link.download = file.name.replace(/\.dxf$/i, '.svg');
						link.click();
						URL.revokeObjectURL(url);
						
						resolve({ file: file.name, success: true });
					} catch (error) {
						console.error(`Error processing ${file.name}:`, error);
						reject({ file: file.name, error: error.message });
					}
				};
				reader.onerror = () => reject({ file: file.name, error: 'Failed to read file' });
				reader.readAsText(file);
			});
		}

		// Batch process DXF files
		const batchDxfInput = document.getElementById('batch-dxf-files') as HTMLInputElement;
		if (batchDxfInput) {
			batchDxfInput.addEventListener('change', async (e) => {
				const target = e.target as HTMLInputElement;
				const files = Array.from(target.files || []);
				if (files.length === 0) return;
				
				const statusDiv = document.getElementById('dxf-processing-status');
				statusDiv.style.display = 'block';
				statusDiv.textContent = `Processing ${files.length} file(s)...`;
				
				// Wait for DXF parser to load if needed
				if (!DxfParser) {
					statusDiv.textContent = 'Loading DXF parser...';
					try {
						await loadDxfParser();
					} catch (error) {
						statusDiv.textContent = `Error: ${error.message}. Please check your internet connection and try again.`;
						statusDiv.style.color = '#ff0000';
						return;
					}
				}
				
				const results = [];
				for (let i = 0; i < files.length; i++) {
					const file = files[i];
					statusDiv.textContent = `Processing ${i + 1}/${files.length}: ${file.name}...`;
					
					try {
						const result = await processDXFFile(file);
						results.push(result);
					} catch (error) {
						results.push({ file: file.name, success: false, error: error.message || error });
					}
				}
				
				const successCount = results.filter(r => r.success).length;
				statusDiv.textContent = `Complete! ${successCount}/${files.length} files processed successfully.`;
				statusDiv.style.color = successCount === files.length ? '#007700' : '#ff0000';
				
				// Reset file input after a delay
				setTimeout(() => {
					target.value = '';
					statusDiv.style.display = 'none';
				}, 3000);
			});
		}
	</script>
</html>
