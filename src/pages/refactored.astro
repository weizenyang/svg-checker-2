---
import UpdateValuesModal from "../components/UpdateValuesModal.astro";
import Tutorial from "../components/Tutorial.astro";
import "../styles.css";
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Astro</title>
	</head>
	<body class="">
		<div class="drag-drop-prompt">
			<div class="animated-border">
				<h1>Drag and Drop Here</h1>
			</div>
		</div>
		<UpdateValuesModal />
		<main class="toolsets" style="display: flex">
			<div class="toolset-section">
				<a
					href="/"
					class="flex w-fit border-2 pl-2 pr-2 p-1 mb-2 text-center rounded-md content-center hover:bg-neutral-100"
				>
					<div class="align-center content-center">
						<svg
							xmlns="http://www.w3.org/2000/svg"
							fill="none"
							viewBox="0 0 24 24"
							stroke-width="1.5"
							stroke="currentColor"
							class="size-5"
						>
							<path
								stroke-linecap="round"
								stroke-linejoin="round"
								d="m2.25 12 8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h8.25"
							></path>
						</svg>
					</div>

					<p class="ml-2">Home</p>
				</a>
				<section class="container">
					<input
						class="dropdown"
						id="custom-formatting"
						name="formatting"
						type="checkbox"
						style="display: none"
					/>
					<label for="custom-formatting"
						>Custom SVG ID Formatting <span class="arrow">^</span
						></label
					>

					<div class="toggle">
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								id="underscore"
								value="underscore"
							/>Underscore on Last Identifier (NHXX-XX<b>_</b>XX)
						</div>

						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="dash"
								id="dash"
							/>Dash on Last Identifier (NHXX-XX<b>-</b>XX)
						</div>
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="none"
								id="none"
								checked="checked"
							/>None
						</div>
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="fullUnderscore"
								id="fullUnderscore"
							/>Full Underscore
						</div>
					</div>
				</section>

				<section class="container">
					<!-- <h3>2. Then, Import Files here</h3> -->
					<!-- <button class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300" class="button-style">Import </button> -->
					<label for="myFile" class="button-style"
						>Import <svg
							xmlns="http://www.w3.org/2000/svg"
							width="24"
							height="24"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							strokeLinecap="round"
							strokeLinejoin="round"
							multiple
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="17 8 12 3 7 8" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="3"
								y2="15"
								stroke-width="2"></line>
						</svg></label
					>
					<input
						type="file"
						class="input-style"
						id="myFile"
						name="filename"
						style="display:none; "
					/>
					<label
						for="updateValues"
						class="flex bg-[#ffffff] hover:bg-[#dddddd] items-center justify-center border border-neutral-700 rounded-[4px] p-0.5 mt-1.5 text-sm text-[#333333] align-center cursor-pointer"
						>Update Names
						<svg
							class="ml-1"
							xmlns="http://www.w3.org/2000/svg"
							width="16"
							height="16"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							strokeLinecap="round"
							strokeLinejoin="round"
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="17 8 12 3 7 8" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="3"
								y2="15"
								stroke-width="2"></line>
						</svg></label
					>
					<input
						type="file"
						class="input-style"
						id="updateValues"
						name="filename"
						accept="text/csv"
						style="display:none"
					/>
				</section>

				<section class="container">
					<div
						class="sub-item"
						style="display: flex; flex-direction: column; margin-bottom: 10px;"
					>
						<p class="w-full text-xs m-0 p-0">Edit Points:</p>
						<div
							class="grid grid-cols-2 button-gap gap-1 flex-start"
							id="edit-options"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="flip-x"
							>
								Flip X</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="flip-y"
							>
								Flip Y</button
							>
						</div>
						<p class="w-full text-xs m-0 mt-2 p-0">Model:</p>
						<div
							class="grid grid-cols-3 button-gap gap-1 flex-start"
							id="model-edit-options"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="model-flip-x"
							>
								Flip X</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="model-flip-y"
							>
								Flip Y</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="model-flip-z"
							>
								Flip Z</button
							>
						</div>
						<p class="w-full text-xs m-0 mt-2 p-0">Edit Canvas:</p>
						<div
							class="grid grid-cols-2 button-gap gap-1 flex-start"
							id="canvas-edit-options"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="canvas-flip-x"
							>
								Canvas Flip X</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="canvas-flip-y"
							>
								Canvas Flip Y</button
							>
							<button
								id="reset-flip"
								class="w-full flex mb-0.5 text-xs p-1 cursor-pointer rounded bg-gray-100 hover:bg-gray-300 opacity-50 col-span-2 hidden"
								>Reset Flip</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="canvas-rotate-left"
							>
								Rotate Left</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="canvas-rotate-right"
							>
								Rotate Right</button
							>
							<button
								id="reset-rotation"
								class="w-full flex mb-0.5 text-xs p-1 cursor-pointer rounded bg-gray-100 hover:bg-gray-300 opacity-50 col-span-2 hidden"
								>Reset Rotation</button
							>
						</div>

					</div>

					<div
						class="sub-item hidden"
						id="show-floors"
						style="display: flex; flex-direction: column; margin-bottom: 10px;"
					>
						<p style="padding: 0 0px 10px 0em; margin: 0px;">
							Floors:
						</p>
					</div>

					<div
						class="sub-item"
						style="display: flex; flex-direction: column; margin-bottom: 10px;"
					>
						<input
							id="group"
							type="text"
							placeholder="Group"
							style="margin-bottom: 10px;"
							class="input-style"
						/>

						<input
							id="unit"
							type="text"
							placeholder="Unit"
							class="input-style"
						/>
						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="set-name">Set</button
							>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="set-unit">Apply Units</button
							>
						</div>
					</div>

					<div
						class="sub-item"
						style="display: flex; flex-direction: column;"
					>
						<p style="padding: 0 0px 10px 0em; margin: 0px;">
							Point Properties:
						</p>
						<input
							id="item-id"
							type="text"
							placeholder="ID"
							style="margin-top: 10px;"
							class="input-style"
						/>

						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="set-id">Set</button
							>
						</div>
						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="add-point">Add Point</button
							>
						</div>
						<div
							class="button-gap"
							style="display: flex; margin-top: 10px;"
						>
							<button
								class="w-full flex m-0 text-xs p-1 cursor-pointer rounded bg-white hover:bg-gray-300"
								id="delete-point">Delete</button
							>
						</div>
					</div>
				</section>

				<section class="container">
					<input
						type="text"
						placeholder="File Name"
						class="input-style"
						id="export-file-name"
						style="margin-bottom: 10px"
					/>

					<button
						id="export"
						class="button-style"
						style="margin-bottom: 10px"
					>
						Export SVG
						<svg
							xmlns="http://www.w3.org/2000/svg"
							width="24"
							height="24"
							viewBox="0 0 24 24"
							fill="none"
							stroke="currentColor"
							strokeLinecap="round"
							strokeLinejoin="round"
						>
							<path
								d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"
								stroke-width="2"></path>
							<polyline points="7 10 12 15 17 10" stroke-width="2"
							></polyline>
							<line
								x1="12"
								x2="12"
								y1="15"
								y2="3"
								stroke-width="2"></line>
						</svg></button
					>
					<div class="">
						<input
							type="checkbox"
							id="yx-flip"
							name="yx-flip"
							value="true"
							checked
						/>
						<label for="yx-flip"> Y/X Flip</label>
					</div>

					<button
						id="export-csv-layer"
						class="button-style"
						style="margin-bottom: 10px"
						>Export CSV <span style="margin-left: 8px" class="boxed"
							>4096px</span
						>
					</button>
					<button id="export-csv-layer-2048" class="button-style"
						>Export CSV <span style="margin-left: 8px" class="boxed"
							>2048px</span
						></button
					>
				</section>

				<Tutorial x="some data" id="tutorial" />

				<div class="container" id="id-container">
					<div class="id-list-title-container">
						<p
							class="id-list-title"
							style="padding: 0em 0em; font-weight: bold;"
						>
							CTRL + F to look for items
						</p>
						<p class="hide-toggle" id="hide-toggle">^</p>
					</div>
					<ul style="padding-left: 1em;" class="id-list" id="id-list">
					</ul>
				</div>
			</div>
		</main>

		<section class="container editor grid">
			<div id="image-list-container" class="hidden flex-col">
				<input
					type="text"
					placeholder="To Remove"
					id="text-replacement"
				/>
				<label
					for="check-floorplans-button"
					class="flex align-center text-center bg-neutral-100 hover:bg-neutral-300 p-1 pl-2 pr-2 rounded-sm text-sm self-end"
				>
					Check Floorplans
				</label>
				<input
					type="file"
					class="input-style"
					id="check-floorplans-button"
					accept="image/jpeg, image/png, image/webp"
					name="filename"
					multiple
					style="display:none; "
				/>
				<button id="clear-images"
        class="flex align-center text-center bg-neutral-100 hover:bg-neutral-300 p-1 pl-2 pr-2 rounded-sm text-sm self-end"
        type="button">
  Clear Images
</button>
				<div
					id="image-carousel-container"
					class="hidden flex-col p-2 bg-neutral-100 rounded-sm"
				>
					<p class="text-sm mb-2">Image List</p>
					<ul
						class="flex flex-row max-h-20 w-full space-x-2 overflow-x-scroll overflow-y-hidden"
						id="image-list-carousel"
					>
					</ul>
				</div>
			</div>

			<div
				id="editor-button-container"
				style="display: flex; flex-direction: row; justify-content: space-between;"
			>
				<h3>Viewer</h3>
			</div>
			<div
				class="aspect-square max-h-[91vh] max-w-[91vh]"
				id="scalable-canvas"
			>
				<div class="output" id="svg-container">
					<p
						style="padding: 2em; background-color: #00000022; border-radius: 3px; margin: 0px;"
					>
						Import SVG file
					</p>
				</div>
			</div>

			<div class="space-y-4" id="tag">
				<h3 id="label">-</h3>
			</div>
			<svg id="svg" height="0px"></svg>
		</section>
	</body>

	<script>
		// import { onMount } from 'astro/client';
		// import * as svgOp from "./svg-scripts/svg-operations"
		import { transform } from "typescript";
		import {
			currentValuesList,
			updateValuesList,
			updateValuesModal,
			circlesToSpawn,
		} from "../store.js";
		enum format {
			underscore,
			dash,
			none,
			fullUnderscore,
		}

		var flipped = false;
		var canvasFlipX = false;
		var canvasFlipY = false;
		var canvasRotate = 0;
		var multiSelect = false;
		var clusterId = [];
		var canvasScale = 1;

		var idFormat = format.none; //SVG ID format
		var mouseDown = false;
		var globalSvgContainer = document.getElementById("svg-container");
		var mouseInContainer = false;
		var tempSelected;
		var flipYX = true;

		let prevMouseX = 0;
		let prevMouseY = 0;

		let rightMouseDown = false;
		let anchorPoint = { x: 0, y: 0 };
		let typing = false;

		let globalFloors = [];
		let globalFloorsAggregated = [];
		let aggregatePoints = false;
		let checkboxesId = [];

		//Multiple SVGs
		var importedSVGs = [];
		var currentSVGIndex = 0;

		//3d objectID
		var object3dCount = 0;

		var formattingButtons = document.querySelectorAll(".formatting");
		formattingButtons.forEach((e) => {
			e.addEventListener("change", (event) =>
				setFormat(event.target.value),
			);
		});

		function setFormat(data) {
			if (data == "underscore") {
				idFormat = format.underscore;
			} else if (data == "dash") {
				idFormat = format.dash;
			} else if (data == "none") {
				idFormat = format.none;
			} else if (data == "fullUnderscore") {
				idFormat = format.fullUnderscore;
			}
		}

		//Attribute Editor
		var groupGlobal = [];

		var fileNameGlobal = "";
		var svg = document.getElementById("svg"); // get the SVG element
		var mouseRect = svg.createSVGRect(); // create a rectangle for the mouse position
		var currentSelected = null;

		// "Show the dialog" button opens the dialog modally

		//New code to interface with SVG
		document
			.getElementById("export-file-name")
			.addEventListener("input", (e) => {
				fileNameGlobal = e.target.value;
				console.log(fileNameGlobal);
			});

		//Check if SVG Container is active
		document
			.getElementById("svg-container")
			.addEventListener("mouseover", (e) => {
				//Set global var MouseInContainer
				mouseInContainer = true;
			});

		document
			.getElementById("svg-container")
			.addEventListener("mouseout", (e) => {
				//Set global var MouseInContainer
				mouseInContainer = false;
			});

		var createNewSVG = () => {
			// Create new SVG if it's not present
			const newSVG = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"svg",
			);
			newSVG.style.width = "100%";
			newSVG.style.height = "100%";
			newSVG.setAttribute("viewBox", "0 0 4096 4096");
			newSVG.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");

			return newSVG;
		};

		const scalableCanvas = document.getElementById("scalable-canvas");
		const svgContainer = document.getElementById("svg-container");

		// Initialize variables for panning
		let isPanning = false;
		let startX, startY;
		let translateX = 0,
			translateY = 0;

		// Handle zooming with the mouse wheel
		scalableCanvas.addEventListener("wheel", (e) => {
			e.preventDefault(); // Prevent default scrolling behavior

			// Get the current scale value or default to 1
			let scale =
				parseFloat(
					svgContainer.style.transform.match(/scale\(([^)]+)\)/)?.[1],
				) || 1;

			// Adjust scale based on wheel delta
			scale -= e.deltaY / 1000; // Scale up for scroll up, down for scroll down

			// Clamp the scale value
			scale = Math.max(1, Math.min(scale, 10)); // Min scale: 0.1, Max scale: 10

			canvasScale = scale;

			// Apply updated scale
			if (scale > 1.2) {
				svgContainer.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
			} else {
				translateX = 0;
				translateY = 0;
				svgContainer.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
			}

			console.log(`Updated scale: ${scale}`);
		});

		// Handle panning
		scalableCanvas.addEventListener("mousedown", (e) => {
			isPanning = true;
			startX = e.clientX - translateX;
			startY = e.clientY - translateY;
			scalableCanvas.style.cursor = "grabbing"; // Change cursor to grabbing
		});

		scalableCanvas.addEventListener("mousemove", (e) => {
			if (!isPanning || tempSelected != null) return;

			// Calculate new translate values
			let newTranslateX = e.clientX - startX;
			let newTranslateY = e.clientY - startY;

			// Dynamically calculate boundaries based on canvas and container sizes
			const canvasRect = scalableCanvas.getBoundingClientRect();
			const svgRect = svgContainer.getBoundingClientRect();

			const scale =
				parseFloat(
					svgContainer.style.transform.match(/scale\(([^)]+)\)/)?.[1],
				) || 1;

			const boundary = {
				minX: Math.min(
					0,
					canvasRect.width - svgRect.width * 0.5 * scale,
				),
				maxX: Math.max(
					0,
					-(canvasRect.width - svgRect.width * 0.5 * scale),
				),
				minY: Math.min(
					0,
					canvasRect.height - svgRect.height * 0.5 * scale,
				),
				maxY: Math.max(
					0,
					-(canvasRect.height - svgRect.height * 0.5 * scale),
				),
			};

			// console.log(boundary)

			// Apply boundaries
			translateX = Math.max(
				boundary.minX,
				Math.min(boundary.maxX, newTranslateX),
			);
			translateY = Math.max(
				boundary.minY,
				Math.min(boundary.maxY, newTranslateY),
			);

			// Apply updated translation
			svgContainer.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;

			// console.log(`Panning: translateX=${translateX}, translateY=${translateY}`);
		});

		scalableCanvas.addEventListener("mouseup", () => {
			isPanning = false;
			scalableCanvas.style.cursor = "default"; // Reset cursor
		});

		scalableCanvas.addEventListener("mouseleave", () => {
			isPanning = false; // Stop panning if the mouse leaves the canvas
		});

		// helper – add one element to the multiselect lists (no duplicates)
		function addToSelection(el) {
		if (!el || el.nodeName.toLowerCase() === 'svg') return;        // ignore root SVG
			if (!el.classList.contains('svg-tool-selected')) {             // not already in set
				el.classList.add('svg-tool-selected');
				el.style.fill = '#ff0000';
				groupGlobal.push(el);
			}
		}

		// track the primary button
		let primaryMouseIsDown = false;
		document.addEventListener('mousedown', e => {
		if (e.button === 0) primaryMouseIsDown = true;
		});
		document.addEventListener('mouseup',   e => {
		if (e.button === 0) primaryMouseIsDown = false;
		});

		document.getElementById('svg-container')
		.addEventListener('mousemove', e => {
			if (!primaryMouseIsDown || !e.shiftKey) return;              // nothing to do

			const target = e.target;                                     // element under cursor
			const parentIsG = target.parentNode?.nodeName.toLowerCase() === 'g';
			const valid     = parentIsG || target.nodeName.toLowerCase() === 'circle';

			if (valid) addToSelection(target);
		});


		document
			.getElementById("svg-container")
			.addEventListener("mouseover", (e) => {
				if (
					e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
					e.srcElement.nodeName.toLowerCase() == "svg" ||
					e.srcElement.parentNode.nodeName.toLowerCase() == "g" ||
					!e.srcElement.tagName == "image"
				) {
					if (currentSelected != null) {
						currentSelected.classList.remove("hovered");
						if (
							!currentSelected.classList.contains(
								"svg-tool-selected",
							)
						) {
							currentSelected.style.fill = "";
						} else {
							currentSelected.style.fill = "#ff0000";
						}
					}
					document.getElementById("tag").style.display = "flex";
					document.getElementById("label").innerHTML = "";
					var label = document.createElement("div");
					if (e.srcElement.id) {
						var idLabel = document.createElement("p");
						idLabel.innerText = `ID: ${e.srcElement.id}`;
						idLabel.style.color = "#007700";
						idLabel.style.marginTop = "10px";
						idLabel.style.marginBottom = "10px";
						label.appendChild(idLabel);
					}

					if (e.srcElement.getAttribute("class")) {
						var classLabel = document.createElement("p");
						var tempClassList = Object.assign(
							{},
							e.srcElement.classList,
						);
						tempClassList = Object.keys(tempClassList).filter(
							(item) =>
								tempClassList[item] !== "svg-tool-selected",
						);
						if (tempClassList.length > 0) {
							var tempString = "";
							tempClassList.forEach((classname) => {
								if (tempString == "") {
									tempString = classname;
								} else {
									tempString += " " + classname;
								}
							});
							classLabel.innerText = `Class: ${tempClassList}`;
							classLabel.style.marginTop = "10px";
							classLabel.style.marginBottom = "10px";
						}

						label.appendChild(classLabel);
					}

					if (e.target.getAttribute("data-floor")) {
						var floorLabel = document.createElement("p");
						floorLabel.innerText = `Floor: ${e.srcElement.getAttribute("data-floor")}`;
						floorLabel.style.color = "#007700";
						floorLabel.style.marginTop = "10px";
						floorLabel.style.marginBottom = "10px";
						label.appendChild(floorLabel);
					}

					document.getElementById("label").append(label);
					currentSelected = e.srcElement;
					e.srcElement.classList.add("hovered");
				} else {
					document.getElementById("tag").style.display = "none";
					mouseInContainer = false;
					// console.log(e.srcElement.parentNode.nodeName);
				}

				document.querySelectorAll(".hovered").forEach((e) => {
					e.style.fill = "#ff000066";
				});
			});

		document.getElementById("yx-flip").addEventListener("change", (e) => {
			flipYX = e.target.checked;
		});

		document
			.getElementById("svg-container")
			.addEventListener("mousedown", (e) => {
				spawnLabel();
				if (
					e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
					e.srcElement.nodeName.toLowerCase() == "svg" ||
					e.srcElement.parentNode.nodeName.toLowerCase() == "g"
				) {
					if (mouseInContainer) {
						if (e.button === 0) {
							// Left mouse button
							mouseDown = true;
						} else if (e.button === 1) {
							// Right mouse button
							rightMouseDown = true;
							prevMouseX = e.clientX;
							prevMouseY = e.clientY;
							// Calculate the anchor point for scaling
							anchorPoint =
								calculateBoundingBoxCenter(groupGlobal);
						}
					}
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;
					// if (currentSelected != null) {
					// 	currentSelected.classList.add("hovered");
					// }
					document.getElementById("tag").style.display = "flex";
					document.getElementById("label").innerText =
						e.srcElement.id;
					currentSelected = e.srcElement;

					const groupName = e.srcElement;
					//Get Attributes
					if (!multiSelect) {
						groupGlobal = [];
						document
							.querySelectorAll(".svg-tool-selected")
							.forEach((e) => {
								// console.log(e.classList)
								e.classList.remove("svg-tool-selected");
								// console.log(e.classList)
								e.style.fill = "";
							});

						groupGlobal.push(groupName);
						console.log(groupGlobal);
					} else {
						if (
							!groupName.classList.contains("hovered") &&
							groupName.classList.contains("svg-tool-selected")
						) {
							groupGlobal.push(groupName);
						} else if (groupGlobal.length <= 1) {
							groupGlobal.push(groupName);
						}
						console.log(groupGlobal);
					}

					if (groupGlobal.length < 2) {
						if (
							groupGlobal[0].getAttribute("group-attribute") != ""
						) {
							document.getElementById("group").value =
								groupGlobal[0].getAttribute("group-attribute");
						} else {
							document.getElementById("group").value = "";
						}

						if (
							groupGlobal[0].getAttribute("unit-attribute") != ""
						) {
							document.getElementById("unit").value =
								groupGlobal[0].getAttribute("unit-attribute");
						} else {
							document.getElementById("unit").placeholder =
								"No Attribute";
							document.getElementById("unit").value = "";
						}

						if (groupGlobal[0].getAttribute("id") != "") {
							document.getElementById("item-id").value =
								groupGlobal[0].getAttribute("id");
						} else {
							document.getElementById("item-id").placeholder =
								"No Attribute";
							document.getElementById("item-id").value = "";
						}
					} else {
						document.getElementById("group").placeholder = "Group";
						document.getElementById("unit").placeholder = "Unit";
						document.getElementById("item-id").placeholder = "ID";
					}
					e.srcElement.classList.add("svg-tool-selected");

					// e.srcElement.style.fill = "#ff000055";
				} else {
					document.getElementById("tag").style.display = "none";
				}

				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.style.fill = "#ff0000";
				});
			});

		document.getElementById("set-name").addEventListener("click", (e) => {
			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				if (
					document.querySelectorAll(".svg-tool-selected").length < 2
				) {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.setAttribute(
						"unit-attribute",
						document.getElementById("unit").value,
					);
					if (
						e.hasAttribute("group-attribute") &&
						e.hasAttribute("unit-attribute")
					) {
						e.id =
							e.getAttribute("group-attribute") +
							"_" +
							e.getAttribute("unit-attribute");
					}
				} else {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.id =
						e.getAttribute("group-attribute") +
						"_" +
						e.getAttribute("unit-attribute");
				}
			});
		});

		document
			.getElementById("delete-point")
			.addEventListener("click", (e) => {
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.remove();
				});
			});

		document.getElementById("set-id").addEventListener("click", (e) => {
			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				if (
					document.querySelectorAll(".svg-tool-selected").length < 2
				) {
					e.setAttribute(
						"id",
						document.getElementById("item-id").value,
					);
				} else {
					e.setAttribute(
						"id",
						document.getElementById("item-id").value,
					);
				}
			});
		});

		document.getElementById("set-unit").addEventListener("click", (e) => {
			setUnit();
		});

		//Tag
		document.addEventListener("mousemove", (e) => {
			document.getElementById("tag").style.left = `${e.x}px`;
			document.getElementById("tag").style.top = `${e.y}px`;
			document.getElementById("tag").style.transform =
				`translate(0%, 150%)`;
		});

		var fileInput = document.getElementById("myFile");
		var type = "";
		fileInput.addEventListener("click", (e) => {
			fileInput.value = null;
		});

		function calculateSensitivity(svgElement) {
			const svgRect = svgElement.getBoundingClientRect(); // Get the on-screen size of the SVG
			// const svgRect = document.getElementById("scalable-canvas").getBoundingClientRect();
			const viewBox = svgElement.viewBox.baseVal; // Get the SVG's viewBox dimensions

			const scaleX = viewBox.width / svgRect.width;
			const scaleY = viewBox.height / svgRect.height;

			return { scaleX, scaleY };
		}

		function calculateLabelOffset(svgElement) {
			// const svgRect = svgElement.getBoundingClientRect(); // Get the on-screen size of the SVG
			const svgRect = document
				.getElementById("scalable-canvas")
				.getBoundingClientRect();
			const viewBox = svgElement.viewBox.baseVal; // Get the SVG's viewBox dimensions

			const scaleX = viewBox.width / svgRect.width;
			const scaleY = viewBox.height / svgRect.height;

			return { scaleX, scaleY };
		}

		function calculateBoundingBoxCenter(elements) {
			if (elements.length === 0) return { x: 0, y: 0 };

			let minX = Infinity,
				maxX = -Infinity,
				minY = Infinity,
				maxY = -Infinity;

			elements.forEach((element) => {
				const cx = parseFloat(element.getAttribute("cx"));
				const cy = parseFloat(element.getAttribute("cy"));

				if (cx < minX) minX = cx;
				if (cx > maxX) maxX = cx;
				if (cy < minY) minY = cy;
				if (cy > maxY) maxY = cy;
			});

			return {
				x: (minX + maxX) / 2,
				y: (minY + maxY) / 2,
			};
		}

		// Tag and mouse move event listener
		document.addEventListener("mousemove", (e) => {
			// Update Tags
			const tag = document.getElementById("tag");
			tag.style.left = `${e.x}px`;
			tag.style.top = `${e.y}px`;
			tag.style.transform = `translate(0%, -40px)`;

			if (mouseDown && mouseInContainer) {
				spawnLabel();
				const svgElement = globalSvgContainer.querySelector("svg");
				if (svgElement != null) {
					// Calculate sensitivity based on SVG resolution and size
					const { scaleX, scaleY } = calculateSensitivity(svgElement);

					// Calculate mouse movement difference once
					const deltaX = (e.clientX - prevMouseX) * scaleX;
					const deltaY = (e.clientY - prevMouseY) * scaleY;

					// Update previous mouse position once
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;

					// Move a single selected item
					if (
						tempSelected != null &&
						!multiSelect &&
						groupGlobal.length < 2
					) {
						console.log("Moving single item");
						moveElement(tempSelected, deltaX, deltaY);
					}
					// Move multiple selected items
					else if (multiSelect && groupGlobal.length > 0) {
						console.log("Moving all items");
						groupGlobal.forEach((item) =>
							moveElement(item, deltaX, deltaY),
						);
					}

					// console.log("Mouse Down + Move");
				}
			} else if (rightMouseDown && mouseInContainer) {
				const svgElement = globalSvgContainer.querySelector("svg");
				if (svgElement != null) {
					// Calculate sensitivity based on SVG resolution and size
					const { scaleX, scaleY } = calculateSensitivity(svgElement);

					// Calculate mouse movement difference
					const movementX = (e.clientX - prevMouseX) * scaleX;
					const movementY = (e.clientY - prevMouseY) * scaleY;

					// Use horizontal movement for scaling factor
					const scaleFactor = 1 + movementX * 0.01; // Adjust sensitivity here

					// Update previous mouse position
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;

					// Scale all selected items
					groupGlobal.forEach((item) =>
						scaleElement(item, scaleFactor, anchorPoint),
					);

					console.log("Scaling all items");
				}
			}
		});

		//Move SVG with CX and CY
		document.addEventListener("mousedown", (e) => {
			spawnLabel();
			if (mouseInContainer && tempSelected != null) {
				if (e.button === 0) {
					// Left mouse button
					mouseDown = true;
				} else if (e.button === 2) {
					// Right mouse button
					rightMouseDown = true;
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;
					// Calculate the anchor point for scaling
					anchorPoint = calculateBoundingBoxCenter(groupGlobal);
				}
			}

			//Checks if it's a primitive element, otherwise put in a null,
			//If TempSelected is not cleared, it will get wrongfully selected and moved during MouseDown
			if (e.srcElement.parentNode.nodeName.toLowerCase() == "g") {
				tempSelected = e.srcElement;
				console.log("tempSelected");
				console.log(tempSelected);
			} else {
				tempSelected = null;
			}

			if (
				e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
				e.srcElement.nodeName.toLowerCase() == "svg" ||
				e.srcElement.parentNode.nodeName.toLowerCase() == "g"
			) {
				console.log(e.srcElement.parentNode);
				// if (currentSelected != null) {
				// 	currentSelected.classList.add("hovered");
				// }
				document.getElementById("tag").style.display = "flex";
				document.getElementById("tag").classList.add("leading-loose");
				document.getElementById("label").innerText = e.srcElement.id;
				currentSelected = e.srcElement;

				const groupName = e.srcElement;
				//Get Attributes
				if (!multiSelect) {
					groupGlobal = [];
					document
						.querySelectorAll(".svg-tool-selected")
						.forEach((e) => {
							// console.log(e.classList)
							e.classList.remove("svg-tool-selected");
							// console.log(e.classList)
							e.style.fill = "";
						});
					groupGlobal.push(groupName);
				} else {
					if (!groupGlobal.includes(groupName)) {
						groupGlobal.push(groupName);
					}
				}

				if (groupGlobal.length < 2) {
					if (groupGlobal[0].getAttribute("group-attribute") != "") {
						document.getElementById("group").value =
							groupGlobal[0].getAttribute("group-attribute");
					} else {
						document.getElementById("group").value = "";
					}

					if (groupGlobal[0].getAttribute("unit-attribute") != "") {
						document.getElementById("unit").value =
							groupGlobal[0].getAttribute("unit-attribute");
					} else {
						document.getElementById("unit").placeholder =
							"No Attribute";
						document.getElementById("unit").value = "";
					}
				} else {
					document.getElementById("group").placeholder = "-";
					document.getElementById("unit").placeholder = "-";
				}
				e.srcElement.classList.add("svg-tool-selected");

				// e.srcElement.style.fill = "#ff000055";
			} else {
				document.getElementById("tag").style.display = "none";
			}

			document.querySelectorAll(".selected").forEach((e) => {
				e.style.fill = "#ff0000";
			});
		});

		document.addEventListener("mouseup", spawnLabel);

		function moveElement(element, deltaX, deltaY) {
			if (
				element.getAttribute("cx") != null &&
				element.getAttribute("cy") != null
			) {
				const currentCx = parseFloat(element.getAttribute("cx"));
				const currentCy = parseFloat(element.getAttribute("cy"));

				const newCx = currentCx + deltaX;
				const newCy = currentCy + deltaY;

				element.setAttribute("cx", newCx);
				element.setAttribute("cy", newCy);
			}
		}

		function scaleElement(element, scaleFactor, anchor) {
			if (
				element.getAttribute("cx") != null &&
				element.getAttribute("cy") != null
			) {
				const currentCx = parseFloat(element.getAttribute("cx"));
				const currentCy = parseFloat(element.getAttribute("cy"));

				const newCx = anchor.x + (currentCx - anchor.x) * scaleFactor;
				const newCy = anchor.y + (currentCy - anchor.y) * scaleFactor;

				element.setAttribute("cx", newCx);
				element.setAttribute("cy", newCy);
			}
		}

		document.addEventListener("mouseup", (e) => {
			tempSelected = null;
			mouseDown = false;
			rightMouseDown = false;
		});

		document.getElementById("add-point").addEventListener("click", (e) => {
			svg = document.getElementById("svg");
			const layers = Array.from(svg.children);

			// Find the layer with the most circle elements
			let maxCircleCount = 0;
			let layerWithMostCircles = null;

			layers.forEach((layer) => {
				const circleCount = layer.querySelectorAll("circle").length;

				if (circleCount > maxCircleCount) {
					maxCircleCount = circleCount;
					layerWithMostCircles = layer;
				}
			});

			if (document.getElementById("item-id").value.length > 0) {
				console.log(document.getElementById("item-id").value);
				const values = document
					.getElementById("item-id")
					.value.split(",");
				values.map((e, i) => {
					console.log(e);
					const circle = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"circle",
					);
					circle.setAttribute("cx", `${30 * i}`);
					circle.setAttribute("cy", "30");
					circle.setAttribute("r", "30");
					circle.setAttribute("id", e);
					if (layerWithMostCircles) {
						layerWithMostCircles.appendChild(circle);
						console.log(layerWithMostCircles);
					} else {
						try {
							if (
								globalSvgContainer
									.querySelector("svg")
									.querySelector("g")
							) {
								globalSvgContainer
									.querySelector("svg")
									.querySelector("g")
									.appendChild(circle);
							} else {
								let svgInstance =
									globalSvgContainer.querySelector("svg");

								const gElement = document.createElementNS(
									"http://www.w3.org/2000/svg",
									"g",
								);
								gElement.appendChild(circle);
								svgInstance.appendChild(gElement);
							}
						} catch (e) {
							console.log(globalSvgContainer);
							let svgInstance =
								globalSvgContainer.querySelector("svg");

							if (!svgInstance) {
								svgInstance = createNewSVG();
								globalSvgContainer.appendChild(svgInstance);
							}

							const gElement = document.createElementNS(
								"http://www.w3.org/2000/svg",
								"g",
							);
							gElement.appendChild(circle);
							svgInstance.appendChild(gElement);
						}
					}
				});
				labelToggle();
			} else {
				alert("Please add a name for the point");
			}
		});

		function spawnCircle(id, cx, cy, data) {
			const g = globalSvgContainer.querySelector("g");
			const circle = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"circle",
			);
			circle.setAttribute("id", id);
			circle.setAttribute("cx", cx);
			circle.setAttribute("cy", cy);
			circle.setAttribute("r", "30");
			data.forEach((e) => {
				circle.setAttribute(e.field, e.value);
			});
			g.appendChild(circle);

			return circle;
		}

		//Listen to the UpdateValeusModal for circle spawn updates
		circlesToSpawn.listen((circles) => {
			console.log("New Circles!");
			const spacing = 2000 / circles.length;
			circles.map((e, id) => {
				console.log(circles);
				spawnCircle(e, id * spacing + 40, 70, []);
			});
			spawnLabel();
		});

		//Scale from center / scale from bounding box
		const scaleBoundingBoxToFitInstance = (svgElement, elArray) => {
			const circles = elArray;
			if (circles.length === 0) return;

			let minX = Infinity,
				maxX = -Infinity,
				minY = Infinity,
				maxY = -Infinity;

			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));
				const r = parseFloat(circle.getAttribute("r"));

				if (cx - r < minX) minX = cx - r;
				if (cx + r > maxX) maxX = cx + r;
				if (cy - r < minY) minY = cy - r;
				if (cy + r > maxY) maxY = cy + r;
			});

			const bboxWidth = maxX - minX;
			const bboxHeight = maxY - minY;

			const viewBox = svgElement.viewBox.baseVal;
			const svgWidth = viewBox.width;
			const svgHeight = viewBox.height;

			const margin = 0.2; // 1/5 margin

			const maxAllowedWidth = svgWidth * (1 - margin);
			const maxAllowedHeight = svgHeight * (1 - margin);

			const widthScale = maxAllowedWidth / bboxWidth;
			const heightScale = maxAllowedHeight / bboxHeight;

			const scale = Math.min(widthScale, heightScale, 1); // Scale down if necessary

			// Calculate the offset to center the scaled bounding box
			const offsetX = (svgWidth - bboxWidth * scale) / 2 - minX * scale;
			const offsetY = (svgHeight - bboxHeight * scale) / 2 - minY * scale;

			// Apply scaling and translation to each circle
			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));

				const newCx = cx * scale + offsetX;
				const newCy = cy * scale + offsetY;

				circle.setAttribute("cx", newCx.toFixed(4));
				circle.setAttribute("cy", newCy.toFixed(4));
				circle.setAttribute("r", 30);
			});

			spawnLabel();
		};

		// function startListeningForServerChanges() {
		// 	const eventSource = new EventSource('http://localhost:9234/events');

		// 	eventSource.onmessage = (event) => {
		// 		console.log('Server data changed:', event.data);
		// 		fetchDataFromServer(); // Call your function to fetch updated data
		// 	};

		// 	eventSource.onerror = (error) => {
		// 		console.error('EventSource error:', error);
		// 		eventSource.close(); // Optional: Close the connection on error
		// 	};
		// }

		async function fetchDataFromServer() {
			try {
				// Fetch the image data
				const imageResponse = await fetch(
					"http://localhost:9234/image",
				);
				if (!imageResponse.ok) throw new Error("Failed to fetch image");
				const { image, imageName } = await imageResponse.json();
				console.log({ image, imageName });

				// Convert the image buffer to a Blob
				const imageBlob = new Blob([new Uint8Array(image.data)], {
					type: "image/webp",
				}); // Update type if necessary
				const imageFile = new File([imageBlob], imageName, {
					type: "image/webp",
				});

				// Pass the image File object to handleFileChange
				handleFileChange(imageFile);
			} catch (error) {
				console.error("Error fetching image data from server:", error);
			}

			try {
				// Fetch the CSV data
				const csvResponse = await fetch("http://localhost:9234/csv");
				if (!csvResponse.ok) throw new Error("Failed to fetch CSV");
				const { csv, csvName } = await csvResponse.json();
				console.log({ csv, csvName });

				// Convert the CSV buffer to a Blob
				const csvBlob = new Blob([new Uint8Array(csv.data)], {
					type: "text/csv",
				});
				const csvFile = new File([csvBlob], csvName, {
					type: "text/csv",
				});

				// Pass the CSV File object to handleFileChange
				handleFileChange(csvFile);
			} catch (error) {
				console.error("Error fetching CSV data from server:", error);
			}
		}

		fetchDataFromServer();

		function spawnSVGNavigation() {
			// Check if navigation already exists and remove if needed
			let navContainer = document.getElementById("svg-nav");
			if (!navContainer) {
				navContainer = document.createElement("div");
				navContainer.id = "svg-nav";
				// Style the container as desired (here we center the arrows)
				navContainer.style.display = "flex";
				navContainer.style.justifyContent = "center";
				navContainer.style.marginTop = "1em";

				// Create left arrow button
				const leftArrow = document.createElement("button");
				leftArrow.id = "svg-prev";
				leftArrow.innerHTML = "&#8592;"; // left arrow symbol
				leftArrow.style.marginRight = "1em";

				// Create right arrow button
				const rightArrow = document.createElement("button");
				rightArrow.id = "svg-next";
				rightArrow.innerHTML = "&#8594;"; // right arrow symbol

				// Append the buttons to the nav container
				navContainer.appendChild(leftArrow);
				navContainer.appendChild(rightArrow);

				// Append the nav container to the document, e.g. just below your svg-container
				const svgContainer = document.getElementById("svg-container");
				svgContainer.parentNode.insertBefore(
					navContainer,
					svgContainer.nextSibling,
				);

				// Add event listeners to change the current SVG
				leftArrow.addEventListener("click", () => {
					if (currentSVGIndex > 0) {
						currentSVGIndex--;
						processSVG(importedSVGs[currentSVGIndex].element);
					}
				});
				rightArrow.addEventListener("click", () => {
					if (currentSVGIndex < importedSVGs.length - 1) {
						currentSVGIndex++;
						processSVG(importedSVGs[currentSVGIndex].element);
					}
				});
			}
		}

		const processSVG = (svgElement) => {
			const list = svgElement.querySelectorAll(`[id]`);
			svgElement.setAttribute("data-csv-editor", "svg");
			document.getElementById("id-list").innerHTML = "";

			const processIdList = (idFormat) => {
				const regexLastUnderscore = /_(?=[^_]*$)/g;
				const regexLastDash = /-(?=[^-]*$)/g;
				const regexDashUnderscore = /\w+-\w+_\w+/;
				const regexText = /^[^-]*/;
				const regexGroupName = /^([A-Z]{2}\d{2}-\d{1,2})/;
				const regexUnitNumber = /(\d{1,3})\D*$/;

				const handleId = (currentId) => {
					const listItem = document.createElement("li");

					const regexResult =
						idFormat === format.fullUnderscore
							? currentId.replaceAll("-", "_")
							: !regexDashUnderscore.test(currentId)
								? currentId.replace(regexLastDash, "_")
								: currentId;

					const selected = svgElement.getElementById(`${currentId}`);
					const groupMatched = selected.id.match(regexGroupName);
					const unitMatched = selected.id.match(regexUnitNumber);

					if (groupMatched) {
						selected.setAttribute(
							"group-attribute",
							groupMatched[1],
						);
					}

					if (unitMatched) {
						selected.setAttribute("unit-attribute", unitMatched[1]);
					}

					selected.id = regexResult;
					listItem.innerHTML = regexResult;
					clusterId.push({
						id: object3dCount,
						clusterId: regexText.exec(regexResult)[0],
						unitId: regexResult,
					});

					object3dCount++;
					listItem.style.listStyle = "none";
					listItem.style.padding = "0.5em 0em";
					document.getElementById("id-list").append(listItem);
				};

				list.forEach((i) => {
					const currentId = i.id;

					if (idFormat === format.underscore) {
						handleId(currentId);
					} else if (idFormat === format.dash) {
						handleId(
							regexDashUnderscore.test(currentId)
								? currentId.replace(regexLastUnderscore, "-")
								: currentId,
						);
					} else if (
						idFormat === format.none ||
						idFormat === format.fullUnderscore
					) {
						handleId(currentId);
					}
				});
			};

			processIdList(idFormat);

			// Append the SVG element to the div element
			const svgContainer = document.getElementById("svg-container");
			svgContainer.innerHTML = "";
			svgElement.setAttributeNS(null, "width", "100%");
			svgElement.setAttributeNS(null, "height", "100%");
			svgContainer.appendChild(svgElement);

			console.log(imageList.length)

			if (imageList.length > 0) {
					previewBackplate(
						document
							.getElementById("svg-container")
							.querySelector("svg"),
					)
			}

			// Set type for export filename
			type =
				idFormat === format.underscore
					? "underscore"
					: idFormat === format.dash
						? "dash"
						: "";
		};

		function getBaseName(fileName) {
			return fileName.replace(/\.[^/.]+$/, "").toLowerCase();
		}

		function handleDraggedImages(files) {
			const imageFiles = Array.from(files).filter((file) =>
				file.type.startsWith("image/"),
			);
			if (imageFiles.length === 0) return;

			imageFiles.forEach((imageFile) => {
				const reader = new FileReader();
				reader.onload = (event) => {
					const contents = event.target.result;
					console.log("Image File")
					console.log(imageFile.name)
					const imageBaseName = getBaseName(imageFile.name);
					console.log(getBaseName(imageFile.name))
					console.log(importedSVGs)
					// Loop through the imported SVG objects to find a matching name
					importedSVGs.forEach((svgObj) => {
						console.log("SVGOBJ")
						console.log(svgObj)
						const svgBaseName = getBaseName(svgObj.name);
						if (svgBaseName === imageBaseName) {
							console.log(svgBaseName)
							console.log(imageBaseName)
							const svgElement = svgObj.element;
							// Create an <image> element for the SVG
							const svgImage = document.createElementNS(
								"http://www.w3.org/2000/svg",
								"image",
							);
							const viewBox = svgElement
								.getAttribute("viewBox")
								.split(" ");
							svgImage.setAttributeNS(null, "href", contents);
							svgImage.setAttributeNS(null, "x", "0");
							svgImage.setAttributeNS(null, "y", "0");
							svgImage.setAttributeNS(null, "width", viewBox[2]);
							svgImage.setAttributeNS(null, "height", viewBox[3]);
							// Insert the image as the first child (or adjust position as needed)
							svgElement.insertBefore(svgImage, svgElement.firstChild);
						}
					});
				};
				reader.readAsDataURL(imageFile);
			});
		}

		function handleFileChange(files) {
			console.log(files);
			flipped = false;
			object3dCount = 0;
			globalFloors = [];
			globalFloorsAggregated = [];
			canvasFlipX = false;
			canvasFlipY = false;
			canvasRotate = 0;
			const file = files[0];
			// if(!document.getElementById("image-list-container").classList.contains("hidden")){
			// 	document.getElementById("image-list-container").classList.add("hidden")
			// }

			// if (files.length === 1) {
			// 	importedSVGs = [];
			// 	currentSVGIndex = 0;
			// 	globalSvgContainer.innerHTML = "";
			// }
			// importedSVGs = []; // Reset the array
			let filesToProcess = Array.from(files).filter(
				(file) => file.type === "image/svg+xml",
			);

			// if (filesToProcess.length === 0) {
			// 	alert("Please import valid SVG files.");
			// 	return;
			// }

			updateResetButtons();

			//Refresh show floors section
			const floorSection = document.getElementById("show-floors");
			floorSection.querySelectorAll("div").forEach((e) => {
				e.remove();
			});
			if (!floorSection.classList.contains("hidden")) {
				floorSection.classList.add("hidden");
			}

			if (document.getElementById("showLabelsDiv")) {
				document.getElementById("showLabelsDiv").remove();
			}
			console.log(files.length)
			if(files.length > 1){
				
				if (file.type === "image/svg+xml") {
					if(document.getElementById("image-list-container").classList.contains("hidden")){
						document.getElementById("image-list-container").classList.remove("hidden")
					}
				Array.from(files).forEach((fileToProcess, index) => {
					const reader = new FileReader();
					reader.onload = () => {
						const svgString = reader.result;
						const parser = new DOMParser();
						const svgDoc = parser.parseFromString(
							svgString,
							"image/svg+xml",
						);
						// For each file, we assume the root element is the SVG element
						const svgElement = svgDoc.documentElement;
						importedSVGs.push({ name: getBaseName(fileToProcess.name), element: svgElement });

						// Once all files have been processed, show the first one and spawn navigation
						if (importedSVGs.length === filesToProcess.length) {
							currentSVGIndex = 0;
							processSVG(importedSVGs[currentSVGIndex].element);
							if (importedSVGs.length > 1) {
								spawnSVGNavigation();
							} else {
								// Remove navigation if only one SVG is imported
								const existingNav =
									document.getElementById("svg-nav");
								if (existingNav) existingNav.remove();
							}
						}
					};
					reader.readAsText(fileToProcess);
				});
			} else if (
				file.type === "image/jpeg" ||
				file.type === "image/png" ||
				file.type === "image/webp"
			) {
				handleDraggedImages(files)
			} else if (file.type === "text/csv") {
			}
			} else {
				if (file.type === "image/svg+xml") {
					if(document.getElementById("image-list-container").classList.contains("hidden")){
						document.getElementById("image-list-container").classList.remove("hidden")
					}
					    importedSVGs = [];
					currentSVGIndex = 0;
					globalSvgContainer.innerHTML = "";

				filesToProcess.forEach((fileToProcess, index) => {
					const reader = new FileReader();
					reader.onload = () => {
						const svgString = reader.result;
						const parser = new DOMParser();
						const svgDoc = parser.parseFromString(
							svgString,
							"image/svg+xml",
						);
						// For each file, we assume the root element is the SVG element
						const svgElement = svgDoc.documentElement;
						importedSVGs.push({ name: getBaseName(file.name), element: svgElement });

						// Once all files have been processed, show the first one and spawn navigation
						if (importedSVGs.length === filesToProcess.length) {
							currentSVGIndex = 0;
							processSVG(importedSVGs[currentSVGIndex].element);
							if (importedSVGs.length > 1) {
								spawnSVGNavigation();
							} else {
								// Remove navigation if only one SVG is imported
								const existingNav =
									document.getElementById("svg-nav");
								if (existingNav) existingNav.remove();
							}
						}
					};
					reader.readAsText(fileToProcess);
				});
			} else if (
				file.type === "image/jpeg" ||
				file.type === "image/png" ||
				file.type === "image/webp"
			) {
				fileNameGlobal = file.name;
				document.getElementById("export-file-name").value =
					fileNameGlobal;
				const reader = new FileReader();
				reader.onload = (event) => {
					const contents = event.target.result;
					// const img = document.createElement("img");
					// img.src = contents;
					// img.style.maxHeight = "100%";
					// img.style.maxWidth = "100%";
					// img.style.borderRadius = "5px"
					const svgContainer =
						document.getElementById("svg-container");
					var internalSVG = svgContainer.querySelector(
						"svg[data-csv-editor='svg']",
					);

					if (!internalSVG) {
						svgContainer.innerHTML = "";
						const newSVG = createNewSVG();
						svgContainer.appendChild(newSVG);
						internalSVG = newSVG;
					}

					const svgImage = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"image",
					);
					const svgViewbox = internalSVG
						.getAttribute("viewBox")
						.split(" ");
					svgImage.setAttributeNS(null, "href", contents);
					svgImage.setAttributeNS(null, "x", "0");
					svgImage.setAttributeNS(null, "y", "0");
					svgImage.setAttributeNS(null, "width", svgViewbox[2]);
					svgImage.setAttributeNS(null, "height", svgViewbox[3]);

					internalSVG.insertBefore(svgImage, internalSVG.firstChild);
				};
				reader.readAsDataURL(file);
			} else if (file.type === "text/csv") {
				if (
					document
						.getElementById("svg-container")
						.getElementsByTagName("p").length > 0
				) {
					Array.from(
						document
							.getElementById("svg-container")
							.getElementsByTagName("p"),
					).forEach((e) => {
						e.remove();
					});
				}

				fileNameGlobal = file.name.replace("camera", "floorplan");

				document.getElementById("export-file-name").value =
					fileNameGlobal;
				const reader = new FileReader();
				reader.onload = (event) => {
					const contents = event.target.result;
					const lines = contents.trim().split("\n");

					// Check the number of columns and decide to transform
					const firstLineFields = lines[0].split(",");
					let transformedLines = lines;
					let scaleToFit = false;
					//column > 3
					if (firstLineFields.length > 3) {
						// Transform the data if more than three columns
						transformedLines = lines.map((line) => {
							const fields = line.split(",");

							const [name, x, y, z] = fields;
							const cleanedName = `${name.split("_")[0]}~${name.split("_")[1]}`; //Curly line for easier text separation
							scaleToFit = true;

							return `${cleanedName},${-y},${-x},${name}`; // Swap x and y
						});
					}

					var gInstance = document.createElementNS(
						"http://www.w3.org/2000/svg",
						"g",
					); //Create group to contain all points
					gInstance.setAttribute("id", "g-instance");
					const svgContainer =
						document.getElementById("svg-container");

					if (svgContainer.querySelector("svg")) {
						//If SVG already exists
						svgContainer
							.querySelector("svg")
							.querySelectorAll("g")
							.forEach((g) => {
								if (g.id !== "Reference") {
									g.remove();
									console.log(g);
									console.log("^ removed");
								}
							});
					} else {
						const newSVG = createNewSVG();
						newSVG.appendChild(gInstance);
						svgContainer.appendChild(newSVG);

						if (svgContainer.querySelector("img")) {
							const tempImage = svgContainer.querySelector("img");
							const svgimg = document.createElementNS(
								"http://www.w3.org/2000/svg",
								"image",
							);
							svgimg.style.width = "100%";
							svgimg.style.height = "100%";
							svgimg.setAttributeNS(
								"http://www.w3.org/1999/xlink",
								"xlink:href",
								tempImage.src,
							);
							newSVG.append(svgimg);
							tempImage.remove();
						}
					}

					svgContainer.querySelector("svg").appendChild(gInstance); //Add g into the svg

					//Floors
					for (let i = 0; i < transformedLines.length; i++) {
						const fields = transformedLines[i].split(",");

						if (Number(fields[1]) || Number(fields[2])) {
							const floor = fields[0].includes("~")
								? fields[0].split("~")[0]
								: null;
							const name = fields[0].includes("~")
								? fields[0].split("~")[1]
								: fields[0];

							const data = [];
							if (floor) {
								const floorData = {
									field: "data-floor",
									value: floor,
								};
								data.push(floorData);
							}

							const fullName = {
								// Custom attribute to be used as unique identifier for functions
								field: "data-fullname",
								value: fields[3],
							};
							data.push(fullName);

							globalFloors.push({
								floor: floor,
								circle: spawnCircle(
									name,
									Number(fields[flipYX ? 2 : 1]).toFixed(4),
									Number(fields[flipYX ? 1 : 2]).toFixed(4),
									data,
								),
							});
						} else {
							console.error(
								`${
									fields[0]
										? fields[0]
										: `(Nameless), Row ${i + 1}`
								} does not contain any cx, cy data`,
							);
						}
					}

					//Floor section
					//Dynamically add Floors section
					var floorNumbers = [];
					const labelDivInstance =
						document.getElementById("labelDiv");
					if (labelDivInstance) {
						labelDivInstance.remove();
					}
					globalFloors.forEach((e) => {
						if (!floorNumbers.includes(e.floor)) {
							floorNumbers.push(e.floor);
						}
					});

					console.log(floorNumbers);
					console.log(globalFloors);

					if (floorNumbers.length > 0) {
						const floorSection =
							document.getElementById("show-floors");
						if (floorSection.classList.contains("hidden")) {
							floorSection.classList.remove("hidden");
						}

						checkboxesId = [];

						floorNumbers.forEach((e) => {
							const div = document.createElement("div");
							const checkbox = document.createElement("input");
							const label = document.createElement("label");

							label.innerText = `Floor ${e}`;
							label.htmlFor = `floor-${e}-checkbox`;
							checkbox.type = "checkbox";
							checkbox.checked = true;
							checkbox.id = `floor-${e}-checkbox`;

							checkboxesId.push(`floor-${e}-checkbox`);
							div.appendChild(checkbox);
							div.appendChild(label);

							checkbox.addEventListener("change", (e) => {
								toggleFloors(aggregatePoints);
								spawnLabel();
							});

							floorSection.appendChild(div);
						});
					}

					//globalFloorsAggregated contains average positioned circle of multicamera points
					const globalFloorsCopy = Object.assign(globalFloors);
					globalFloorsAggregated =
						getAveragedCircles(globalFloorsCopy);

					if (document.getElementById("aggregate-points-parent")) {
						document
							.getElementById("aggregate-points-parent")
							.remove();
					}
					const editOptions = document.getElementById("edit-options");
					const div = document.createElement("div");
					div.id = "aggregate-points-parent";
					const aggregateOptionsCheckbox =
						document.createElement("input");
					const label = document.createElement("label");
					div.classList.add("col-span-2");
					div.classList.add("mt-2");
					label.innerText = `Aggregate points`;
					label.classList.add("ml-1");
					label.htmlFor = `aggregate-points`;
					aggregateOptionsCheckbox.type = "checkbox";
					aggregateOptionsCheckbox.checked = false;
					aggregateOptionsCheckbox.id = `aggregate-points`;
					div.appendChild(aggregateOptionsCheckbox);
					div.appendChild(label);
					editOptions.appendChild(div);

					aggregateOptionsCheckbox.addEventListener("change", (e) => {
						aggregatePoints = e.target.checked;
						toggleFloors(aggregatePoints);
						spawnLabel();
					});

					// Scale bounding box to fit within the SVG frame
					if (scaleToFit) {
						const globalCircle = globalFloors.map(
							(item) => item.circle,
						);
						const globalAggregateCircle =
							globalFloorsAggregated.map((item) => item.circle);
						const totalCircles = [
							...globalCircle,
							...globalAggregateCircle,
						];
						scaleBoundingBoxToFitInstance(
							svgContainer.querySelector("svg"),
							totalCircles,
						);
					}
					// scaleBoundingBoxToFit(svgContainer.querySelector("svg"));
				};
				reader.readAsText(file);

				labelToggle();

				//Lord will spite me for this method
				setTimeout((e) => {
					spawnLabel();
				}, 50);
			}
			}


		}

		function labelToggle() {
			if (!document.getElementById("showLabelsDiv")) {
				//Add Toggle Label Checkbox
				const showLabelsDiv = document.createElement("div");
				showLabelsDiv.id = "showLabelsDiv";
				const showLabelsToggle = document.createElement("input");
				const showLabelsLabel = document.createElement("label");
				showLabelsLabel.textContent = "Toggle Labels";
				showLabelsLabel.setAttribute("for", "showLabelsToggle");

				showLabelsToggle.type = "checkbox";
				showLabelsToggle.style.padding = "0.5em";
				showLabelsToggle.style.height = "fit-content";
				showLabelsToggle.id = "showLabelsToggle";

				showLabelsDiv.appendChild(showLabelsToggle);
				showLabelsDiv.appendChild(showLabelsLabel);
				document
					.getElementById("editor-button-container")
					.appendChild(showLabelsDiv);

				showLabelsToggle.addEventListener("change", (e) => {
					if (e.target.checked) {
						spawnLabel();
					} else {
						killLabels();
					}
				});

				showLabelsToggle.checked = true;
			}
		}

		const imageList = [];
		document.getElementById("check-floorplans-button").addEventListener("change", (e) => {
			console.log("Change") 
			uploadImages(e)
		});

		document.getElementById("clear-images").addEventListener("click", () => {
			// 1. empty the array that the previewer uses
			imageList.splice(0, imageList.length);

			// 2. remove thumbnails
			const carousel = document.getElementById("image-list-carousel");
			if (carousel) carousel.innerHTML = "";

			// 3. hide the image-list UI if it's open
			const imgListContainer = document.getElementById("image-carousel-container");
			if (imgListContainer && imgListContainer.classList.contains("flex")) {
				imgListContainer.classList.remove("flex");
				imgListContainer.classList.add("hidden");
			}

			// 4. hide the floating previewer if it exists
			const previewer = document.getElementById("image-previewer-container");
			if (previewer) previewer.style.display = "none";
			
		});


		function uploadImages(e) {
			const files = Array.from(e.target.files);

			const readFile = (file) => {
				return new Promise((resolve, reject) => {
					const reader = new FileReader();
					reader.onload = (data) =>
						resolve({ name: file.name, data: data.target.result });
					reader.onerror = (error) => reject(error);
					reader.readAsDataURL(file);
				});
			};

			if (
				document
					.getElementById("image-carousel-container")
					.classList.contains("hidden")
			) {
				document
					.getElementById("image-carousel-container")
					.classList.remove("hidden");
				document
					.getElementById("image-carousel-container")
					.classList.add("flex");
			}

			Promise.all(Array.from(files).map(readFile))
				.then((results) => {
					imageList.splice(0, imageList.length);
					imageList.push(...results);
					const imageListCarousel = document.getElementById(
						"image-list-carousel",
					);
					imageListCarousel.innerHTML = "";
					imageList.forEach((image) => {
						const listItem = document.createElement("li");
						listItem.style.height = "100%";
						const imageElement = document.createElement("img");
						imageElement.src = image.data;
						imageElement.style.height = "60px";
						// imageElement.setAttribute("data-name", image.name)
						listItem.appendChild(imageElement);
						imageListCarousel.appendChild(listItem);
					});
					previewBackplate(
						document
							.getElementById("svg-container")
							.querySelector("svg"),
					);
				})
				.catch((error) =>
					console.error("Error loading images:", error),
				);
		}

		function previewBackplate(parentSVG) {
			const listeners = [];
			listeners.forEach((e) => {
				removeEventListener("hover", e);
			});

			let previewerInstance = document.getElementById("image-previewer");
			console.log("previewing")
			if (!previewerInstance) {
				const newPreviewer = document.createElement("div");
				const previewerImg = document.createElement("img");
				const previewerText = document.createElement("p");
				newPreviewer.id = "image-previewer-container";
				newPreviewer.style.padding = "5px";
				newPreviewer.style.position = "fixed";
				newPreviewer.style.display = "flex";
				newPreviewer.style.flexDirection = "flex-column";
				newPreviewer.style.backgroundColor = "#cccccccc";
				newPreviewer.style.borderRadius = "10px";
				newPreviewer.style.alignContent = "align-center";
				newPreviewer.style.justifyContent = "justify-center";
				newPreviewer.style.justifyItems = "justify-center";
				newPreviewer.style.transform = "translate(-50%, -113%)";
				newPreviewer.style.width = "310px";
				previewerImg.id = "image-previewer-image";
				previewerImg.style.width = "300px";
				previewerImg.style.marginBottom = "10px";
				newPreviewer.appendChild(previewerImg);
				previewerText.id = "image-previewer-text";
				previewerText.style.fontSize = "12px";
				newPreviewer.appendChild(previewerText);
				document.querySelector("body").appendChild(newPreviewer);
			}

			parentSVG.querySelectorAll("path").forEach((path) => {
				const listener = path.addEventListener("mouseover", (e) => {
					document.getElementById(
						"image-previewer-container",
					).style.display = "block";
					const textReplacement = document.getElementById("text-replacement").value;
					console.log(textReplacement);
					console.log(e.target.id
								.split("_")
								.join("")
								.split("-")
								.join("")
								.replace(textReplacement, ""),);
					const selectedImage = imageList.filter((image) => {
						return image.name
							.split("_")
							.join("")
							.split("-")
							.join("")
							.includes(
								e.target.id
									.split("_")
									.join("")
									.split("-")
									.join("")
									.replace(textReplacement, ""),
							);
					})[0];

					console.log(selectedImage)

					if (selectedImage) {
						// console.log(selectedImage)
						document.getElementById("image-previewer-image").src =
							selectedImage.data;
						document.getElementById(
							"image-previewer-text",
						).innerHTML = selectedImage.name;
					} else {
						document.getElementById("image-previewer-image").src =
							"";
						document.getElementById(
							"image-previewer-text",
						).innerHTML = "";
					}
				});

				const listener2 = path.addEventListener("mouseout", (e) => {
					document.getElementById(
						"image-previewer-container",
					).style.display = "none";
				});

				listeners.push(listener);
				listeners.push(listener2);
			});
			globalSvgContainer.addEventListener("mousemove", (e) => {
				document.getElementById(
					"image-previewer-container",
				).style.left = `${e.clientX}px`;
				document.getElementById("image-previewer-container").style.top =
					`${e.clientY}px`;
			});
		}

		fileInput.addEventListener("change", () => {
			handleFileChange(fileInput.files[0]);
		});

		document
			.getElementById("updateValues")
			.addEventListener("click", (e) => {
				updateValuesList.set([]);
				currentValuesList.set([]);
				updateValuesModal.set(false);
				console.log("UpdateValues clicked");
			});

		document
			.getElementById("updateValues")
			.addEventListener("change", () => {
				updateValues(document.getElementById("updateValues").files[0]);
			});

		var animationTimeout;
		document.body.addEventListener("dragover", (e) => {
			event.preventDefault(); // Prevent the default behavior
			document.querySelector(".drag-drop-prompt").classList.add("appear");
			if (animationTimeout != null) {
				clearTimeout(animationTimeout);
				animationTimeout = setTimeout((e) => {
					document
						.querySelector(".drag-drop-prompt")
						.classList.remove("appear");
				}, 500);
			} else {
				animationTimeout = setTimeout((e) => {
					document
						.querySelector(".drag-drop-prompt")
						.classList.remove("appear");
				}, 500);
			}
		});

		document.body.addEventListener("dragend", (e) => {
			event.preventDefault(); // Prevent the default behavior
			document
				.querySelector(".drag-drop-prompt")
				.classList.remove("appear");
		});

		document.body.addEventListener("drop", (e) => {
			e.preventDefault();
			console.log(e);
			console.log(e.dataTransfer.files[0]);
			handleFileChange(e.dataTransfer.files);
			document
				.querySelector(".drag-drop-prompt")
				.classList.remove("appear");
		});

		//To check globally if is typing
		document.addEventListener("focusin", (event) => {
			if (
				event.target.tagName === "INPUT" ||
				event.target.tagName === "TEXTAREA"
			) {
				typing = true;
				console.log("Input is active");
			}
		});

		document.addEventListener("focusout", (event) => {
			if (
				event.target.tagName === "INPUT" ||
				event.target.tagName === "TEXTAREA"
			) {
				typing = false;
				console.log("Input is not active");
			}
		});

		document.addEventListener("keydown", (e) => {
			if (e.key == "Escape") {
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.classList.remove("svg-tool-selected");
					e.style.fill = "";
					groupGlobal = [];
					document.querySelectorAll("#group").value = "";
				});

				if (multiSelect) {
					groupGlobal.forEach((e) => {
						e.classList.remove("svg-tool-selected");
						e.style.fill = "";
					});

					multiSelect = false;
				}
			}

			if (
				e.key === "a" &&
				e.ctrlKey &&
				document.activeElement.tagName === "INPUT" &&
				document.activeElement.type === "text"
			) {
				document.activeElement.select();
				console.log(document.activeElement);
			}

			if (e.key == "Shift") {
				multiSelect = true;
			}

			if (e.key == "Enter") {
				document.querySelector("#set-name").click();
			}

			if (e.key == "q") {
				document.querySelector("#set-unit").click();
			}

			if (e.key == "Delete" || e.key === "Backspace") {
				document.querySelector("#delete-point").click();
			}

			if (event.key === "ArrowLeft") {
				if (!typing) {
					rotateCircles(-45);
				}
			} else if (event.key === "ArrowRight") {
				if (!typing) {
					rotateCircles(45);
				}
			}

			if (e.key == "l") {
				console.log(e.key);
				if (document.getElementById("showLabelsToggle")) {
					document.getElementById("showLabelsToggle").click();
				}
			}

			if (e.ctrlKey && e.key === "a") {
				e.preventDefault(); // Prevent the default browser select all behavior

				const svgElement = globalSvgContainer.querySelector("svg");
				if (svgElement != null) {
					// Select all circles in the SVG
					groupGlobal = Array.from(
						svgElement.querySelectorAll("circle"),
					);

					groupGlobal.forEach((e) => {
						e.classList.add("svg-tool-selected");
						e.style.fill = "#ff0000";
					});

					// Indicate multi-selection mode
					multiSelect = true;

					console.log("All circles selected:", groupGlobal);
				}
			}

			if (e.key == "Delete") {
				document.querySelector("delete-point").click();
				spawnLabel();
			}

			spawnLabel();
		});

		window.addEventListener("resize", (e) => {
			spawnLabel();
		});

		function setUnit() {
			for (var i = 0; i < groupGlobal.length; i++) {
				console.log(i);
				groupGlobal[i].setAttribute("unit-attribute", pad(i + 1));
			}

			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				if (
					document.querySelectorAll(".svg-tool-selected").length < 2
				) {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.setAttribute(
						"unit-attribute",
						document.getElementById("unit").value,
					);
					if (
						e.hasAttribute("group-attribute") &&
						e.hasAttribute("unit-attribute")
					) {
						e.id =
							e.getAttribute("group-attribute") +
							"_" +
							e.getAttribute("unit-attribute");
					}
				} else {
					e.setAttribute(
						"group-attribute",
						document.getElementById("group").value,
					);
					e.id =
						e.getAttribute("group-attribute") +
						"_" +
						e.getAttribute("unit-attribute");
				}
			});
		}

		function rotateCircles(angle, customMidpoint = null) {
			const svgElement = document.querySelector("#svg-container svg");
			if (!svgElement) {
				console.error("SVG element not found.");
				return;
			}

			const circles = svgElement.querySelectorAll("circle");
			if (circles.length === 0) {
				console.warn("No circles found in the SVG.");
				return;
			}

			let bboxCenterX, bboxCenterY;

			if (customMidpoint) {
				// Use the custom midpoint
				bboxCenterX = customMidpoint.x;
				bboxCenterY = customMidpoint.y;
			} else {
				// Calculate bounding box midpoint
				let minX = Infinity,
					maxX = -Infinity,
					minY = Infinity,
					maxY = -Infinity;

				circles.forEach((circle) => {
					const cx = parseFloat(circle.getAttribute("cx"));
					const cy = parseFloat(circle.getAttribute("cy"));
					const r = parseFloat(circle.getAttribute("r"));

					if (cx - r < minX) minX = cx - r;
					if (cx + r > maxX) maxX = cx + r;
					if (cy - r < minY) minY = cy - r;
					if (cy + r > maxY) maxY = cy + r;
				});

				bboxCenterX = minX + (maxX - minX) / 2;
				bboxCenterY = minY + (maxY - minY) / 2;
			}

			const radians = (angle * Math.PI) / 180;

			// Rotate each circle around the chosen midpoint
			circles.forEach((circle) => {
				const cx = parseFloat(circle.getAttribute("cx"));
				const cy = parseFloat(circle.getAttribute("cy"));

				const dx = cx - bboxCenterX;
				const dy = cy - bboxCenterY;

				const newCx =
					bboxCenterX +
					dx * Math.cos(radians) -
					dy * Math.sin(radians);
				const newCy =
					bboxCenterY +
					dx * Math.sin(radians) +
					dy * Math.cos(radians);

				circle.setAttribute("cx", newCx.toFixed(4));
				circle.setAttribute("cy", newCy.toFixed(4));
			});

			console.log(
				`Rotated circles around midpoint (${bboxCenterX.toFixed(
					4,
				)}, ${bboxCenterY.toFixed(4)}) by ${angle} degrees.`,
			);
		}

		function getAveragedCircles(data) {
			console.log("data");
			console.log(data);
			const grouped = {};
			data.forEach((item) => {
				const { floor, circle } = item;
				console.log(circle.attributes[1].textContent);
				const idLocal = circle.getAttribute("id");
				const cxLocal = parseFloat(circle.attributes[1].value);
				const cyLocal = parseFloat(circle.attributes[2].value);
				console.log({ floor, circle, cxLocal, cyLocal });

				// Grouping by floor and id
				if (!grouped[floor]) {
					grouped[floor] = {};
				}
				if (!grouped[floor][idLocal]) {
					grouped[floor][idLocal] = {
						totalCx: 0,
						totalCy: 0,
						count: 0,
						idLocal,
					};
				}

				// Summing cx, cy positions
				grouped[floor][idLocal].totalCx += cxLocal;
				grouped[floor][idLocal].totalCy += cyLocal;
				grouped[floor][idLocal].count += 1;
			});

			console.log(grouped);

			const averagedCircles = [];

			for (const floor in grouped) {
				for (const id in grouped[floor]) {
					const { totalCx, totalCy, count } = grouped[floor][id];
					const avgCx = totalCx / count;
					const avgCy = totalCy / count;

					// Clone the original DOM element and update its attributes
					const originalCircle = data.find(
						(item) => item.circle.getAttribute("id") === id,
					).circle;
					const newCircle = originalCircle.cloneNode(true);
					newCircle.setAttribute("cx", avgCx);
					newCircle.setAttribute("cy", avgCy);

					averagedCircles.push({
						floor,
						circle: newCircle,
					});
				}
			}

			return averagedCircles;
		}

		function toggleFloors(aggregated) {
			const globalG = globalSvgContainer.querySelector("g");
			const localFloors = globalFloors;
			const localFloorsAggregated = globalFloorsAggregated;

			checkboxesId.forEach((i) => {
				const floor = i.split("-")[1];
				if (aggregated) {
					console.log(globalFloorsAggregated);
					localFloors.forEach((e) => {
						e.circle.remove();
					});
					const selectedFloorCirclesAggregated =
						localFloorsAggregated.filter((e) =>
							e.floor.includes(floor),
						);

					if (document.getElementById(i).checked) {
						selectedFloorCirclesAggregated.forEach((e) => {
							globalG.appendChild(e.circle);
						});
						console.log({ Added: selectedFloorCirclesAggregated });
					} else {
						selectedFloorCirclesAggregated.forEach((e) => {
							e.circle.remove();
						});
						console.log({
							Removed: selectedFloorCirclesAggregated,
						});
					}
				} else {
					localFloorsAggregated.forEach((e) => {
						e.circle.remove();
					});
					const selectedFloorCircles = localFloors.filter((e) =>
						e.floor.includes(floor),
					);

					if (document.getElementById(i).checked) {
						selectedFloorCircles.forEach((e) => {
							globalG.appendChild(e.circle);
						});
						console.log({ Added: selectedFloorCircles });
					} else {
						selectedFloorCircles.forEach((e) => {
							e.circle.remove();
						});
						console.log({ Removed: selectedFloorCircles });
					}
				}
			});
		}

		//Add zero to single digit
		function pad(d) {
			return d < 10 ? "0" + d.toString() : d.toString();
		}

		document.addEventListener("keydown", (e) => {
			if (e.key == "Escape") {
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					e.classList.remove("svg-tool-selected");
					e.style.fill = "";
					groupGlobal = [];
					document.querySelectorAll("#group").value = "";
				});
			}

			if (e.key == "Shift") {
				multiSelect = true;
			}
		});

		document.addEventListener("keyup", (e) => {
			if (e.key == "Shift") {
				multiSelect = false;
				console.log(multiSelect);
			}
		});

		document
			.getElementById("hide-toggle")
			.addEventListener("click", (e) => {
				if (
					document.getElementById("id-list").style.display == "none"
				) {
					document.getElementById("id-list").style.display = "block";
					document
						.getElementById("hide-toggle")
						.classList.remove("expand");
				} else {
					document.getElementById("id-list").style.display = "none";
					document
						.getElementById("hide-toggle")
						.classList.add("expand");
				}
			});

		// document.getElementById("export-csv").addEventListener("click", (e) => {
		// 	exportCSV();
		// });

		// document.getElementById("remove").addEventListener("click", (e) => {
		// 	removeData();
		// });

		// document
		// 	.getElementById("export-csv-count")
		// 	.addEventListener("click", (e) => {
		// 		exportCSVId();
		// 	});

		document.getElementById("export").addEventListener("click", (e) => {
			exportSVG();
		});

		document
			.getElementById("export-csv-layer")
			.addEventListener("click", (e) => {
				exportFloorNamePosition();
			});

		document
			.getElementById("export-csv-layer-2048")
			.addEventListener("click", (e) => {
				exportFloorNamePosition2048();
			});

		//SVG Conversion
		function exportSVG() {
			const file = fileNameGlobal;
			var svg = document
				.querySelector("#svg-container")
				.querySelector("svg");
			document.querySelectorAll("[id]").forEach((e) => {
				const str = e.getAttribute("id");
				e.setAttribute("data-name", str.replace(/\s+/g, "_"));
			});
			document.querySelectorAll("[group-attribute]").forEach((e) => {
				e.removeAttribute("group-attribute");
			});
			document.querySelectorAll("[unit-attribute]").forEach((e) => {
				e.removeAttribute("unit-attribute");
			});
			if (svg) {
				var serializer = new XMLSerializer();
				var svgString = serializer.serializeToString(svg);
				var blob = new Blob([svgString], { type: "image/svg+xml" });
				var url = URL.createObjectURL(blob);
				var link = document.createElement("a");
				link.href = url;
				link.download =
					file.replace(/\.[^/.]+$/, "") + "_" + type + ".svg";
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			} else {
				alert("Import an SVG to start!");
			}
		}
		//SVG Conversion
		function exportFloorNamePosition() {
			// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
			if (document.querySelector("#svg-container").querySelector("svg")) {
				const parser = new DOMParser();
				var doc = null;
				doc = document
					.querySelector("#svg-container")
					.querySelector("svg");

				const layers = Array.from(doc.querySelectorAll("g"))
					.map((layer, index) => {
						if (
							layer.getAttribute("id") != null ||
							layer.getAttribute("id") != undefined
						) {
							if (
								layer.getAttribute("id").toLowerCase() !=
								"reference"
							) {
								console.log("Layer ID is found");
								const id = layer
									.getAttribute("id")
									.replace("_", "");
								const children = Array.from(layer.children).map(
									(child) => {
										console.log(child);
										const childId = child.getAttribute(
											"data-name",
										)
											? decodeHtml(
													child.getAttribute(
														"data-name",
													),
												)
											: child.getAttribute("id");

										const x = child.getAttribute("cx");
										const y = child.getAttribute("cy");
										return { id: childId, x, y };
									},
								);
								console.log(id, children);
								return { id, children };
							}
						} else {
							console.log("Layer ID is null");
							console.log(layer);
							const id = `item-${index}`;
							const children = Array.from(layer.children).map(
								(child) => {
									console.log(child);
									const childId = child.getAttribute(
										"data-name",
									)
										? decodeHtml(
												child.getAttribute("data-name"),
											)
										: child.getAttribute("id");

									const x = child.getAttribute("cx");
									const y = child.getAttribute("cy");
									return { id: childId, x, y };
								},
							);
							console.log(id, children);
							return { id, children };
						}
					})
					.filter((layer) => layer !== undefined);

				var csv;
				if (layers.length < 2) {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				} else {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				}

				const file = fileNameGlobal;
				var blob = new Blob([csv], { type: "text/csv" });
				var link = document.createElement("a");
				link.href = URL.createObjectURL(blob);
				link.download =
					file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "");
				(".csv");
				link.click();
			} else {
				alert("Import an SVG to start!");
			}
		}

		//SVG Conversion
		function exportFloorNamePosition2048() {
			// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
			if (document.querySelector("#svg-container").querySelector("svg")) {
				const parser = new DOMParser();
				var doc = null;

				doc = document
					.querySelector("#svg-container")
					.querySelector("svg");
				const height = doc.viewBox.baseVal.height;
				const width = doc.viewBox.baseVal.width;

				const layers = Array.from(doc.querySelectorAll("g"))
					.map((layer) => {
						if (
							layer.getAttribute("id").toLowerCase() !=
							"reference"
						) {
							const id = layer
								.getAttribute("id")
								.replace("_", "");
							const children = Array.from(layer.children).map(
								(child) => {
									console.log(child);
									const childId = child.getAttribute(
										"data-name",
									)
										? decodeHtml(
												child.getAttribute("data-name"),
											)
										: child.getAttribute("id");

									const x =
										(child.getAttribute("cx") / width) *
										2048;
									const y =
										(child.getAttribute("cy") / height) *
										2048;
									return { id: childId, x, y };
								},
							);
							console.log(id, children);
							return { id, children };
						}
					})
					.filter((layer) => layer !== undefined);

				var csv;
				if (layers.length < 2) {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				} else {
					if (flipYX) {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.y},${child.x}`,
								),
							)
							.join("\n");
					} else {
						csv = layers
							.flatMap((layer) =>
								layer.children.map(
									(child) =>
										`${layer.id} ${child.id},${child.x},${child.y}`,
								),
							)
							.join("\n");
					}
				}

				console.log(csv);

				const file = fileNameGlobal;
				var blob = new Blob([csv], { type: "text/csv" });
				var link = document.createElement("a");
				link.href = URL.createObjectURL(blob);
				link.download =
					file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "");
				(".csv");
				link.click();
			} else {
				alert("Import an SVG to start!");
			}
		}

		function decodeHtml(html) {
			var txt = document.createElement("textarea");
			txt.innerHTML = html;
			return txt.value;
		}

		//Flip Points only
		function flipPointsX() {
			flipped = !flipped;

			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");
			const width = doc.viewBox.baseVal.width;
			const layers = Array.from(doc.querySelectorAll("g")).map(
				(layer) => {
					// if(layer.getAttribute("id").toLowerCase() != 'reference'){
					// const id = layer.getAttribute("id").replace('_', "");
					const children = Array.from(layer.children).map((child) => {
						if (child.tagName == "image") {
							// child.getAttribute("transform")
							// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
							if (!child.hasAttribute("flipped")) {
								child.setAttribute("flipped", "");
								child.style.transform =
									"scaleX(-1) translate(-100%, 0)";
							} else {
								child.removeAttribute("flipped");
								child.style.transform =
									"scaleX(1) translate(0, 0)";
							}

							console.log(child.style.scale);
						} else {
							const x = child.getAttribute("cx");
							child.setAttribute("cx", width - x);
						}
					});
					// }
				},
			);
			spawnLabel();
		}

		function flipPointsY() {
			// var svg = document.querySelector("#svg-container").querySelector("svg");
			// svg.style.scale = "-1 1"
			flipped = !flipped;

			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");
			const height = doc.viewBox.baseVal.height;
			const layers = Array.from(doc.querySelectorAll("g")).map(
				(layer) => {
					// if(layer.getAttribute("id").toLowerCase() != 'reference'){
					// const id = layer.getAttribute("id").replace('_', "");
					const children = Array.from(layer.children).map((child) => {
						if (child.tagName == "image") {
							// child.getAttribute("transform")
							// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
							if (!child.hasAttribute("flipped")) {
								child.setAttribute("flipped", "");
								child.style.transform =
									"scaleY(-1) translate(0, -100%)";
							} else {
								child.removeAttribute("flipped");
								child.style.transform =
									"scaleX(1) translate(0, 0)";
							}

							console.log(child.style.scale);
						} else {
							const y = child.getAttribute("cy");
							child.setAttribute("cy", height - y);
						}
					});
					// }
				},
			);
			spawnLabel();
		}

		//Flip Models only
		function flipModelsX() {
			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");
			const width = doc.viewBox.baseVal.width;
			
			// Find and flip model elements (paths, polygons, rects, etc.)
			const modelElements = doc.querySelectorAll("path, polygon, rect, ellipse");
			modelElements.forEach((model) => {
				const currentTransform = model.getAttribute("transform") || "";
				const scaleTransform = `scaleX(-1) translate(-${width}, 0)`;
				
				if (currentTransform.includes("scaleX(-1)")) {
					// Remove existing flip
					model.setAttribute("transform", currentTransform.replace(/scaleX\(-1\)[^)]*\)/g, "").trim());
				} else {
					// Add flip transform
					model.setAttribute("transform", `${currentTransform} ${scaleTransform}`.trim());
				}
			});
			spawnLabel();
		}

		function flipModelsY() {
			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");
			const height = doc.viewBox.baseVal.height;
			
			// Find and flip model elements (paths, polygons, rects, etc.)
			const modelElements = doc.querySelectorAll("path, polygon, rect, ellipse");
			modelElements.forEach((model) => {
				const currentTransform = model.getAttribute("transform") || "";
				const scaleTransform = `scaleY(-1) translate(0, -${height})`;
				
				if (currentTransform.includes("scaleY(-1)")) {
					// Remove existing flip
					model.setAttribute("transform", currentTransform.replace(/scaleY\(-1\)[^)]*\)/g, "").trim());
				} else {
					// Add flip transform
					model.setAttribute("transform", `${currentTransform} ${scaleTransform}`.trim());
				}
			});
			spawnLabel();
		}

		function flipModelsZ() {
			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");
			const centerX = doc.viewBox.baseVal.width / 2;
			const centerY = doc.viewBox.baseVal.height / 2;
			
			// Find and flip model elements (simulate Z-axis flip with rotation)
			const modelElements = doc.querySelectorAll("path, polygon, rect, ellipse");
			modelElements.forEach((model) => {
				const currentTransform = model.getAttribute("transform") || "";
				const rotateTransform = `rotate(180, ${centerX}, ${centerY})`;
				
				if (currentTransform.includes("rotate(180")) {
					// Remove existing Z-flip (180-degree rotation)
					model.setAttribute("transform", currentTransform.replace(/rotate\(180[^)]*\)/g, "").trim());
				} else {
					// Add Z-flip transform (180-degree rotation around center)
					model.setAttribute("transform", `${currentTransform} ${rotateTransform}`.trim());
				}
			});
			spawnLabel();
		}

		function transformImages() {
			// Select the SVG element
			var svgElement = document
				.querySelector("#svg-container")
				.querySelector("svg");
			if (!svgElement) {
				console.error(
					`SVG element not found for selector: ${svgElement}`,
				);
				return;
			}

			// Get all <image> elements within the SVG
			const imageNodes = svgElement.querySelectorAll("image");
			if (imageNodes.length === 0) {
				console.warn("No <image> nodes found in the SVG.");
				return;
			}

			// Iterate through each <image> node
			console.log(imageNodes);
			imageNodes.forEach((imageNode) => {
				// Get current attributes for width and x
				const width = parseFloat(imageNode.getAttribute("width")) || 0;
				const height =
					parseFloat(imageNode.getAttribute("height")) || 0;
				const x = parseFloat(imageNode.getAttribute("x")) || 0;
				const y = parseFloat(imageNode.getAttribute("y")) || 0;

				// Calculate the transformation
				const translateX = canvasFlipX ? width : 0;
				const translateY = canvasFlipY ? height : 0;
				const scaleX = canvasFlipX ? -1 : 1;
				const scaleY = canvasFlipY ? -1 : 1;
				const rotate = canvasRotate % 360;

				const transformValue = `translate(${translateX}, ${translateY}) scale(${scaleX}, ${scaleY}) rotate(${rotate}, ${width / 2}, ${height / 2})`;

				// Apply the transformation
				const existingTransform =
					imageNode.getAttribute("transform") || "";
				imageNode.setAttribute("transform", `${transformValue}`.trim());

				console.log(
					`Flipped <image> node with x: ${x}, width: ${width}, y: ${y}, height: ${height}`,
				);
			});
		}

		document
			.getElementById("flip-x")
			.addEventListener("click", flipPointsX);
		document
			.getElementById("flip-y")
			.addEventListener("click", flipPointsY);
		document
			.getElementById("canvas-flip-x")
			.addEventListener("click", () => {
				canvasFlipX = !canvasFlipX;
				console.log(canvasFlipX);
				transformImages();
				flipPointsX();
				updateResetButtons();
			});
		document
			.getElementById("canvas-flip-y")
			.addEventListener("click", () => {
				canvasFlipY = !canvasFlipY;
				console.log(canvasFlipY);
				transformImages();
				flipPointsY();
				updateResetButtons();
			});

		document
			.getElementById("canvas-rotate-left")
			.addEventListener("click", () => {
				canvasRotate -= 90;
				transformImages();
				const svgElement = document
					.querySelector("#svg-container")
					.querySelector("svg");
				const midpoint = {
					x: svgElement.viewBox.baseVal.width / 2,
					y: svgElement.viewBox.baseVal.height / 2,
				};
				rotateCircles(-90, midpoint);
				spawnLabel();
				updateResetButtons();
				// flipPointsX()
			});
		document
			.getElementById("canvas-rotate-right")
			.addEventListener("click", () => {
				canvasRotate += 90;
				transformImages();
				const svgElement = document
					.querySelector("#svg-container")
					.querySelector("svg");
				const midpoint = {
					x: svgElement.viewBox.baseVal.width / 2,
					y: svgElement.viewBox.baseVal.height / 2,
				};
				rotateCircles(90, midpoint);
				spawnLabel();
				updateResetButtons();
				// flipPointsY()
			});

		document
			.getElementById("reset-rotation")
			.addEventListener("click", (e) => {
				const tempCanvasRotation = canvasRotate;
				canvasRotate = 0;
				transformImages();

				const svgElement = document
					.querySelector("#svg-container")
					.querySelector("svg");
				const midpoint = {
					x: svgElement.viewBox.baseVal.width / 2,
					y: svgElement.viewBox.baseVal.height / 2,
				};

				rotateCircles(-tempCanvasRotation, midpoint);
				spawnLabel();
				updateResetButtons();
			});

		document.getElementById("reset-flip").addEventListener("click", (e) => {
			transformImages();
			if (canvasFlipX) {
				flipPointsX();
				canvasFlipX = false;
			}

			if (canvasFlipY) {
				flipPointsY();
				canvasFlipY = false;
			}

			updateResetButtons();
		});

		// Model flip event listeners
		document
			.getElementById("model-flip-x")
			.addEventListener("click", () => {
				flipModelsX();
			});
		document
			.getElementById("model-flip-y")
			.addEventListener("click", () => {
				flipModelsY();
			});
		document
			.getElementById("model-flip-z")
			.addEventListener("click", () => {
				flipModelsZ();
			});

		function updateResetButtons() {
			if (canvasRotate != 0) {
				if (
					document
						.getElementById("reset-rotation")
						.classList.contains("hidden")
				) {
					document
						.getElementById("reset-rotation")
						.classList.remove("hidden");
					document
						.getElementById("reset-rotation")
						.classList.add("flex");
				}
			} else {
				if (
					document
						.getElementById("reset-rotation")
						.classList.contains("flex")
				) {
					document
						.getElementById("reset-rotation")
						.classList.remove("flex");
					document
						.getElementById("reset-rotation")
						.classList.add("hidden");
				}
			}

			if (canvasFlipX || canvasFlipY) {
				if (
					document
						.getElementById("reset-flip")
						.classList.contains("hidden")
				) {
					document
						.getElementById("reset-flip")
						.classList.remove("hidden");
					document.getElementById("reset-flip").classList.add("flex");
				}
			} else if (!canvasFlipX && !canvasFlipY) {
				if (
					document
						.getElementById("reset-flip")
						.classList.contains("flex")
				) {
					document
						.getElementById("reset-flip")
						.classList.remove("flex");
					document
						.getElementById("reset-flip")
						.classList.add("hidden");
				}
			}
		}

		function spawnLabel() {
			killLabels(true);
			if (document.getElementById("showLabelsToggle")) {
				if (document.getElementById("showLabelsToggle").checked) {
					var circles = [];
					const group = globalSvgContainer
						.querySelector("svg")
						.querySelector("g");
					// console.log(
					// 	globalSvgContainer
					// 		.querySelector("svg")
					// 		.querySelector("g"),
					// );
					if (!group) {
					} else if (group instanceof SVGGElement) {
						circles = [].slice.call(
							group.getElementsByTagName("circle"),
						);
					}
					// console.log(circles);

					const svgContainer =
						document.getElementById("svg-container");
					const { scaleX, scaleY } = calculateLabelOffset(
						globalSvgContainer.querySelector("svg"),
					);

					const { width } = globalSvgContainer
						.querySelector("svg")
						.getBoundingClientRect();
					const labelDiv = document.createElement("div");
					labelDiv.setAttribute("id", "labelDiv");
					labelDiv.style.width = "4096px";
					labelDiv.style.height = "4096px";
					// labelDiv.style.width = "100%";
					// labelDiv.style.height = "100%";
					labelDiv.style.position = "absolute";
					labelDiv.style.transform = `scale(${1 / scaleX})`;
					labelDiv.style.left = `-${2048 - 4096 / scaleY / 2}px`;
					labelDiv.style.top = `-${2048 - 4096 / scaleY / 2}px`;
					labelDiv.style.pointerEvents = "none";

					const createParagraph = (
						className,
						text,
						display,
						color = "white",
					) => {
						const p = document.createElement("p");
						Object.assign(p.style, {
							color: color,
							margin: "0px",
							pointerEvents: "none",
							lineHeight: "1.2em",
							display,
						});
						p.className = className;
						p.innerHTML = text; // Changed from textContent to innerHTML to support line breaks
						return p;
					};

					// Helper function to format text with line breaks for more than 3 words
					const formatTextWithLineBreaks = (text) => {
						// Extract room name from pattern like "0_Balcony_1" -> "Balcony"
						// or "0_MasterBedroomBathroom_1" -> "MasterBedroomBathroom"
						let cleanedText = text;
						
						// If the text contains underscores, extract the middle part(s)
						if (text.includes('_')) {
							const parts = text.split('_');
							// Remove first and last parts if they are numbers
							const isFirstPartNumber = /^\d+$/.test(parts[0]);
							const isLastPartNumber = /^\d+$/.test(parts[parts.length - 1]);
							
							if (isFirstPartNumber && isLastPartNumber && parts.length >= 3) {
								// Take everything except first and last part
								cleanedText = parts.slice(1, -1).join('');
							} else if (isFirstPartNumber && parts.length >= 2) {
								// Only remove first part if it's a number
								cleanedText = parts.slice(1).join('');
							}
						}
						
						// Add spaces before capital letters and numbers
						const spacedText = cleanedText
							.replace(/([A-Z0-9])/g, " $1")
							.trim();
						
						const words = spacedText.split(' ').filter(word => word.length > 0);
						if (words.length > 2) {
							// Split roughly in half
							const midPoint = Math.ceil(words.length / 2);
							const firstLine = words.slice(0, midPoint).join(' ');
							const secondLine = words.slice(midPoint).join(' ');
							return `${firstLine}<br>${secondLine}`;
						}
						return spacedText;
					};

					const createDiv = (e) => {
						const div = document.createElement("div");
						div.setAttribute(
							"data-fullname",
							e.getAttribute("data-fullname"),
						);
						Object.assign(div.style, {
							position: "absolute",
							left: `${e.getAttribute("cx")}px`,
							top: `${e.getAttribute("cy")}px`,
							transform: "translate(-50%, -1%)",
							backgroundColor: "rgba(0, 0, 0, 0.5)",
							border: "2px solid rgba(255, 255, 255, 0.1)",
							padding: "4px 24px",
							borderRadius: "0.75rem",
							marginBottom: "0.25rem",
							zIndex: "10",
							backdropFilter: "blur(10px)",
							pointerEvents: "none",
							cursor: "pointer",
							textAlign: "center",
							fontSize: "2.25rem",
						});

						const formattedText = formatTextWithLineBreaks(e.id);
						div.appendChild(
							createParagraph("text-normal", formattedText, "block"),
						);
						div.appendChild(
							createParagraph("text-hover", formattedText, "none"),
						);

						div.onmouseover = () => toggleHover(div, true);
						div.onmouseout = () => toggleHover(div, false);
						return div;
					};

					const createPreviewDiv1 = (e) => {
						const div = document.createElement("div");
						div.setAttribute(
							"data-fullname",
							e.getAttribute("data-fullname"),
						);
						Object.assign(div.style, {
							position: "absolute",
							color: "rgba(0, 0, 0, 255)",
							left: `${e.getAttribute("cx")}px`,
							top: `${e.getAttribute("cy")}px`,
							transform: "translate(-50%, -101%)",
							backgroundColor: "rgba(0, 0, 0, 0)",
							border: "2px solid rgba(0, 0, 0, 1)",
							padding: "4px 24px",
							borderRadius: "0.75rem",
							marginBottom: "0.25rem",
							zIndex: "10",
							pointerEvents: "none",
							cursor: "pointer",
							textAlign: "center",
							fontSize: "2.25rem",
						});

						const formattedText = formatTextWithLineBreaks(e.id);
						div.appendChild(
							createParagraph(
								"text-normal",
								formattedText,
								"block",
								"rgba(0,0,0,0)",
							),
						);
						return div;
					};

					const createPreviewDiv2 = (e) => {
						const div = document.createElement("div");
						div.setAttribute(
							"data-fullname",
							e.getAttribute("data-fullname"),
						);

						const cx = parseFloat(e.getAttribute("cx"));
						const cy = parseFloat(e.getAttribute("cy"));

						// Apply initial styles for measurement
						Object.assign(div.style, {
							position: "absolute",
							visibility: "hidden", // Prevents flickering during measurement
							whiteSpace: "nowrap", // Ensure proper size calculation
							fontSize: "2.25rem", // Match intended font size
							padding: "6px 28px",
						});

						const formattedText = formatTextWithLineBreaks(e.id);
						div.appendChild(
							createParagraph(
								"text-normal",
								formattedText,
								"block",
								"rgba(0,0,0,0)",
							),
						);

						// Append to document for measurement
						document.body.appendChild(div);
						const { width, height } = div.getBoundingClientRect();
						document.body.removeChild(div); // Remove after measuring
						div.querySelectorAll("p").forEach((e) => e.remove());

						// // Calculate the adjusted offsets based on rotation
						// const adjustedLeft = cx - height; // Use height for horizontal adjustment
						// const adjustedTop = cy - width / 2;  // Use width for vertical adjustment

						// Final styles with rotation and alignment
						Object.assign(div.style, {
							position: "absolute",
							color: "rgba(0, 0, 0, 255)",
							left: `${cx}px`,
							top: `${cy - width / 2}px`,
							width: `${height}px`,
							height: `${width}px`,
							// transform: `rotate(90deg)`, // Rotate around the center
							backgroundColor: "rgba(0, 0, 0, 0)",
							border: "2px solid rgba(0, 0, 0, 1)",
							borderRadius: "0.75rem",
							marginBottom: "0.25rem",
							zIndex: "10",
							pointerEvents: "none",
							cursor: "pointer",
							textAlign: "center",
							fontSize: "2.25rem",
							visibility: "visible", // Make visible after measurement
						});

						return div;
					};

					const createPreviewDiv3 = (e) => {
						const div = document.createElement("div");
						div.setAttribute(
							"data-fullname",
							e.getAttribute("data-fullname"),
						);

						const cx = parseFloat(e.getAttribute("cx"));
						const cy = parseFloat(e.getAttribute("cy"));

						// Apply initial styles for measurement
						Object.assign(div.style, {
							position: "absolute",
							visibility: "hidden", // Prevents flickering during measurement
							whiteSpace: "nowrap", // Ensure proper size calculation
							fontSize: "2.25rem", // Match intended font size
							padding: "6px 28px",
						});

						const formattedText = formatTextWithLineBreaks(e.id);
						div.appendChild(
							createParagraph(
								"text-normal",
								formattedText,
								"block",
								"rgba(0,0,0,0)",
							),
						);

						// Append to document for measurement
						document.body.appendChild(div);
						const { width, height } = div.getBoundingClientRect();
						document.body.removeChild(div); // Remove after measuring
						div.querySelectorAll("p").forEach((e) => e.remove());

						// // Calculate the adjusted offsets based on rotation
						// const adjustedLeft = cx - height; // Use height for horizontal adjustment
						// const adjustedTop = cy - width / 2;  // Use width for vertical adjustment

						// Final styles with rotation and alignment
						Object.assign(div.style, {
							position: "absolute",
							color: "rgba(0, 0, 0, 255)",
							left: `${cx - height}px`,
							top: `${cy - width / 2}px`,
							width: `${height}px`,
							height: `${width}px`,
							// transform: `rotate(90deg)`, // Rotate around the center
							backgroundColor: "rgba(0, 0, 0, 0)",
							border: "2px solid rgba(0, 0, 0, 1)",
							borderRadius: "0.75rem",
							marginBottom: "0.25rem",
							zIndex: "10",
							pointerEvents: "none",
							cursor: "pointer",
							textAlign: "center",
							fontSize: "2.25rem",
							visibility: "visible", // Make visible after measurement
						});

						return div;
					};

					const toggleHover = (div, isHovered) => {
						div.style.borderColor = isHovered
							? "rgba(255, 255, 255, 1)"
							: "rgba(255, 255, 255, 0.1)";
						div.querySelector(".text-normal").style.display =
							isHovered ? "none" : "block";
						div.querySelector(".text-hover").style.display =
							isHovered ? "block" : "none";
					};

					circles.forEach((e) => {
						const div = createDiv(e);
						const previewDiv1 = createPreviewDiv1(e);
						const previewDiv2 = createPreviewDiv2(e);
						const previewDiv3 = createPreviewDiv3(e);
						labelDiv.appendChild(div);
						labelDiv.appendChild(previewDiv1);
						labelDiv.appendChild(previewDiv2);
						labelDiv.appendChild(previewDiv3);
						svgContainer.prepend(labelDiv);
					});
				}
			} else {
				console.log("No labels toggle found");
			}
		}

		function killLabels(toggleChecked?) {
			if (document.getElementById("labelDiv")) {
				document.getElementById("labelDiv").remove();
				if (!toggleChecked) {
					document.getElementById("showLabelsToggle").checked = false;
				} else {
					// console.log("toggleChecked true, retaining checked state")
				}
			} else {
				// console.log("labelDiv not found");
			}
		}

		function updateStates(circles, transformedLines, group) {
			if (!group) {
			} else if (group instanceof SVGGElement) {
				console.log("Is group");
				var thisCircles = [].slice.call(
					group.getElementsByTagName("circle"),
				);

				updateValuesModal.set(true);
				console.log("Set updateValuesModal");
				updateValuesList.set(transformedLines);
				currentValuesList.set(thisCircles);
			}
		}

		function updateValues(file) {
			var circles = [];
			const group = globalSvgContainer
				.querySelector("svg")
				.querySelector("g");
			console.log(group);

			const reader = new FileReader();
			reader.onload = (event) => {
				const contents = event.target.result;
				const lines = contents.trim().split("\n");

				// Check the number of columns and decide to transform
				const firstLineFields = lines[0].split(",");
				let transformedLines = lines;

				if (firstLineFields.length > 3) {
					//Camera CSV
					transformedLines = lines.map((line) => {
						const fields = line.split(",");
						const [name, x, y, z] = fields;
						const cleanedName = name.split("_")[1]
							? name.split("_")[1]
							: undefined;
						if (cleanedName) {
							return { name: cleanedName, x: -y, y: -x }; // Swap x and y
						}
					});
					updateStates(circles, transformedLines, group);
				} else {
					//Floorplan CSV
					transformedLines = lines.map((line) => {
						const fields = line.split(",");
						const [name, x, y] = fields;
						const cleanedName = name.split("_")[1]
							? name.split("_")[1]
							: undefined;
						if (cleanedName) {
							return { name: cleanedName, x: x, y: y }; // Swap x and y
						}
					});
					updateStates(circles, transformedLines, group);
				}
				spawnLabel();
			};
			reader.readAsText(file);
		}

		function removeData() {
			const doc = document.querySelector("#svg-container");
			const xml = `<?xml version="1.0" encoding="UTF-8"?>`;
			const defs = doc.querySelector("defs");
			const maskParent = document.querySelector("defs");
			const maskChild = maskParent.children;
			const maskShape = Array.from(maskChild).map((e) => {
				const shape = e.children[0];
				if (shape) {
					if (
						shape.nodeName == "polygon" ||
						shape.nodeName == "path"
					) {
						const className = shape.classList[0];
						shape.classList.remove(className);
						return shape;
					}
				}
			});

			var kvPair = Object.assign(
				{},
				...Array.from(document.styleSheets[1].cssRules).map((e) => {
					// return e.selectorText
					// return e.style.clipPath
					if (e.style.clipPath) {
						var str = e.style.clipPath;
						var regex = /#([\w-]+)/; // \w matches any alphanumeric character
						var match = regex.exec(str); // exec returns an array of matches
						var id = "#" + match[1]; // the first capture group is the ID
						return { [e.selectorText.replace(/[-.]/g, "")]: id };
					}
				}),
			);

			// kvPair = kvPair.filter(element => {
			//     return element !== undefined;
			// })
			var classes = [
				"cls-8158",
				"cls-8167",
				"cls-8163",
				"cls-8166",
				"cls-8165",
			];
			console.log(kvPair);
			const classValues = document
				.getElementById("myClasses")
				.value.replace(/\s/g, "");
			if (classValues) {
				classes = classValues.split(",");
			}

			var units = [];
			if (classes) {
				classes.forEach((e) => {
					doc.querySelectorAll(`.${e}`).forEach((i) => {
						console.log(i);
						const parentClass = String(
							i.parentElement.classList[0],
						);
						const refId = kvPair[parentClass.replace(/[-.]/g, "")];
						console.log(parentClass);
						const refEl = doc
							.querySelector("defs")
							.querySelector(refId);
						var child;
						if (refEl) {
							console.log(refEl);
							child = refEl.children[0];
							child.classList.remove(child.classList[0]);
							child.classList.add(e);
							units.push(child);
							return child;
						}
					});
				});
			}

			console.log("units");
			console.log(units);

			const output = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"g",
			);

			var svg = doc.querySelector("svg");
			console.log(svg);
			while (svg.firstChild) {
				svg.removeChild(svg.firstChild);
			}

			svg.append(defs);
			units.forEach((e) => {
				console.log(e);
				svg.append(e);
			});
		}

		function getStyleSheet(unique_title) {
			for (const sheet of document.styleSheets) {
				if (sheet.title === unique_title) {
					return sheet;
				}
			}
		}
	</script>
</html>
