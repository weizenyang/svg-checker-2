---

---
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>Astro</title>
	</head>
	<body>
		<!--?xml version="1.0" encoding="UTF-8"?-->
		<div>Newer Version Available <a href="/refactored">here</a></div>
		<main class="toolsets" style="display: flex">
			<div class="toolset-section">
				<section class="container">
					<h3>1. Choose your SVG ID Formatting</h3>
					<div class="toggle">
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								id="underscore"
								value="underscore"
							/>Underscore on Last Identifier (NHXX-XX<b>_</b>XX)
						</div>

						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="dash"
								id="dash"
							/>Dash on Last Identifier (NHXX-XX<b>-</b>XX)
						</div>
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="none"
								id="none"
								checked="checked"
							/>None
						</div>
						<div class="sub-item">
							<input
								type="radio"
								name="data-format"
								class="formatting"
								value="fullUnderscore"
								id="fullUnderscore"
							/>Full Underscore
						</div>
					</div>
				</section>

				<section class="container">
					<h3>2. Then, Import Files here</h3>
					<div class="sub-item">
						<label for="myFile">SVG</label>
						<input type="file" id="myFile" name="filename" />
						<label for="myCSVFile">CSV</label>
						<input type="file" id="myCSVFile" name="filename" />
						<label for="myCSVFile">Image</label>
						<input type="file" id="imageFile" name="filename" />
					</div>
					<div class="sub-item">
						<input
							type="text"
							id="myClasses"
							name="filename"
							style="margin-right: 1em"
						/>
						<button id="remove" style="margin-right: 1em"
							>Isolate Data</button
						>
					</div>
				</section>

				<section class="container">
					<h3>3. Export reformatted files</h3>
					<div class="sub-item" style="display: flex">
						<button id="export" style="margin-right: 1em"
							>Export SVG</button
						>
						<button id="remove" style="margin-right: 1em"
							>Remove Data</button
						>
						<button id="export-csv-count" style="margin-right: 1em"
							>Export CSV with Count</button
						>

						<button id="export-csv" style="margin-right: 1em"
							>Export CSV No Count</button
						>
						<button id="export-csv-layer" style="margin-right: 1em"
							>Export CSV w Position</button
						>
						<button id="export-csv-layer-2048" style="margin-right: 1em"
							>Export CSV w Position 2048</button
						>
						
					</div>
					<label for="export-file-name">File Name: </label>
					<input type="text" id="export-file-name"/>
				</section>
			</div>
			<div id="id-container">
				<div class="id-list-title-container">
					<p
						class="id-list-title"
						style="padding: 0em 0em; font-weight: bold;"
					>
						CTRL + F to look for items
					</p>
					<p class="hide-toggle" id="hide-toggle">^</p>
				</div>
				<ul style="padding-left: 1em;" class="id-list" id="id-list">
				</ul>
			</div>
		</main>

		<section class="container">
			<h3>Viewer</h3>
			<button id="flip-x"> Flip X</button>

			<button id="flip-y"> Flip Y</button>
			<label for="group">Group:</label>
			<input
				id="group"
				oninput="this.value = this.value.toUpperCase()"
				type="text"
			/>

			<label for="unit">Unit:</label>
			<input
				id="unit"
				type="text"
				oninput="this.value = this.value.toUpperCase()"
			/>
			<button id="set-name">Set</button>
			<button id="set-unit">Apply Units</button>
			<input type="text" id="new-point-name" placeholder="Insert New Point Name"/>
			<button id="add-point">Add Point</button>
			<div class="output" id="svg-container">
				<p
					style="padding: 2em; background-color: #00000022; border-radius: 3px; margin: 0px;"
				>
					No SVG file
				</p>
			</div>

			<div id="tag">
				<h3 id="label">-</h3>
			</div>
			<svg id="svg"></svg>
		</section>
	</body>
</html>

<style>
	@font-face {
		font-family: "gabarito";
		src: url("/Gabarito-VariableFont_wght.ttf");
	}
	* {
		font-family: gabarito, sans-serif;
	}

	h3 {
		margin-top: 0.2em;
	}

	.toolsets {
		width: 100%;
	}

	.toolset-section {
		width: 100%;
		/* padding: 0.5em; */
	}
	#tag {
		display: flex;
		position: fixed;
		background-color: #cccccccc;
		padding: 0em 0.5em;
		text-align: center;
		justify-content: center;
		min-width: max-content;
		pointer-events: none;
		/* transform: translate(-50%); */
		height: 50px;
		border-radius: 6px;
		font-family: sans-serif;
	}
	#label {
		display: flex;
		text-align: center;
		justify-content: center;
		margin: 0%;
		height: 100%;
		font-family: sans-serif;
	}

	.output {
		pointer-events: fill;
	}

	#id-container {
		margin-top: 0.5em;
		background-color: #eee;
		max-height: 390px;
		width: 300px;
		border-radius: 5px;
		/* position: fixed; */
		right: 0%;
		top: 0%;
		display: flex;
		overflow-y: none;
		list-style: none;
		flex-direction: column;
		margin-left: 0.5em;
	}

	#svg-container {
		border: solid 1px #00000055;
		border-radius: 3px;
		position: relative;
	}

	.hide {
		display: none;
	}

	.container {
		background-color: #eee;
		margin-top: 0.5em;
		padding: 0.5em;
		border-radius: 5px;
	}

	.selected {
		fill: #ff0000;
	}

	.hovered {
		fill: #ff000066;
	}

	.sub-item {
		padding: 0.5em;
		margin-bottom: 0.1em;
		background-color: #00000011;
		border-radius: 3px;
	}

	.toggle {
		display: flex;
		flex-direction: column;
	}

	.expand {
		transform: rotate(180deg);
	}

	.hide-toggle:hover {
		cursor: pointer;
		text-decoration: underline;
	}

	.id-list {
		margin: 0%;
		overflow-y: scroll;
		min-height: 50px;
	}

	.id-list-title-container {
		display: flex;
		justify-content: space-between;
		padding: 0em 1em;
		background-color: #00000011;
	}

	.id-list-title span:hover {
		cursor: pointer;
		text-decoration: underline;
	}
</style>

<script>
	enum format {
		underscore,
		dash,
		none,
		fullUnderscore,
	}

	var flipped = false;
	var multiSelect = false;
	var clusterId = [];

	var idFormat = format.none; //SVG ID format
	//New Variables 08/12/23
	var mouseDown = false;
	var globalSvgContainer = document.getElementById('svg-container');
	var tempSelected;

	var formattingButtons = document.querySelectorAll(".formatting");
	formattingButtons.forEach((e) => {
		e.addEventListener("change", (event) => setFormat(event.target.value));
	});

	function setFormat(data) {
		if (data == "underscore") {
			idFormat = format.underscore;
		} else if (data == "dash") {
			idFormat = format.dash;
		} else if (data == "none") {
			idFormat = format.none;
		} else if (data == "fullUnderscore") {
			idFormat = format.fullUnderscore;
		}
	}
	//Attribute Editor
	var groupGlobal = [];

	var fileNameGlobal = "";
	var svg = document.getElementById("svg"); // get the SVG element
	var mouseRect = svg.createSVGRect(); // create a rectangle for the mouse position
	var currentSelected = null;

	document.getElementById("export-file-name").addEventListener('input', (e) => {
		fileNameGlobal = e.target.value
		console.log(fileNameGlobal)
	})
	document.addEventListener("mouseover", (e) => {

		// console.log(e.parentNode.nodeName.toLowerCase())
		if (
			e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
			e.srcElement.nodeName.toLowerCase() == "svg" ||
			e.srcElement.parentNode.nodeName.toLowerCase() == "g" ||
			!e.srcElement.tagName == "image"
		) {
			if (currentSelected != null) {
				currentSelected.classList.remove("hovered");
				if (!currentSelected.classList.contains("selected")) {
					currentSelected.style.fill = "";
				} else {
					currentSelected.style.fill = "#ff0000";
				}
			}
			document.getElementById("tag").style.display = "flex";
			document.getElementById("label").innerText = e.srcElement.id;
			currentSelected = e.srcElement;
			e.srcElement.classList.add("hovered");
		} else {
			document.getElementById("tag").style.display = "none";
			// console.log(e.srcElement.parentNode.nodeName);
		}

		document.querySelectorAll(".hovered").forEach((e) => {
			e.style.fill = "#ff000066";
		});
	});

	document.addEventListener("mouseup", (e) => {
		mouseDown = false;
	})

	document.getElementById('add-point').addEventListener('click', (e) => {
		console.log('adding point')
		console.log(document.getElementById('new-point-name').value)
		console.log(document.getElementById('new-point-name').value.length)
		if(document.getElementById('new-point-name').value.length > 0){
			const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle')
			circle.setAttribute('cx', '10')
			circle.setAttribute('cy', '10')
			circle.setAttribute('r', '30')
			circle.setAttribute('id', document.getElementById('new-point-name').value)
			globalSvgContainer.querySelector('svg').querySelector('g').appendChild(circle)
		} else {
			alert('Please add a name for the point')
		}
		
	})

	document.addEventListener("mousedown", (e) => {
		mouseDown = true
		// console.log(e.parentNode.nodeName.toLowerCase())
		if (e.srcElement.parentNode.nodeName.toLowerCase() == "g") {
			tempSelected = e.srcElement;
		}

		if (
			e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
			e.srcElement.nodeName.toLowerCase() == "svg" ||
			e.srcElement.parentNode.nodeName.toLowerCase() == "g"
		) {
			console.log(e.srcElement.id);
			// if (currentSelected != null) {
			// 	currentSelected.classList.add("hovered");
			// }
			document.getElementById("tag").style.display = "flex";
			document.getElementById("label").innerText = e.srcElement.id;
			currentSelected = e.srcElement;

			const groupName = e.srcElement;
			//Get Attributes
			if (!multiSelect) {
				groupGlobal = [];
				document.querySelectorAll(".selected").forEach((e) => {
					// console.log(e.classList)
					e.classList.remove("selected");
					// console.log(e.classList)
					e.style.fill = "";
				});
				groupGlobal.push(groupName);
			} else {
				groupGlobal.push(groupName);
			}

			if (groupGlobal.length < 2) {
				if (groupGlobal[0].getAttribute("group-attribute") != "") {
					document.getElementById("unit").focus();

					document.getElementById("group").value =
						groupGlobal[0].getAttribute("group-attribute");
				} else {
					document.getElementById("group").focus();
					document.getElementById("group").value = "";
				}

				if (groupGlobal[0].getAttribute("unit-attribute") != "") {
					document.getElementById("unit").value =
						groupGlobal[0].getAttribute("unit-attribute");
				} else {
					document.getElementById("unit").placeholder =
						"No Attribute";
					document.getElementById("unit").value = "";
				}
			} else {
				document.getElementById("group").focus();
				document.getElementById("group").placeholder = "-";
				document.getElementById("unit").placeholder = "-";
			}
			e.srcElement.classList.add("selected");

			// e.srcElement.style.fill = "#ff000055";
		} else {
			document.getElementById("tag").style.display = "none";
		}

		document.querySelectorAll(".selected").forEach((e) => {
			e.style.fill = "#ff0000";
		});
	});

	document.getElementById("set-name").addEventListener("click", (e) => {
		document.querySelectorAll(".selected").forEach((e) => {
			if (document.querySelectorAll(".selected").length < 2) {
				e.setAttribute(
					"group-attribute",
					document.getElementById("group").value,
				);
				e.setAttribute(
					"unit-attribute",
					document.getElementById("unit").value,
				);
				if (
					e.hasAttribute("group-attribute") &&
					e.hasAttribute("unit-attribute")
				) {
					e.id =
						e.getAttribute("group-attribute") +
						"_" +
						e.getAttribute("unit-attribute");
				}
			} else {
				e.setAttribute(
					"group-attribute",
					document.getElementById("group").value,
				);
				e.id =
					e.getAttribute("group-attribute") +
					"_" +
					e.getAttribute("unit-attribute");
			}
		});
	});

	document.getElementById("set-unit").addEventListener("click", (e) => {
		setUnit();
	});

	//Tag
	document.addEventListener("mousemove", (e) => {

		//Update Tags
		document.getElementById("tag").style.left = `${e.x}px`;
		document.getElementById("tag").style.top = `${e.y}px`;
		document.getElementById("tag").style.transform = `translate(${
			(e.clientX / window.innerWidth) * -100
		}%, ${(e.clientY / window.innerHeight) * -150}%)`;

		
		//Editing points
		if(mouseDown){
			if(tempSelected != null){
				if(tempSelected.getAttribute('cx') != null && tempSelected.getAttribute('cy') != null){
					if(globalSvgContainer.querySelector('svg') != null){
						var pt = globalSvgContainer.querySelector('svg').createSVGPoint();
						pt.x = e.clientX; pt.y = e.clientY;
  						const coords = pt.matrixTransform(globalSvgContainer.querySelector('svg').getScreenCTM().inverse())
						  console.log('Moving')
						  tempSelected.setAttribute('cx', coords.x)
						  tempSelected.setAttribute('cy', coords.y)
					}
				}
			}
			console.log("Mouse Down + Move")
		}
	});

	var fileInput = document.getElementById("myFile");
	var csvFileInput = document.getElementById("myCSVFile");
	var imageInput = document.getElementById("imageFile");
	var type = "";
	fileInput.addEventListener("click", (e) => {
		fileInput.value = null;
	});
	csvFileInput.addEventListener("click", (e) => {
		fileInput.value = null;
	});

	//SVG Uploading
	fileInput.addEventListener("change", function () {
		flipped = false;
		// Get the selected file
		var file = fileInput.files[0];
		fileNameGlobal = file.name;
		document.getElementById("export-file-name").value = file.name

		// Check if the file is an SVG image
		if (file.type === "image/svg+xml") {
			var reader = new FileReader();

			// Add a load event listener
			reader.addEventListener("load", function () {
				// Get the SVG content as a string
				var svgString = reader.result;
				var parser = new DOMParser();
				var svgDoc = parser.parseFromString(svgString, "image/svg+xml");

				var svgElement = svgDoc.documentElement;

				var list = svgElement.querySelectorAll(`[id]`);
				document.getElementById("id-list").innerHTML = "";

				//Regex Options
				const regexLastUnderscore = /_(?=[^_]*$)/g;
				const regexLastDash = /-(?=[^-]*$)/g;
				const regexDashUnderscore = /\w+-\w+_\w+/;
				const regexText = /^[^-]*/;
				const regexGroupName = /^([A-Z]{2}\d{2}-\d{1,2})/;
				const regexUnitNumber = /(\d{1,3})\D*$/;

				if (idFormat == format.underscore) {
					var count = 0;
					//If Underscore mode
					list.forEach((i) => {
						const currentId = i.id;
						var listItem = document.createElement("li");

						//Check if ID ends with a dash

						if (!regexDashUnderscore.test(currentId)) {
							//Change the last Dash into Underscore
							const regexResult = currentId.replace(
								regexLastDash,
								"_",
							);
							const selected = svgElement.getElementById(
								`${currentId}`,
							);
							const groupMatched =
								selected.id.match(regexGroupName);
							const unitMatched =
								selected.id.match(regexUnitNumber);
							if (groupMatched) {
								selected.setAttribute(
									"group-attribute",
									groupMatched[1],
								);
							}

							if (unitMatched) {
								selected.setAttribute(
									"unit-attribute",
									unitMatched[1],
								);
							}

							selected.id = regexResult;
							listItem.innerHTML = regexResult;
							clusterId.push({
								id: count,
								clusterId: regexText.exec(regexResult)[0],
								unitId: regexResult,
							});
						} else {
							clusterId.push({
								id: count,
								clusterId: regexText.exec(currentId)[0],
								unitId: currentId,
							});
							listItem.innerHTML = currentId;
						}
						count++;
						listItem.style.listStyle = "none";
						listItem.style.padding = "0.5em 0em";
						document.getElementById("id-list").append(listItem);
					});
				} else if (idFormat == format.dash) {
					var count = 0;
					list.forEach((i) => {
						const currentId = i.id;
						var listItem = document.createElement("li");
						// console.log(regexDashUnderscore.test(currentId))
						if (regexDashUnderscore.test(currentId)) {
							const regexResult = currentId.replace(
								regexLastUnderscore,
								"-",
							);

							const selected = svgElement.getElementById(
								`${currentId}`,
							);
							const groupMatched =
								selected.id.match(regexGroupName);
							const unitMatched =
								selected.id.match(regexUnitNumber);
							if (groupMatched) {
								selected.setAttribute(
									"group-attribute",
									groupMatched[1],
								);
							}

							if (unitMatched) {
								selected.setAttribute(
									"unit-attribute",
									unitMatched[1],
								);
							}
							selected.id = regexResult;
							listItem.innerHTML = regexResult;
							clusterId.push({
								id: count,
								clusterId: regexText.exec(regexResult)[0],
								unitId: regexResult,
							});
						} else {
							listItem.innerHTML = currentId;
							clusterId.push({
								id: count,
								clusterId: regexText.exec(currentId)[0],
								unitId: currentId,
							});
						}
						count++;
						listItem.style.listStyle = "none";
						listItem.style.padding = "0.5em 0em";
						document.getElementById("id-list").append(listItem);
					});
				} else if (idFormat == format.none) {
					var count = 0;
					list.forEach((i) => {
						const currentId = i.id;
						var listItem = document.createElement("li");

						const selected = svgElement.getElementById(
							`${currentId}`,
						);
						const groupMatched = selected.id.match(regexGroupName);
						const unitMatched = selected.id.match(regexUnitNumber);
						if (groupMatched) {
							selected.setAttribute(
								"group-attribute",
								groupMatched[1],
							);
						}

						if (unitMatched) {
							selected.setAttribute(
								"unit-attribute",
								unitMatched[1],
							);
						}

						listItem.innerHTML = currentId;

						clusterId.push({
							id: count,
							clusterId: regexText.exec(currentId)[0],
							unitId: currentId,
						});
						count++;
						listItem.style.listStyle = "none";
						listItem.style.padding = "0.5em 0em";
						document.getElementById("id-list").append(listItem);
					});
				}
				if (idFormat == format.fullUnderscore) {
					var count = 0;
					//If Underscore mode
					list.forEach((i) => {
						const currentId = i.id;
						var listItem = document.createElement("li");

						//Check if ID ends with a dash

						if (currentId) {
							//Change the all Dash into Underscore
							const regexResult = currentId.replaceAll("-", "_");
							console.log(regexResult);
							const selected = svgElement.getElementById(
								`${currentId}`,
							);
							const groupMatched =
								selected.id.match(regexGroupName);
							const unitMatched =
								selected.id.match(regexUnitNumber);
							// selected.setAttribute("id", regexResult)
							if (groupMatched) {
								selected.setAttribute(
									"group-attribute",
									groupMatched[1],
								);
							}

							if (unitMatched) {
								selected.setAttribute(
									"unit-attribute",
									unitMatched[1],
								);
							}

							selected.id = regexResult;
							listItem.innerHTML = regexResult;
							clusterId.push({
								id: count,
								clusterId: regexText.exec(regexResult)[0],
								unitId: regexResult,
							});
						} else {
							clusterId.push({
								id: count,
								clusterId: regexText.exec(currentId)[0],
								unitId: currentId,
							});
							listItem.innerHTML = currentId;
						}
						count++;
						listItem.style.listStyle = "none";
						listItem.style.padding = "0.5em 0em";
						document.getElementById("id-list").append(listItem);
					});
				}

				// Append the SVG element to the div element
				var svgContainer = document.getElementById("svg-container");
				svgContainer.innerHTML = "";
				svgContainer.appendChild(svgElement);

				//Set type for export filename
				if (idFormat == format.underscore) {
					type = "underscore";
				} else if (idFormat == format.dash) {
					type = "dash";
				} else if (idFormat == format.none) {
					type = "";
				}
			});

			reader.readAsText(file);
		} else {
			alert("Please select an SVG image file.");
		}
	});

	csvFileInput.addEventListener("change", (e) => {
		// Get the file object
		var file = e.target.files[0];
		fileNameGlobal = file.name;
		document.getElementById("export-file-name").value = file.name

		// Create a new FileReader object
		var reader = new FileReader();

		// Set the onload function for the FileReader object
		reader.onload = function (event) {
			// Get the contents of the file
			var contents = event.target.result;

			// Split the contents into lines
			var lines = contents.split("\n");
			console.log(lines)

			// Create an SVG element
			var g = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"g",
			);

			var textG = document.createElementNS(
				"http://www.w3.org/2000/svg",
				"g",
			);

			var svgContainer = document.getElementById("svg-container")
			// remove all groups except for Reference
			//To overlay waypoints on top of images
			if(svgContainer.querySelector('svg')){
				svgContainer.querySelector('svg').querySelectorAll('g').forEach((e) => {
				if(e.id.toLowerCase() != 'reference'){
					e.remove()
				}
			})
			
			} else {
				// svgContainer.innerHTML = "";
				const newSVG = document.createElementNS("http://www.w3.org/2000/svg", "svg");
				newSVG.style.width = "100%"
				newSVG.style.height = "100%"
				newSVG.setAttribute("viewBox", "0 0 4096 4096")
				newSVG.setAttribute("xmlns:xlink","http://www.w3.org/1999/xlink")
				svgContainer.appendChild(newSVG)
				if(svgContainer.querySelector('img')){
					const tempImage = svgContainer.querySelector('img')
					const svgimg = document.createElementNS('http://www.w3.org/2000/svg','image');
					svgimg.style.width = "100%"
					svgimg.style.height = "100%"
					// svgimg.setAttributeNS('http://www.w3.org/2000/svg','id','testimg2');
					svgimg.setAttributeNS('http://www.w3.org/1999/xlink','xlink:href',tempImage.src);
					newSVG.append(svgimg)
					tempImage.remove()

				}
			}
			

			
			const labelContainer = document.createElement('div');
			// Loop through the lines and create circles
			for (var i = 0; i < lines.length; i++) {
				// Split the line into fields
				var fields = lines[i].split(",");

				// Create a circle element
				var circle = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"circle",
				);

				var text = document.createElementNS(
					"http://www.w3.org/2000/svg",
					"text",
				);
				
				
				if(Number(fields[1]) || Number(fields[2])){
					circle.setAttribute("id", fields[0]);
					circle.setAttribute("cx", Number(fields[1]).toFixed(4));
					circle.setAttribute("cy", Number(fields[2]).toFixed(4));
					circle.setAttribute("r", "30");
					// const label = document.createElement('p')
					text.appendChild(document.createTextNode(`${fields[0]}`));
					text.style.fontSize = '80px'
					text.style.textAlign = 'center'
					text.style.textAnchor = 'middle'
					text.setAttribute('x', `${Number(fields[1]).toFixed(4)}`)
					text.setAttribute('y', `${Number(fields[2]).toFixed(4)}`)

					g.appendChild(circle);
					textG.appendChild(text)
				} else {
					console.error(`${fields[0] ?  fields[0] : `(Nameless), Row ${i + 1}`} does not contain any cx, cy data`)
				}
				
				
			}
			textG.setAttribute('id', 'reference')
			svgContainer.querySelector('svg').appendChild(textG);
			svgContainer.querySelector('svg').appendChild(g);
			
		};

		// Read the file as text
		reader.readAsText(file);
	});

	imageInput.addEventListener("change", (e) => {
		// Get the file object
		var file = e.target.files[0];
		fileNameGlobal = file.name;
		document.getElementById("export-file-name").value = file.name

		// Create a new FileReader object
		var reader = new FileReader();

		// Set the onload function for the FileReader object
		reader.onload = function (event) {
			// Get the contents of the file
			var contents = event.target.result;

			// Split the contents into lines
			var lines = contents.split("\n");
			console.log(lines)

			// Create an SVG element
			var img = document.createElement('img');
			img.src = contents;
			// img.style.width = '4096px'
			// img.style.height = '4096px'
			// img.style.position = 'absolute'
			img.style.maxHeight = '100%'
			img.style.maxWidth = '100%'
			var svgContainer = document.getElementById("svg-container")
			// remove all groups except for Reference
				svgContainer.innerHTML = ""
				svgContainer.appendChild(img)
			
		};

		// Read the file as text
		reader.readAsDataURL(file);
	});

	document.addEventListener("keydown", (e) => {
		if (e.key == "Escape") {
			document.querySelectorAll(".selected").forEach((e) => {
				e.classList.remove("selected");
				e.style.fill = "";
				groupGlobal = [];
				document.querySelectorAll("#group").value = "";
			});
		}

		if (e.key == "Shift") {
			multiSelect = true;
		}

		if (e.key == "Enter") {
			document.querySelector("#set-name").click();
		}

		if (e.key == "Q") {
			document.querySelector("#set-unit").click();
		}
	});

	function setUnit() {
		for (var i = 0; i < groupGlobal.length; i++) {
			groupGlobal[i].setAttribute("unit-attribute", pad(i + 1));
		}
	}

	//Add zero to single digit
	function pad(d) {
		return d < 10 ? "0" + d.toString() : d.toString();
	}

	document.addEventListener("keydown", (e) => {
		if (e.key == "Escape") {
			document.querySelectorAll(".selected").forEach((e) => {
				e.classList.remove("selected");
				e.style.fill = "";
				groupGlobal = [];
				document.querySelectorAll("#group").value = "";
			});
		}

		if (e.key == "Shift") {
			multiSelect = true;
		}
	});

	document.addEventListener("keyup", (e) => {
		if (e.key == "Shift") {
			multiSelect = false;
		}
	});

	document.getElementById("hide-toggle").addEventListener("click", (e) => {
		if (document.getElementById("id-list").style.display == "none") {
			document.getElementById("id-list").style.display = "block";
			document.getElementById("hide-toggle").classList.remove("expand");
		} else {
			document.getElementById("id-list").style.display = "none";
			document.getElementById("hide-toggle").classList.add("expand");
		}
	});

	document.getElementById("export-csv").addEventListener("click", (e) => {
		exportCSV();
	});

	document.getElementById("remove").addEventListener("click", (e) => {
		removeData();
	});

	document
		.getElementById("export-csv-count")
		.addEventListener("click", (e) => {
			exportCSVId();
		});

	document.getElementById("export").addEventListener("click", (e) => {
		exportSVG();
	});

	document
		.getElementById("export-csv-layer")
		.addEventListener("click", (e) => {
			exportFloorNamePosition();
		});

	document
		.getElementById("export-csv-layer-2048")
		.addEventListener("click", (e) => {
			exportFloorNamePosition2048();
		});

	// CSV Conversion
	function exportCSV() {
		const file = fileNameGlobal;
		var data = clusterId;
		data.forEach((e) => {
			delete e.id;
		});
		if (clusterId.length > 0) {
			// We can create a header row by mapping the object keys
			var header = Object.keys(data[0])
				.map((key) => `"${key}"`)
				.join(",");

			var rows = data.map((obj) =>
				Object.values(obj)
					.map((val) => `"${val}"`)
					.join(","),
			);

			var csv = [header, ...rows].join("\n");
			var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);

			link.download = file.replace(/\.[^/.]+$/, "") + "_" + type + ".csv";
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
	}

	// CSV Conversion
	function exportCSVId() {
		var data = clusterId;
		const file = fileNameGlobal;
		if (clusterId.length > 0) {
			// We can create a header row by mapping the object keys
			var header = Object.keys(data[0])
				.map((key) => `"${key}"`)
				.join(",");

			var rows = data.map((obj) =>
				Object.values(obj)
					.map((val) => `"${val}"`)
					.join(","),
			);

			var csv = [header, ...rows].join("\n");
			var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);
			link.download =
				file.replace(/\.[^/.]+$/, "") +
				"_" +
				type +
				"_w_Count" +
				".csv";
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
	}
	//SVG Conversion
	function exportSVG() {
		const file = fileNameGlobal;
		var svg = document.querySelector("#svg-container").querySelector("svg");
		document.querySelectorAll("[id]").forEach((e) => {
			const str = e.getAttribute("id");
			e.setAttribute("data-name", str.replace(/\s+/g, "_"));
		});
		document.querySelectorAll("[group-attribute]").forEach((e) => {
			e.removeAttribute("group-attribute");
		});
		document.querySelectorAll("[unit-attribute]").forEach((e) => {
			e.removeAttribute("unit-attribute");
		});
		if (svg) {
			var serializer = new XMLSerializer();
			var svgString = serializer.serializeToString(svg);
			var blob = new Blob([svgString], { type: "image/svg+xml" });
			var url = URL.createObjectURL(blob);
			var link = document.createElement("a");
			link.href = url;
			link.download = file.replace(/\.[^/.]+$/, "") + "_" + type + ".svg";
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		} else {
			alert("Import and SVG to start!");
		}
	}
	//SVG Conversion
	function exportFloorNamePosition() {
		// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
		if (document.querySelector("#svg-container").querySelector("svg")) {
			const parser = new DOMParser();
			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");

			const layers = Array.from(doc.querySelectorAll("g"))
				.map((layer, index) => {
					
					if(layer.getAttribute("id") != null || layer.getAttribute("id") != undefined ){
						if (layer.getAttribute("id").toLowerCase() != "reference") {
							console.log("Layer ID is found")
						const id = layer.getAttribute("id").replace("_", "");
						const children = Array.from(layer.children).map(
							(child) => {
								console.log(child);
								const childId = child.getAttribute("data-name")
									? decodeHtml(
											child.getAttribute("data-name"),
									  )
									: child.getAttribute("id");

								const x = child.getAttribute("cx");
								const y = child.getAttribute("cy");
								return { id: childId, x, y };
							},
						);
						console.log(id, children);
						return { id, children };
						}
					}  else {
							console.log("Layer ID is null")
							console.log(layer)
							const id = `item-${index}`
						const children = Array.from(layer.children).map(
							(child) => {
								console.log(child);
								const childId = child.getAttribute("data-name")
									? decodeHtml(
											child.getAttribute("data-name"),
									  )
									: child.getAttribute("id");

								const x = child.getAttribute("cx");
								const y = child.getAttribute("cy");
								return { id: childId, x, y };
							},
						);
						console.log(id, children);
						return { id, children };
						}
					
				})
				.filter((layer) => layer !== undefined);

			var csv;
			if (layers.length < 2) {
				csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) => `${child.id},${child.x},${child.y}`,
						),
					)
					.join("\n");

				console.log(csv);
			} else {
				csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) =>
								`${layer.id} ${child.id},${child.x},${child.y}`,
						),
					)
					.join("\n");

				console.log(csv);
			}

			const file = fileNameGlobal;
			var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);
			link.download =
				file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "");
			(".csv");
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
	}

	//SVG Conversion
	function exportFloorNamePosition2048() {
		// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
		if (document.querySelector("#svg-container").querySelector("svg")) {
			const parser = new DOMParser();
			var doc = null;

			doc = document.querySelector("#svg-container").querySelector("svg");
			const height = doc.viewBox.baseVal.height;
			const width = doc.viewBox.baseVal.width;

			const layers = Array.from(doc.querySelectorAll("g"))
				.map((layer) => {
					if (layer.getAttribute("id").toLowerCase() != "reference") {
						const id = layer.getAttribute("id").replace("_", "");
						const children = Array.from(layer.children).map(
							(child) => {
								console.log(child);
								const childId = child.getAttribute("data-name")
									? decodeHtml(
											child.getAttribute("data-name"),
									  )
									: child.getAttribute("id");

								const x =
									(child.getAttribute("cx") / width) * 2048;
								const y =
									(child.getAttribute("cy") / height) * 2048;
								return { id: childId, x, y };
							},
						);
						console.log(id, children);
						return { id, children };
					}
				})
				.filter((layer) => layer !== undefined);

			var csv;
			if (layers.length < 2) {
				csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) => `${child.id},${child.x},${child.y}`,
						),
					)
					.join("\n");

				console.log(csv);
			} else {
				csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) =>
								`${layer.id} ${child.id},${child.x},${child.y}`,
						),
					)
					.join("\n");

				console.log(csv);
			}

			const file = fileNameGlobal;
			var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);
			link.download =
				file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "");
			(".csv");
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
	}

	function decodeHtml(html) {
		var txt = document.createElement("textarea");
		txt.innerHTML = html;
		return txt.value;
	}

	document.getElementById("flip-x").addEventListener("click", (e) => {
		// var svg = document.querySelector("#svg-container").querySelector("svg");
		// svg.style.scale = "-1 1"
		flipped = !flipped;

		var doc = null;
		doc = document.querySelector("#svg-container").querySelector("svg");
		const width = doc.viewBox.baseVal.width;
		const layers = Array.from(doc.querySelectorAll("g")).map((layer) => {
			// if(layer.getAttribute("id").toLowerCase() != 'reference'){
			// const id = layer.getAttribute("id").replace('_', "");
			const children = Array.from(layer.children).map((child) => {
				if (child.tagName == "image") {
					// child.getAttribute("transform")
					// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
					if (!child.hasAttribute("flipped")) {
						child.setAttribute("flipped", "");
						child.style.transform =
							"scaleX(-1) translate(-100%, 0)";
					} else {
						child.removeAttribute("flipped");
						child.style.transform = "scaleX(1) translate(0, 0)";
					}

					console.log(child.style.scale);
				} else {
					const x = child.getAttribute("cx");
					child.setAttribute("cx", width - x);
				}
			});
			// }
		});
	});

	document.getElementById("flip-y").addEventListener("click", (e) => {
		// var svg = document.querySelector("#svg-container").querySelector("svg");
		// svg.style.scale = "-1 1"
		flipped = !flipped;

		var doc = null;
		doc = document.querySelector("#svg-container").querySelector("svg");
		const height = doc.viewBox.baseVal.height;
		const layers = Array.from(doc.querySelectorAll("g")).map((layer) => {
			// if(layer.getAttribute("id").toLowerCase() != 'reference'){
			// const id = layer.getAttribute("id").replace('_', "");
			const children = Array.from(layer.children).map((child) => {
				if (child.tagName == "image") {
					// child.getAttribute("transform")
					// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
					if (!child.hasAttribute("flipped")) {
						child.setAttribute("flipped", "");
						child.style.transform =
							"scaleY(-1) translate(0, -100%)";
					} else {
						child.removeAttribute("flipped");
						child.style.transform = "scaleX(1) translate(0, 0)";
					}

					console.log(child.style.scale);
				} else {
					const y = child.getAttribute("cy");
					child.setAttribute("cy", height - y);
				}
			});
			// }
		});
	});

	function removeData() {
		const doc = document.querySelector("#svg-container");

		// threeBed.forEach((x) => {
		//   console.log(x.getAttribute("style"));
		//   x.setAttribute("class", "cls-8182");
		// });

		// threeBedClip.setAttribute("class", threeBed.class);
		// threeBedClip.empty();

		// threeBed.setAttribute("fill", "#bddbe6");
		// const twoBed = doc.querySelectorAll(".cls-8281").closest("g");
		// twoBed.setAttribute("fill", "#f2b38c");
		// const oneBed = doc.querySelectorAll(".cls-7986").closest("g");
		// oneBed.setAttribute("fill", "#e8acac");
		// const xml = doc.querySelector("xml").outerHTML;
		const xml = `<?xml version="1.0" encoding="UTF-8"?>`;
		const defs = doc.querySelector("defs");
		const maskParent = document.querySelector("defs");
		const maskChild = maskParent.children;
		const maskShape = Array.from(maskChild).map((e) => {
			// const className = e.classList
			// console.log(className)
			const shape = e.children[0];
			if (shape) {
				if (shape.nodeName == "polygon" || shape.nodeName == "path") {
					const className = shape.classList[0];
					shape.classList.remove(className);
					return shape;
				}
			}
		});
		console.log(maskShape);

		console.log(document.styleSheets[1].cssRules);
		// var kvPair = Array.from(document.styleSheets[1].cssRules).map((e)=> {
		// 	// return e.selectorText
		// 	// return e.style.clipPath
		// 	if(e.style.clipPath){
		// 		var str = e.style.clipPath;
		// 		var regex = /#([\w-]+)/; // \w matches any alphanumeric character
		// 		var match = regex.exec(str); // exec returns an array of matches
		// 		var id
		// 		id = "#" + match[1]; // the first capture group is the ID
		// 		return {[e.selectorText.replace(/[-.]/g, "")] : id}
		// 	}
		// })

		var kvPair = Object.assign(
			{},
			...Array.from(document.styleSheets[1].cssRules).map((e) => {
				// return e.selectorText
				// return e.style.clipPath
				if (e.style.clipPath) {
					var str = e.style.clipPath;
					var regex = /#([\w-]+)/; // \w matches any alphanumeric character
					var match = regex.exec(str); // exec returns an array of matches
					var id = "#" + match[1]; // the first capture group is the ID
					return { [e.selectorText.replace(/[-.]/g, "")]: id };
				}
			}),
		);

		// kvPair = kvPair.filter(element => {
		//     return element !== undefined;
		// })
		var classes = [
			"cls-8158",
			"cls-8167",
			"cls-8163",
			"cls-8166",
			"cls-8165",
		];
		console.log(kvPair);
		const classValues = document
			.getElementById("myClasses")
			.value.replace(/\s/g, "");
		if (classValues) {
			classes = classValues.split(",");
		}

		var units = [];
		if (classes) {
			classes.forEach((e) => {
				doc.querySelectorAll(`.${e}`).forEach((i) => {
					console.log(i);
					const parentClass = String(i.parentElement.classList[0]);
					const refId = kvPair[parentClass.replace(/[-.]/g, "")];
					console.log(parentClass);
					const refEl = doc
						.querySelector("defs")
						.querySelector(refId);
					var child;
					if (refEl) {
						console.log(refEl);
						child = refEl.children[0];
						child.classList.remove(child.classList[0]);
						child.classList.add(e);
						units.push(child);
						return child;
					}
				});
			});
		}

		console.log("units");
		console.log(units);

		// const threeBed = Array.from(doc.querySelectorAll(".cls-8182")).map((e) => {
		// 			const parentClass = String(e.parentElement.classList[0])
		// 			console.log(e)
		// 			const refId = kvPair[parentClass.replace( /[-.]/g, "")]
		// 			console.log(parentClass)
		// 			const refEl = doc.querySelector("defs").querySelector(refId)
		// 			var child
		// 			if(refEl){
		// 				child = refEl.children[0]
		// 				child.classList.remove(child.classList[0])
		// 				child.classList.add('cls-8182')
		// 				return child
		// 			}
		// 		});
		// 		console.log(threeBed)

		// 		const twoBed = Array.from(doc.querySelectorAll(".cls-8281")).map((e) => {
		// 			const parentClass = String(e.parentElement.classList[0])
		// 			const refId = kvPair[parentClass.replace ( /[-.]/g, "")]
		// 			console.log(parentClass)
		// 			const refEl = doc.querySelector("defs").querySelector(refId)
		// 			var child
		// 			if(refEl){
		// 				child = refEl.children[0]
		// 				child.classList.remove(child.classList[0])
		// 				child.classList.add('cls-8281')
		// 				return child
		// 			}
		// 		});
		// 		console.log(threeBed)

		// 		const oneBed = Array.from(doc.querySelectorAll(".cls-7986")).map((e) => {
		// 			const parentClass = String(e.parentElement.classList[0])
		// 			const refId = kvPair[parentClass.replace ( /[-.]/g, "")]
		// 			console.log(parentClass)
		// 			const refEl = doc.querySelector("defs").querySelector(refId)
		// 			var child
		// 			if(refEl){
		// 				child = refEl.children[0]
		// 				child.classList.remove(child.classList[0])
		// 				child.classList.add('cls-7986')
		// 				return child
		// 			}
		// 		});
		// 		console.log(threeBed)
		// const style = doc.querySelector("style");

		// parent.setAttribute("id", "Layer_1");
		// parent.setAttribute("data-name", "Layer 1");
		// parent.setAttribute("viewBox", "0 0 1684.08 2384.28");
		// parent.setAttribute("xmlns", "http://www.w3.org/2000/svg");
		// parent.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
		// defs.append(style);

		const output = document.createElementNS(
			"http://www.w3.org/2000/svg",
			"g",
		);
		// parent.append(oneBed);
		// parent.append(twoBed);
		// threeBed.forEach((e) => {
		// 	parent.appendChild(e);
		// })

		// output.append(parent);
		// parent.prepend(xml);
		// save the output as a separate SVG file

		var svg = doc.querySelector("svg");
		console.log(svg);
		while (svg.firstChild) {
			svg.removeChild(svg.firstChild);
		}
		// // const parent = document.createElement("g");
		svg.append(defs);
		units.forEach((e) => {
			console.log(e);
			svg.append(e);
		});

		// twoBed.forEach((e) => {
		// 	svg.append(e)
		// })

		// oneBed.forEach((e) => {
		// 	svg.append(e)
		// })

		// maskShape.forEach((e) => {
		// 	svg.append(e)
		// })
		// console.log(doc.querySelector('svg').attributeStyleMap)
		// svg.appendChild(parent)
	}

	// 	function getStyle(className) {
	//     var cssText = "";
	//     var classes = document.styleSheets[0].rules || document.styleSheets[0].cssRules;
	//     for (var x = 0; x < classes.length; x++) {
	//         if (classes[x].selectorText == className) {
	//             cssText += classes[x].cssText || classes[x].style.cssText;
	//         }
	//     }
	//     return cssText;
	// }

	function getStyleSheet(unique_title) {
		for (const sheet of document.styleSheets) {
			if (sheet.title === unique_title) {
				return sheet;
			}
		}
	}
	
</script>
