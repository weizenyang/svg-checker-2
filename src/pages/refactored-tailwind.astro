---

---

<html lang="en">
<head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Floorplan CSV Editor</title>
</head>
<body class="min-h-screen p-2 grid grid-cols-6 gap-2 font-sans">
    <!-- Drag Drop Prompt -->
    <div class="fixed hidden inset-0 bg-black bg-opacity-40 z-50 text-white justify-center items-center transition-opacity duration-200" id="drag-drop-prompt">
        <div class="flex justify-center items-center h-full w-full">
            <h1 class="text-4xl">Drag and Drop Here</h1>
        </div>
    </div>

    <!-- Main Content -->
    <main class="flex">
        <div class="flex flex-col">
            <!-- Custom SVG ID Formatting -->
            <section class="mb-4">
                <input id="custom-formatting" type="checkbox" class="hidden" />
                <label for="custom-formatting" class="flex items-center cursor-pointer">
                    Custom SVG ID Formatting
                    <span class="ml-2">^</span>
                </label>
                <div class="flex flex-col space-y-2 mt-2">
                    <div class="flex items-center space-x-2">
                        <input type="radio" name="data-format" id="underscore" value="underscore" class="mr-2" /> 
                        <label for="underscore">Underscore on Last Identifier (NHXX-XX<b>_</b>XX)</label>
                    </div>
                    <div class="flex items-center space-x-2">
                        <input type="radio" name="data-format" id="dash" value="dash" class="mr-2" /> 
                        <label for="dash">Dash on Last Identifier (NHXX-XX<b>-</b>XX)</label>
                    </div>
                    <div class="flex items-center space-x-2">
                        <input type="radio" name="data-format" id="none" value="none" checked class="mr-2" /> 
                        <label for="none">None</label>
                    </div>
                    <div class="flex items-center space-x-2">
                        <input type="radio" name="data-format" id="fullUnderscore" value="fullUnderscore" class="mr-2" /> 
                        <label for="fullUnderscore">Full Underscore</label>
                    </div>
                </div>
            </section>

            <!-- Import File Section -->
            <section class="mb-4">
                <label for="myFile" class="flex items-center justify-center p-3 w-full bg-gray-800 text-white cursor-pointer rounded-md">
                    Import
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="ml-2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="17 8 12 3 7 8"></polyline>
                        <line x1="12" y1="3" x2="12" y2="15"></line>
                    </svg>
                </label>
                <input type="file" id="myFile" class="hidden" />
            </section>

            <!-- Flip Buttons -->
            <section class="mb-4">
                <p class="mb-2">Edit:</p>
                <div class="grid grid-cols-2 gap-2">
                    <button id="flip-x" class="px-3 py-2 bg-gray-800 text-white rounded-md">Flip X</button>
                    <button id="flip-y" class="px-3 py-2 bg-gray-800 text-white rounded-md">Flip Y</button>
                </div>
            </section>

            <!-- Group & Unit Section -->
            <section class="mb-4">
                <input id="group" type="text" class="w-full p-2 mb-2 border border-gray-300 rounded-md" placeholder="Group" />
                <input id="unit" type="text" class="w-full p-2 mb-2 border border-gray-300 rounded-md" placeholder="Unit" />
                <div class="grid grid-cols-2 gap-2">
                    <button id="set-name" class="px-3 py-2 bg-gray-800 text-white rounded-md">Set</button>
                    <button id="set-unit" class="px-3 py-2 bg-gray-800 text-white rounded-md">Apply Units</button>
                </div>
            </section>

            <!-- Point Properties Section -->
            <section class="mb-4">
                <p class="mb-2">Point Properties:</p>
                <input id="item-id" type="text" class="w-full p-2 mb-2 border border-gray-300 rounded-md" placeholder="ID" />
                <div class="grid grid-cols-2 gap-2">
                    <button id="set-id" class="px-3 py-2 bg-gray-800 text-white rounded-md">Set</button>
                    <button id="add-point" class="px-3 py-2 bg-gray-800 text-white rounded-md">Add Point</button>
                    <button id="delete-point" class="px-3 py-2 bg-gray-800 text-white rounded-md">Delete</button>
                </div>
            </section>

            <!-- Export Section -->
            <section class="mb-4">
                <input type="text" id="export-file-name" class="w-full p-2 mb-2 border border-gray-300 rounded-md" placeholder="File Name" />
                <button id="export" class="w-full p-3 bg-gray-800 text-white rounded-md flex items-center justify-center mb-2">
                    Export SVG
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" class="ml-2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                        <polyline points="7 10 12 15 17 10"></polyline>
                        <line x1="12" y1="15" x2="12" y2="3"></line>
                    </svg>
                </button>
                <div class="flex items-center space-x-2 mb-4">
                    <input type="checkbox" id="yx-flip" class="mr-2" checked /> 
                    <label for="yx-flip">Y/X Flip</label>
                </div>
                <button id="export-csv-layer" class="w-full p-3 bg-gray-800 text-white rounded-md flex items-center justify-between mb-2">
                    Export CSV <span class="ml-2">4096px</span>
                </button>
                <button id="export-csv-layer-2048" class="w-full p-3 bg-gray-800 text-white rounded-md flex items-center justify-between">
                    Export CSV <span class="ml-2">2048px</span>
                </button>
            </section>

            <!-- Key Mappings -->
            <button class="w-full p-3 bg-transparent border border-gray-800 text-gray-800 rounded-md flex items-center justify-center mt-4">
                <svg fill="#000" width="30" height="30" class="mr-2" viewBox="0 0 324.952 324.952" xmlns="http://www.w3.org/2000/svg">
                    <path d="M323.195,33.502c-2.342-2.344-6.143-2.344-8.484,0c-20.718,20.718-31.436,18.955-43.851,16.909 c-13.984-2.301-29.752-4.876-56.232,19.795c-15.643-15.121-36.605-23.45-59.216-23.45c-25.451,0-50.795,10.747-69.532,29.485 L85.1,77.02l-55.644,55.643c-37.173,37.172-39.447,95.383-5.069,129.761l6.09,6.091l-18.031,18.032 c-3.317,3.317-3.317,8.708,0,12.025c1.659,1.659,3.835,2.488,6.012,2.488c2.178,0,4.354-0.829,6.013-2.488l18.031-18.032 l6.091,6.091c17.197,17.196,40.838,26.794,65.484,26.794c26.198,0,51.348-11.255,68.8-30.848l19.453-19.453 c18.737-18.737,29.484-44.081,29.484-69.532c0-22.61-8.329-43.572-23.45-59.216c24.672-26.481,22.096-42.249,19.795-56.232 c-2.046-12.415-3.808-23.132,16.91-43.851C325.539,39.645,325.539,35.846,323.195,33.502z"/>
                </svg>
                Key Mappings
            </button>
        </div>
    </main>
</body>
</html>


<style>
	@font-face {
		font-family: "gabarito";
		src: url("/Gabarito-VariableFont_wght.ttf");
	}
	* {
		font-family: gabarito, sans-serif;
	}

	button{
		all: unset;
		
		width: 100%;
		display: flex;
		margin: 0px;
		font-size: 12px;
		padding: 0.3em;
		cursor: pointer;
		border-radius: 4px;
		background-color: #FFF;
	}

	button:hover{
		background-color: #ccc;
	}

	body{
		box-sizing: border-box;
		display: grid;
		grid-template-columns: repeat(6, 1fr);

		grid-template-rows: repeat(6, 1fr);
		gap: 10px;
		
		min-height: 100vh;
		margin: 0%;
		padding: 10px;
	}

	.boxed{
		font-size: 12px; 
		padding: 0.2em; 
		color: #333; 
		background-color: #ccc; 
		border-radius: 3px; 
	}

	.button-style{
		display: flex;
		cursor: pointer;
		box-sizing: border-box;
		padding: 0.7em;
		width: 100%;
		align-items: center;
		justify-content: center;
		font-size: large;
		color: #eee;
		transition: 0.2s;
		background-color: #333333;
		border-radius: 4px;
	}
	.button-style:hover{
		display: flex;
		cursor: pointer;
		padding: 0.7em;
		align-items: center;
		justify-content: center;
		font-size: large;
		color: #eee;
		
		background-color: #555555;
	}
	.button-style svg{
		padding-left: 1em
	}

	.row{
		display: flex;
		flex-direction: row;
		padding: 0.5em;
	}

	.row :first-child{
		width: 210px;
		align-items: flex-end;
	}

	.row p{
		margin: 0%;
	}

	.hollow{
		display: flex;
		cursor: pointer;
		box-sizing: border-box;
		padding: 0.7em;
		width: 100%;
		color: #333333;
		background-color: #33333300;
		border: solid 1px #333333;
	}

	.button-gap :first-child{
		margin: 0em 0.2em;
		margin-left: 0em;
		text-align: center;
		align-items: center;
		justify-content: center;
	}

	.button-gap :last-child{
		margin: 0em 0.2em;
		margin-right: 0em;
		text-align: center;
		align-items: center;
		justify-content: center;
	}

	.button-gap button{
		border: 1px solid #00000022;
		background-color: #333333;
		color: #eee;
		margin: 0em 0.2em;
		text-align: center;
		align-items: center;
		justify-content: center;
	}

	.button-gap button:hover{
		background-color: #888888;
	}

	.drag-drop-prompt{
		position: fixed;
		display: none;
		opacity: 0;
		width: calc(100% - 25px);
		height: calc(100% - 25px);
		margin-right: 1em;
		margin-bottom: 1em;
		background-color: #00000055;
		z-index: 10000000;
		color: #eee;
		transition: opacity 0.2;
	}

	.drag-drop-prompt.appear{
		display: flex;
		opacity: 1;
	}

	.animated-border {
		position: relative;
		width: 100%;
		height: 100%;
		background-image: repeating-linear-gradient(0deg, #333333, #333333 10px, transparent 10px, transparent 20px, #333333 20px), repeating-linear-gradient(90deg, #333333, #333333 10px, transparent 10px, transparent 20px, #333333 20px), repeating-linear-gradient(180deg, #333333, #333333 10px, transparent 10px, transparent 20px, #333333 20px), repeating-linear-gradient(270deg, #333333, #333333 10px, transparent 10px, transparent 20px, #333333 20px);
		background-size: 3px calc(100% + 20px), calc(100% + 20px) 3px, 3px calc(100% + 20px) , calc(100% + 20px) 3px;
		background-position: 0 0, 0 0, 100% 0, 0 100%;
		background-repeat: no-repeat;
		animation: borderAnimation 1s infinite linear;
		display: flex;
		align-items: center;
		text-align: center;
		justify-content: center;
	}

	@keyframes borderAnimation {
		from { background-position: 0 0, -20px 0, 100% -20px, 0 100%; }
		to { background-position: 0 -20px, 0 0, 100% 0, -20px 100%; }
	}

	.dropdown ~ .toggle{
		display: none
	}

	.dropdown:checked ~ .toggle{
		display: flex;
		flex-direction: column;
	}

	.dropdown:checked ~ .toggle{
		display: flex;
		flex-direction: column;
	}

	.dropdown ~ label{
		display: flex;
		cursor: pointer;
		align-items: center;
		justify-content: space-between;
		
	}
	.dropdown ~ label .arrow{
		display: flex;
		cursor: pointer;
		font-size: 2em;
		text-align: center;
		
		justify-content: center;
	}

	.dropdown:checked ~ label .arrow{
		transform: rotate(180deg);
		
	}

	h3 {
		margin-top: 0.2em;
	}

	.toolsets {
		width: 100%;
		grid-column: 1 / 1;
		grid-row: 1/7;
	}

	.editor{
		grid-column: 2/7;
		grid-row: 1/7;
		height: 100vh;
		position: sticky;
	}

	.container {
		box-sizing: border-box;
		/* background-color: #0000000c; */
		border: 0.3px solid #00000022;
		padding: 0.5em;
		width: auto;
		display: flex;
		flex-direction: column;
		border-radius: 5px;
		-webkit-user-select: none; /* Safari */
		-ms-user-select: none; /* IE 10 and IE 11 */
		user-select: none; /* Standard syntax */
	}

	.input-style{
		all: unset;
		border: 0px solid;
		border-radius: 3px;
		/* background-color: #00000011; */
		transition: box-shadow 0.2s;
		border: solid 0.5px #ddd;
		padding: 0.3em;
	}

	.input-style:focus{
		box-shadow: inset 0px 0px 100px #fff;
		border: solid 1px;
	}

	.toolset-section {
		width: 100%;

		/* padding: 0.5em; */
	}

	.toolset-section .container{
		margin-top: 10px;
	}

	.toolset-section .container:first-child{
		margin-top: 0px;
	}

	.hidden{
		display: none !important;
	}

	#tag, #tag *{
		display: flex;
		position: fixed;
		background-color: #cccccccc;
		padding: 0em 0.5em;
		text-align: left;
		line-height: 0.5em;
		font-family: monospace;
		font-weight: 100;
		justify-content: center;
		min-width: max-content;
		pointer-events: none;
		/* transform: translate(-50%); */
		/* min-height: 50px; */
		height: fit-content;
		border-radius: 6px;
		/* font-family: sans-serif; */
	}
	#label {
		display: flex;
		text-align: center;
		justify-content: center;
		margin: 0%;
		height: 100%;
		font-family: sans-serif;
	}

	.output {
		pointer-events: fill;
	}

	#id-container {
		/* margin-top: 0.5em; */
		background-color: #eee;
		max-height: 390px;
		border-radius: 5px;
		/* position: fixed; */
		right: 0%;
		top: 0%;
		display: flex;
		overflow-y: none;
		list-style: none;
		flex-direction: column;
		/* margin-left: 0.5em; */
	}

	#svg-container {
		border: solid 1px #00000055;
		border-radius: 3px;
		position: relative;
		max-height: 91vh;
		max-width: 91vh;
	}

	.hide {
		display: none;
	}



	.svg-tool-selected {
		fill: #ff0000;
	}

	.hovered {
		fill: #ff000066;
	}

	.sub-item {
		padding: 0.5em;
		margin-bottom: 0.1em;
		/* background-color: #00000011; */
		border: 1px solid #00000022;
		border-radius: 3px;
		display: flex;
		/* flex-direction: column; */
	}

	.sub-item [type="radio"]{
		margin-left: 0%;
	}

	.toggle {
		display: flex;
		flex-direction: column;
	}

	.expand {
		transform: rotate(180deg);
	}

	.hide-toggle:hover {
		cursor: pointer;
		text-decoration: underline;
	}

	.id-list {
		margin: 0%;
		overflow-y: scroll;
		min-height: 50px;
	}

	.id-list-title-container {
		display: flex;
		justify-content: space-between;
		padding: 0em 1em;
		background-color: #00000011;
	}

	.id-list-title span:hover {
		cursor: pointer;
		text-decoration: underline;
	}
</style>

<script>
	enum format {
		underscore,
		dash,
		none,
		fullUnderscore,
	}

	var flipped = false;
	var multiSelect = false;
	var clusterId = [];
	
	var idFormat = format.none; //SVG ID format
	var mouseDown = false;
	var globalSvgContainer = document.getElementById('svg-container');
	var mouseInContainer = false;
	var tempSelected;
	var flipYX = true;

	let prevMouseX = 0;
	let prevMouseY = 0;

	let rightMouseDown = false;
	let anchorPoint = { x: 0, y: 0 };
	let typing = false;

	let globalFloors = []


	//Tutorial
	const dialog = document.querySelector("dialog");
	const showButton = document.querySelector("dialog + button");
	const closeButton = document.querySelector("dialog button");

	// "Show the dialog" button opens the dialog modally
	showButton.addEventListener("click", () => {
	dialog.showModal();
	});

	// "Close" button closes the dialog
	closeButton.addEventListener("click", () => {
	dialog.close();
	});

	// "Close" button closes the dialog
	dialog.addEventListener("click", () => {
	dialog.close();
	});


	var formattingButtons = document.querySelectorAll(".formatting");
	formattingButtons.forEach((e) => {
		e.addEventListener("change", (event) => setFormat(event.target.value));
	});

	function setFormat(data) {
		if (data == "underscore") {
			idFormat = format.underscore;
		} else if (data == "dash") {
			idFormat = format.dash;
		} else if (data == "none") {
			idFormat = format.none;
		} else if (data == "fullUnderscore") {
			idFormat = format.fullUnderscore;
		}
	}
	//Attribute Editor
	var groupGlobal = [];

	var fileNameGlobal = "";
	var svg = document.getElementById("svg"); // get the SVG element
	var mouseRect = svg.createSVGRect(); // create a rectangle for the mouse position
	var currentSelected = null;

	document.getElementById("export-file-name").addEventListener('input', (e) => {
		fileNameGlobal = e.target.value
		console.log(fileNameGlobal)
	})

	//Check if SVG Container is active
	document.getElementById("svg-container").addEventListener("mouseover", (e) => {
		//Set global var MouseInContainer
		mouseInContainer = true;
	})

	document.getElementById("svg-container").addEventListener("mouseout", (e) => {
		//Set global var MouseInContainer
		mouseInContainer = false;
	})

	// globalSvgContainer.addEventListener('mouseleave', () => {
	// 	mouseInContainer = false;
	// });

	document.getElementById('svg-container').addEventListener("mouseover", (e) => {

		if (
			e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
			e.srcElement.nodeName.toLowerCase() == "svg" ||
			e.srcElement.parentNode.nodeName.toLowerCase() == "g" ||
			!e.srcElement.tagName == "image"
		) {

			if (currentSelected != null) {
				currentSelected.classList.remove("hovered");
				if (!currentSelected.classList.contains("svg-tool-selected")) {
					currentSelected.style.fill = "";
				} else {
					currentSelected.style.fill = "#ff0000";
				}
			}
			document.getElementById("tag").style.display = "flex";
			document.getElementById("label").innerHTML = "";
			var label = document.createElement('div')
			if(e.srcElement.id){
				var idLabel = document.createElement('p')
				idLabel.innerText = `ID: ${e.srcElement.id}`
				idLabel.style.color = "#007700"
				label.appendChild(idLabel)
			}

			if(e.srcElement.getAttribute('class')){
				var classLabel = document.createElement('p')
				var tempClassList = Object.assign({}, e.srcElement.classList);
				tempClassList = Object.keys(tempClassList).filter(item => tempClassList[item] !== "svg-tool-selected");
				if(tempClassList.length > 0){
					var tempString = "";
					tempClassList.forEach(classname => {
						if(tempString == ""){
							tempString = classname
						} else {
							tempString += " " + classname;
						}
					});
					classLabel.innerText = `Class: ${tempClassList}`
				}
				
				label.appendChild(classLabel)
			}

			if(e.target.getAttribute('data-floor')){
				var floorLabel = document.createElement('p')
				floorLabel.innerText = `Floor: ${e.srcElement.getAttribute('data-floor')}`
				floorLabel.style.color = "#007700"
				label.appendChild(floorLabel)
			}
			
			
			document.getElementById("label").append(label)
			currentSelected = e.srcElement;
			e.srcElement.classList.add("hovered");
		} else {
			document.getElementById("tag").style.display = "none";
			mouseInContainer = false;
			// console.log(e.srcElement.parentNode.nodeName);
		}

		document.querySelectorAll(".hovered").forEach((e) => {
			e.style.fill = "#ff000066";
		});
	});

	document.getElementById("yx-flip").addEventListener("change", (e) => {
		flipYX = e.target.checked;
	})

	// document..getElementById('svg-container').addEventListener("click",(e))
	document.getElementById('svg-container').addEventListener("mousedown", (e) => {
		if (
			e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
			e.srcElement.nodeName.toLowerCase() == "svg" ||
			e.srcElement.parentNode.nodeName.toLowerCase() == "g"
		) {

			if (mouseInContainer) {
				if (e.button === 0) {
					// Left mouse button
					mouseDown = true;
				} else if (e.button === 1) {
					// Right mouse button
					rightMouseDown = true;
					prevMouseX = e.clientX;
					prevMouseY = e.clientY;
					// Calculate the anchor point for scaling
					anchorPoint = calculateBoundingBoxCenter(groupGlobal);
				}
			}
			prevMouseX = e.clientX;
			prevMouseY = e.clientY;
			// if (currentSelected != null) {
			// 	currentSelected.classList.add("hovered");
			// }
			document.getElementById("tag").style.display = "flex";
			document.getElementById("label").innerText = e.srcElement.id;
			currentSelected = e.srcElement;

			const groupName = e.srcElement;
			//Get Attributes
			if (!multiSelect) {
				groupGlobal = [];
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					// console.log(e.classList)
					e.classList.remove("svg-tool-selected");
					// console.log(e.classList)
					e.style.fill = "";
				});

				groupGlobal.push(groupName);
				console.log(groupGlobal);
			} else {
				if(!groupName.classList.contains("hovered") && groupName.classList.contains("svg-tool-selected")){
					groupGlobal.push(groupName);
				} else if (groupGlobal.length <= 1){
					groupGlobal.push(groupName);
				}
				console.log(groupGlobal);
			}

			if (groupGlobal.length < 2) {
				if (groupGlobal[0].getAttribute("group-attribute") != "") {

					document.getElementById("group").value =
						groupGlobal[0].getAttribute("group-attribute");
				} else {
					document.getElementById("group").value = "";
				}

				if (groupGlobal[0].getAttribute("unit-attribute") != "") {
					document.getElementById("unit").value =
						groupGlobal[0].getAttribute("unit-attribute");
				} else {
					document.getElementById("unit").placeholder =
						"No Attribute";
					document.getElementById("unit").value = "";
				}

				if (groupGlobal[0].getAttribute("id") != "") {
					document.getElementById("item-id").value =
						groupGlobal[0].getAttribute("id");
				} else {
					document.getElementById("item-id").placeholder =
						"No Attribute";
					document.getElementById("item-id").value = "";
				}
			} else {
				document.getElementById("group").placeholder = "Group";
				document.getElementById("unit").placeholder = "Unit";
				document.getElementById("item-id").placeholder = "ID";
			}
			e.srcElement.classList.add("svg-tool-selected");

			// e.srcElement.style.fill = "#ff000055";
		} else {
			document.getElementById("tag").style.display = "none";

		}

		document.querySelectorAll(".svg-tool-selected").forEach((e) => {
			e.style.fill = "#ff0000";
		});
	});

	document.getElementById("set-name").addEventListener("click", (e) => {
		document.querySelectorAll(".svg-tool-selected").forEach((e) => {
			if (document.querySelectorAll(".svg-tool-selected").length < 2) {
				e.setAttribute(
					"group-attribute",
					document.getElementById("group").value,
				);
				e.setAttribute(
					"unit-attribute",
					document.getElementById("unit").value,
				);
				if (
					e.hasAttribute("group-attribute") &&
					e.hasAttribute("unit-attribute")
				) {
					e.id =
						e.getAttribute("group-attribute") +
						"_" +
						e.getAttribute("unit-attribute");
				}
			} else {
				e.setAttribute(
					"group-attribute",
					document.getElementById("group").value,
				);
				e.id =
					e.getAttribute("group-attribute") +
					"_" +
					e.getAttribute("unit-attribute");
			}
		});
	});

	document.getElementById("delete-point").addEventListener("click", (e) => {
		document.querySelectorAll(".svg-tool-selected").forEach((e) => {
			e.remove()
		});
	});

	document.getElementById("set-id").addEventListener("click", (e) => {
		document.querySelectorAll(".svg-tool-selected").forEach((e) => {
			if (document.querySelectorAll(".svg-tool-selected").length < 2) {
				e.setAttribute(
					"id",
					document.getElementById("item-id").value,
				);
			} else {
				e.setAttribute(
					"id",
					document.getElementById("item-id").value,
				);
			}
		});
	});

	document.getElementById("set-unit").addEventListener("click", (e) => {
		setUnit();
	});

	//Tag
	document.addEventListener("mousemove", (e) => {
			document.getElementById("tag").style.left = `${e.x}px`;
			document.getElementById("tag").style.top = `${e.y}px`;
			document.getElementById("tag").style.transform = `translate(${
				(e.clientX / window.innerWidth) * -100
			}%, ${(e.clientY / window.innerHeight) * -150}%)`;
	});

	var fileInput = document.getElementById("myFile");
	var csvFileInput = document.getElementById("myCSVFile");
	var imageInput = document.getElementById("imageFile");
	var type = "";
	fileInput.addEventListener("click", (e) => {
		fileInput.value = null;
	});

function calculateSensitivity(svgElement) {
    const svgRect = svgElement.getBoundingClientRect(); // Get the on-screen size of the SVG
    const viewBox = svgElement.viewBox.baseVal; // Get the SVG's viewBox dimensions

    const scaleX = viewBox.width / svgRect.width;
    const scaleY = viewBox.height / svgRect.height;

    return { scaleX, scaleY };
}

function calculateBoundingBoxCenter(elements) {
    if (elements.length === 0) return { x: 0, y: 0 };

    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

    elements.forEach(element => {
        const cx = parseFloat(element.getAttribute('cx'));
        const cy = parseFloat(element.getAttribute('cy'));

        if (cx < minX) minX = cx;
        if (cx > maxX) maxX = cx;
        if (cy < minY) minY = cy;
        if (cy > maxY) maxY = cy;
    });

    return {
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2
    };
}

// Tag and mouse move event listener
document.addEventListener("mousemove", (e) => {
    // Update Tags
    const tag = document.getElementById("tag");
    tag.style.left = `${e.x}px`;
    tag.style.top = `${e.y}px`;
    tag.style.transform = `translate(${(e.clientX / window.innerWidth)}%, ${(e.clientY / window.innerHeight)}%)`;

	if (mouseDown && mouseInContainer) {
        const svgElement = globalSvgContainer.querySelector('svg');
        if (svgElement != null) {
            // Calculate sensitivity based on SVG resolution and size
            const { scaleX, scaleY } = calculateSensitivity(svgElement);

            // Calculate mouse movement difference once
            const deltaX = (e.clientX - prevMouseX) * scaleX;
            const deltaY = (e.clientY - prevMouseY) * scaleY;

            // Update previous mouse position once
            prevMouseX = e.clientX;
            prevMouseY = e.clientY;

            // Move a single selected item
            if (tempSelected != null && !multiSelect && groupGlobal.length < 2) {
                console.log("Moving single item");
                moveElement(tempSelected, deltaX, deltaY);
            }
            // Move multiple selected items
            else if (multiSelect && groupGlobal.length > 0) {
                console.log('Moving all items');
                groupGlobal.forEach(item => moveElement(item, deltaX, deltaY));
            }

            console.log("Mouse Down + Move");


        }
    } else if (rightMouseDown && mouseInContainer) {
        const svgElement = globalSvgContainer.querySelector('svg');
        if (svgElement != null) {
            // Calculate sensitivity based on SVG resolution and size
            const { scaleX, scaleY } = calculateSensitivity(svgElement);

            // Calculate mouse movement difference
            const movementX = (e.clientX - prevMouseX) * scaleX;
            const movementY = (e.clientY - prevMouseY) * scaleY;
            
            // Use horizontal movement for scaling factor
            const scaleFactor = 1 + (movementX * 0.01); // Adjust sensitivity here

            // Update previous mouse position
            prevMouseX = e.clientX;
            prevMouseY = e.clientY;

            // Scale all selected items
            groupGlobal.forEach(item => scaleElement(item, scaleFactor, anchorPoint));

            console.log('Scaling all items');
        }
    }
	
});

	//Move SVG with CX and CY
	document.addEventListener("mousedown", (e) => {

		if (mouseInContainer && tempSelected != null) {
			if (e.button === 0) {
				// Left mouse button
				mouseDown = true;
			} else if (e.button === 2) {
				// Right mouse button
				rightMouseDown = true;
				prevMouseX = e.clientX;
				prevMouseY = e.clientY;
				// Calculate the anchor point for scaling
				anchorPoint = calculateBoundingBoxCenter(groupGlobal);
			}
		}
		
		//Checks if it's a primitive element, otherwise put in a null, 
		//If TempSelected is not cleared, it will get wrongfully selected and moved during MouseDown
		if (e.srcElement.parentNode.nodeName.toLowerCase() == "g") {
			tempSelected = e.srcElement;
			console.log("tempSelected")
			console.log(tempSelected)
		} else {
			tempSelected = null;
		}

		if (
			e.srcElement.parentNode.nodeName.toLowerCase() == "svg" ||
			e.srcElement.nodeName.toLowerCase() == "svg" ||
			e.srcElement.parentNode.nodeName.toLowerCase() == "g"
		) {
			console.log(e.srcElement.parentNode);
			// if (currentSelected != null) {
			// 	currentSelected.classList.add("hovered");
			// }
			document.getElementById("tag").style.display = "flex";
			document.getElementById("label").innerText = e.srcElement.id;
			currentSelected = e.srcElement;

			const groupName = e.srcElement;
			//Get Attributes
			if (!multiSelect) {
				groupGlobal = [];
				document.querySelectorAll(".svg-tool-selected").forEach((e) => {
					// console.log(e.classList)
					e.classList.remove("svg-tool-selected");
					// console.log(e.classList)
					e.style.fill = "";
				});
				groupGlobal.push(groupName);
			} else {
				if(!groupGlobal.includes(groupName)){
					groupGlobal.push(groupName);
				}
				
			}

			if (groupGlobal.length < 2) {
				if (groupGlobal[0].getAttribute("group-attribute") != "") {

					document.getElementById("group").value =
						groupGlobal[0].getAttribute("group-attribute");
				} else {
					document.getElementById("group").value = "";
				}

				if (groupGlobal[0].getAttribute("unit-attribute") != "") {
					document.getElementById("unit").value =
						groupGlobal[0].getAttribute("unit-attribute");
				} else {
					document.getElementById("unit").placeholder =
						"No Attribute";
					document.getElementById("unit").value = "";
				}
			} else {
				document.getElementById("group").placeholder = "-";
				document.getElementById("unit").placeholder = "-";
			}
			e.srcElement.classList.add("svg-tool-selected");

			// e.srcElement.style.fill = "#ff000055";
		} else {
			document.getElementById("tag").style.display = "none";
		}

		document.querySelectorAll(".selected").forEach((e) => {
			e.style.fill = "#ff0000";
		});
		
	});

	function moveElement(element, deltaX, deltaY) {
    if (element.getAttribute('cx') != null && element.getAttribute('cy') != null) {
        const currentCx = parseFloat(element.getAttribute('cx'));
        const currentCy = parseFloat(element.getAttribute('cy'));

        const newCx = currentCx + deltaX;
        const newCy = currentCy + deltaY;

        element.setAttribute('cx', newCx);
        element.setAttribute('cy', newCy);
    }
}

function scaleElement(element, scaleFactor, anchor) {
    if (element.getAttribute('cx') != null && element.getAttribute('cy') != null) {
        const currentCx = parseFloat(element.getAttribute('cx'));
        const currentCy = parseFloat(element.getAttribute('cy'));

        const newCx = anchor.x + (currentCx - anchor.x) * scaleFactor;
        const newCy = anchor.y + (currentCy - anchor.y) * scaleFactor;

        element.setAttribute('cx', newCx);
        element.setAttribute('cy', newCy);
    }
}

	document.addEventListener("mouseup", (e) => {
		mouseDown = false;
		rightMouseDown = false;
	})
	

	document.getElementById('add-point').addEventListener('click', (e) => {
		console.log('adding point')
		//console.log(document.getElementById('item-id').value)
		//console.log(document.getElementById('item-id').value.length)

		// const layers = globalSvgContainer.querySelector('svg').querySelectorAll('g')
		// Get all layers in the SVG
		svg = document.getElementById("svg");
		const layers = Array.from(svg.children);

		// Find the layer with the most circle elements
		let maxCircleCount = 0;
		let layerWithMostCircles = null;

		layers.forEach((layer) => {
		const circleCount = layer.querySelectorAll("circle").length;

		if (circleCount > maxCircleCount) {
			maxCircleCount = circleCount;
			layerWithMostCircles = layer;
		}
		});

		
		if(document.getElementById('item-id').value.length > 0){
			const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle')
			circle.setAttribute('cx', '30')
			circle.setAttribute('cy', '30')
			circle.setAttribute('r', '30')
			circle.setAttribute('id', document.getElementById('item-id').value)
			if(layerWithMostCircles){
				layerWithMostCircles.appendChild(circle)
				console.log(layerWithMostCircles)
			} else {
				try{
					if(globalSvgContainer.querySelector('svg').querySelector('g')){
						globalSvgContainer.querySelector('svg').querySelector('g').appendChild(circle)
					}
				} catch (e) {
					console.log(e)
					var svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
					svg.id = "svg"
					svg.setAttribute("width", "2048");
					svg.setAttribute("height", "2048");

					var imageElement = globalSvgContainer.querySelector('img'); // Adjust the selector as needed to target the correct image element

					// If the image element exists, move it into the <g> element
					if (imageElement) {
						// Create a new image element in the SVG namespace
						var svgImageElement = document.createElementNS("http://www.w3.org/2000/svg", "image");
						
						// Set the href attribute to the source of the existing image
						svgImageElement.setAttributeNS("http://www.w3.org/1999/xlink", "href", imageElement.src);
						
						// Set the position and size of the image within the SVG
						svgImageElement.setAttribute("x", "0");
						svgImageElement.setAttribute("y", "0");
						svgImageElement.setAttribute("width", "2048");
						svgImageElement.setAttribute("height", "2048");
						
						// Append the SVG image element to the <g> element
						svg.appendChild(svgImageElement);
						
						// Optionally, remove the original image element from the document
						imageElement.parentNode.removeChild(imageElement);
					}

					const gElement = document.createElementNS("http://www.w3.org/2000/svg", "g");
					gElement.appendChild(circle)
					svg.appendChild(gElement)
					globalSvgContainer.appendChild(svg)

				}
					
				
			}
			
		} else {
			alert('Please add a name for the point')
		}
		
	})

	function spawnCircle(id, cx, cy, data){

		const g = globalSvgContainer.querySelector('g')
		const circle = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "circle"
        );
		circle.setAttribute("id", id);
        circle.setAttribute("cx", cx);
        circle.setAttribute("cy", cy);
        circle.setAttribute("r", "30");
		data.forEach((e) => {
			circle.setAttribute(e.field, e.value)
		})
        g.appendChild(circle);

		return circle
	}

	const scaleBoundingBoxToFit = (svgElement) => {
        const circles = svgElement.querySelectorAll('circle');
        if (circles.length === 0) return;

        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

        circles.forEach(circle => {
            const cx = parseFloat(circle.getAttribute('cx'));
            const cy = parseFloat(circle.getAttribute('cy'));
            const r = parseFloat(circle.getAttribute('r'));

            if (cx - r < minX) minX = cx - r;
            if (cx + r > maxX) maxX = cx + r;
            if (cy - r < minY) minY = cy - r;
            if (cy + r > maxY) maxY = cy + r;
        });

        const bboxWidth = maxX - minX;
        const bboxHeight = maxY - minY;

        const viewBox = svgElement.viewBox.baseVal;
        const svgWidth = viewBox.width;
        const svgHeight = viewBox.height;

        const margin = 0.2; // 1/5 margin

        const maxAllowedWidth = svgWidth * (1 - margin);
        const maxAllowedHeight = svgHeight * (1 - margin);

        const widthScale = maxAllowedWidth / bboxWidth;
        const heightScale = maxAllowedHeight / bboxHeight;

        const scale = Math.min(widthScale, heightScale, 1); // Scale down if necessary

        // Calculate the offset to center the scaled bounding box
        const offsetX = (svgWidth - bboxWidth * scale) / 2 - minX * scale;
        const offsetY = (svgHeight - bboxHeight * scale) / 2 - minY * scale;

        // Apply scaling and translation to each circle
        circles.forEach(circle => {
            const cx = parseFloat(circle.getAttribute('cx'));
            const cy = parseFloat(circle.getAttribute('cy'));

            const newCx = cx * scale + offsetX;
            const newCy = cy * scale + offsetY;

            circle.setAttribute('cx', newCx.toFixed(4));
            circle.setAttribute('cy', newCy.toFixed(4));
            circle.setAttribute('r', 30);
        });
    };

	function handleFileChange(file) {
    flipped = false;
    var count = 0;
	globalFloors = []
	
	
	//Refresh show floors section
	const floorSection = document.getElementById("show-floors")
	floorSection.querySelectorAll('div').forEach((e) => {
		e.remove()
	})
	if(!floorSection.classList.contains("hidden")){
		floorSection.classList.add('hidden')
	}

	if(document.getElementById("showLabelsDiv")){
		document.getElementById("showLabelsDiv").remove()
	}
	

    const processSVG = (svgElement) => {
        const list = svgElement.querySelectorAll(`[id]`);
        document.getElementById("id-list").innerHTML = "";

        const processIdList = (idFormat) => {
            const regexLastUnderscore = /_(?=[^_]*$)/g;
            const regexLastDash = /-(?=[^-]*$)/g;
            const regexDashUnderscore = /\w+-\w+_\w+/;
            const regexText = /^[^-]*/;
            const regexGroupName = /^([A-Z]{2}\d{2}-\d{1,2})/;
            const regexUnitNumber = /(\d{1,3})\D*$/;

            const handleId = (currentId) => {
                const listItem = document.createElement("li");

                const regexResult =
                    idFormat === format.fullUnderscore
                        ? currentId.replaceAll("-", "_")
                        : !regexDashUnderscore.test(currentId)
                        ? currentId.replace(regexLastDash, "_")
                        : currentId;

                const selected = svgElement.getElementById(`${currentId}`);
                const groupMatched = selected.id.match(regexGroupName);
                const unitMatched = selected.id.match(regexUnitNumber);

                if (groupMatched) {
                    selected.setAttribute("group-attribute", groupMatched[1]);
                }

                if (unitMatched) {
                    selected.setAttribute("unit-attribute", unitMatched[1]);
                }

                selected.id = regexResult;
                listItem.innerHTML = regexResult;
                clusterId.push({
                    id: count,
                    clusterId: regexText.exec(regexResult)[0],
                    unitId: regexResult,
                });

                count++;
                listItem.style.listStyle = "none";
                listItem.style.padding = "0.5em 0em";
                document.getElementById("id-list").append(listItem);
            };

            list.forEach((i) => {
                const currentId = i.id;

                if (idFormat === format.underscore) {
                    handleId(currentId);
                } else if (idFormat === format.dash) {
                    handleId(
                        regexDashUnderscore.test(currentId)
                            ? currentId.replace(regexLastUnderscore, "-")
                            : currentId
                    );
                } else if (
                    idFormat === format.none ||
                    idFormat === format.fullUnderscore
                ) {
                    handleId(currentId);
                }
            });
        };

        processIdList(idFormat);

        // Append the SVG element to the div element
        const svgContainer = document.getElementById("svg-container");
        svgContainer.innerHTML = "";
        svgContainer.appendChild(svgElement);

        // Set type for export filename
        type =
            idFormat === format.underscore
                ? "underscore"
                : idFormat === format.dash
                ? "dash"
                : "";

        // Scale bounding box to fit within the SVG frame
        // scaleBoundingBoxToFit(svgElement);
    };



    if (file.type === "image/svg+xml") {
        const reader = new FileReader();
        reader.addEventListener("load", () => {
            const svgString = reader.result;
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgString, "image/svg+xml");
            const svgElement = svgDoc.documentElement;
            processSVG(svgElement);
        });
        reader.readAsText(file);
    } else if (
        file.type === "image/jpeg" || file.type === "image/png" || file.type === "image/webp") {

        fileNameGlobal = file.name;
        document.getElementById("export-file-name").value = fileNameGlobal;
        const reader = new FileReader();
        reader.onload = (event) => {
            const contents = event.target.result;
            const img = document.createElement("img");
            img.src = contents;
            img.style.maxHeight = "100%";
            img.style.maxWidth = "100%";
            const svgContainer = document.getElementById("svg-container");
            svgContainer.innerHTML = "";
            svgContainer.appendChild(img);
        };
        reader.readAsDataURL(file);
    } else if (file.type === "text/csv") {
		if(document.getElementById('svg-container').getElementsByTagName("p").length > 0){
			Array.from(document.getElementById('svg-container').getElementsByTagName("p")).forEach((e) => {
				e.remove()
			})
		}

        fileNameGlobal = file.name;

        document.getElementById("export-file-name").value = fileNameGlobal;
        const reader = new FileReader();
        reader.onload = (event) => {
            const contents = event.target.result;
            const lines = contents.trim().split("\n");

            // Check the number of columns and decide to transform
            const firstLineFields = lines[0].split(",");
            let transformedLines = lines;
			let scaleToFit = false
			//column > 3
            if (firstLineFields.length > 3) {
                // Transform the data if more than three columns
                transformedLines = lines.map((line) => {
                    const fields = line.split(",");
					
                    const [name, x, y, z] = fields;
					const cleanedName = `${name.split("_")[0]}~${name.split("_")[1]}`;
					scaleToFit = true
					
                    return `${cleanedName},${-y},${-x}`; // Swap x and y
                });

            }

            var gInstance = document.createElementNS("http://www.w3.org/2000/svg", "g");
			gInstance.setAttribute('id', "g-instance")
            const svgContainer = document.getElementById("svg-container");
			
            if (svgContainer.querySelector("svg")) { //If SVG already exists
                svgContainer
                    .querySelector("svg")
                    .querySelectorAll("g")
                    .forEach((g) => {
                        if (g.id !== "Reference") {
                            g.remove();
							console.log(g)
							console.log("^ removed")
                        }
                    });

				// gInstance = svgContainer.querySelector("svg").querySelector("g")

            } else {
				// Create new SVG if it's not present
                const newSVG = document.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "svg"
                );
                newSVG.style.width = "100%";
                newSVG.style.height = "100%";
                newSVG.setAttribute("viewBox", "0 0 4096 4096");
                newSVG.setAttribute(
                    "xmlns:xlink",
                    "http://www.w3.org/1999/xlink"
                );
                newSVG.appendChild(gInstance);
                svgContainer.appendChild(newSVG);

                if (svgContainer.querySelector("img")) {
                    const tempImage = svgContainer.querySelector("img");
                    const svgimg = document.createElementNS(
                        "http://www.w3.org/2000/svg",
                        "image"
                    );
                    svgimg.style.width = "100%";
                    svgimg.style.height = "100%";
                    svgimg.setAttributeNS(
                        "http://www.w3.org/1999/xlink",
                        "xlink:href",
                        tempImage.src
                    );
                    newSVG.append(svgimg);
                    tempImage.remove();
                }
            }

			svgContainer.querySelector("svg").appendChild(gInstance); //Add g into the svg

            for (let i = 0; i < transformedLines.length; i++) {
                const fields = transformedLines[i].split(",");

                if (Number(fields[1]) || Number(fields[2])) {
					const floor = fields[0].includes('~') ? fields[0].split("~")[0] : null
					const name = fields[0].includes('~') ? fields[0].split("~")[1] : fields[0]

					const data = []
					if(floor){
						// circle.setAttribute("data-floor", floor)
						const floorData = {field: "data-floor", value: floor}
						data.push(floorData)
						globalFloors.push({"floor" : floor, "circle": spawnCircle(name, Number(fields[2]).toFixed(4), Number(fields[1]).toFixed(4), data)})
					} else {
						console.log(spawnCircle(name, Number(fields[2]).toFixed(4), Number(fields[1]).toFixed(4), data))
					}
					

                } else {
                    console.error(
                        `${
                            fields[0] ? fields[0] : `(Nameless), Row ${i + 1}`
                        } does not contain any cx, cy data`
                    );
                }
            }

			//Add Toggle Label Checkbox
			const showLabelsDiv = document.createElement('div')
			showLabelsDiv.id = "showLabelsDiv"
			const showLabelsToggle = document.createElement('input')
			const showLabelsLabel = document.createElement('label')
			showLabelsLabel.textContent = "Toggle Labels"
			showLabelsLabel.setAttribute('for', 'showLabelsToggle')

			showLabelsToggle.type = 'checkbox'
			showLabelsToggle.style.padding = "0.5em"
			showLabelsToggle.style.height = "fit-content"
			showLabelsToggle.id = "showLabelsToggle"
			
			showLabelsDiv.appendChild(showLabelsToggle)
			showLabelsDiv.appendChild(showLabelsLabel)
			document.getElementById('editor-button-container').appendChild(showLabelsDiv)

			showLabelsToggle.addEventListener('change', (e) => {
				if(e.target.checked){
					spawnLabel(gInstance)
				} else {
					killLabels()
				}
			})

			//Floor section
			//Dynamically add Floors section
			var floorNumbers = []
			const labelDivInstance = document.getElementById('labelDiv')
			if(labelDivInstance){
				labelDivInstance.remove()
			}
			globalFloors.forEach((e) => {
				if(!floorNumbers.includes(e.floor)){
					floorNumbers.push(e.floor)
				}
			})

			console.log(floorNumbers)
			console.log(globalFloors)

			if(floorNumbers.length > 0){
				const floorSection = document.getElementById("show-floors")
				if(floorSection.classList.contains('hidden')){
					floorSection.classList.remove('hidden')
				}

				const checkboxesId = []

				floorNumbers.forEach((e) => {
					const div = document.createElement('div')
					const checkbox = document.createElement('input')
					const label = document.createElement('label')
					
					label.innerText = `Floor ${e}`
					label.htmlFor = `floor-${e}-checkbox`
					checkbox.type = 'checkbox'
					checkbox.checked = true
					checkbox.id = `floor-${e}-checkbox`

					checkboxesId.push(`floor-${e}-checkbox`)
					div.appendChild(checkbox)
					div.appendChild(label)

					checkbox.addEventListener('change', (e) => {
						const g = globalSvgContainer.querySelector('g')
						const selectedFloor = e.target.id.split("-")[1]
						if(!e.target.checked){
							globalFloors = globalFloors.filter(i => i.floor !== selectedFloor);

						const allCircles = g.querySelectorAll('circle')
						const filteredCircles = Array.from(allCircles).filter((e) => 
							e.getAttribute('data-floor').includes(selectedFloor)
						)
						filteredCircles.forEach((e) => {
							globalFloors.push({floor: e.getAttribute('data-floor'), circle: e})
						})
						g.querySelectorAll('circle').forEach((e) => {
							e.remove()
						})
						}


						checkboxesId.forEach((i) => {
							if(document.getElementById(i).checked){
								const floor = i.split("-")[1]
								console.log("Floor" + floor)
								
								const selectedFloorCircles = globalFloors.filter((e) => e.floor.includes(floor))
								selectedFloorCircles.forEach((e) => {
									g.appendChild(e.circle)
								})
								console.log(selectedFloorCircles)
							}

						})


					})

					floorSection.appendChild(div)
				})
				
			}

            // Scale bounding box to fit within the SVG frame
			if(scaleToFit){
				scaleBoundingBoxToFit(svgContainer.querySelector("svg"))
			}
            // scaleBoundingBoxToFit(svgContainer.querySelector("svg"));
        };
        reader.readAsText(file);
    }
}

	fileInput.addEventListener("change", () => {
		handleFileChange(fileInput.files[0]);
	});


	document.body.addEventListener("dragover", (e) => {
		event.preventDefault(); // Prevent the default behavior
		document.querySelector(".drag-drop-prompt").classList.add("appear")
	});

	document.body.addEventListener("drop", (e) => {
		e.preventDefault();
		console.log(e.dataTransfer.files[0])
		handleFileChange(e.dataTransfer.files[0]);
		document.querySelector(".drag-drop-prompt").classList.remove("appear")
	});

	//To check globally if is typing
	document.addEventListener('focusin', (event) => {
    if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
        typing = true;
        console.log('Input is active');
    }
});

	document.addEventListener('focusout', (event) => {
		if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
			typing = false;
			console.log('Input is not active');
		}
	});

	document.addEventListener("keydown", (e) => {
		console.log(e)
		if (e.key == "Escape") {
			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				e.classList.remove("svg-tool-selected");
				e.style.fill = "";
				groupGlobal = [];
				document.querySelectorAll("#group").value = "";
			});

			if(multiSelect){
				groupGlobal.forEach((e) => {
					e.classList.remove('svg-tool-selected')
					e.style.fill = ""
				})

				multiSelect = false
			}
		}

		if (e.key == "Shift") {
			multiSelect = true;
		}

		if (e.key == "Enter") {
			document.querySelector("#set-name").click();
		}

		if (e.key == "q") {
			document.querySelector("#set-unit").click();
		}

		if (e.key == "Delete") {
			document.querySelector("#delete-point").click();
		}

		if (event.key === "ArrowLeft") {
			if(!typing){
				rotateCircles(-45);
			}

		} else if (event.key === "ArrowRight") {
			if(!typing){
				rotateCircles(45);
			}
		}

		if(e.key == 'l'){
			console.log(e.key)
			if(document.getElementById("showLabelsToggle")){
				document.getElementById("showLabelsToggle").click()
			}
		}



		if (e.ctrlKey && e.key === 'a') {
        e.preventDefault(); // Prevent the default browser select all behavior

        const svgElement = globalSvgContainer.querySelector('svg');
        if (svgElement != null) {
            // Select all circles in the SVG
            groupGlobal = Array.from(svgElement.querySelectorAll('circle'));

			groupGlobal.forEach((e) => {
				e.classList.add('svg-tool-selected')
				e.style.fill = "#ff0000";
			})

            // Indicate multi-selection mode
            multiSelect = true;

            console.log('All circles selected:', groupGlobal);
        }
    }
		
		if (e.key == 'Delete') {
			document.querySelector("delete-point").click();
		}
	});

	function setUnit() {
		for (var i = 0; i < groupGlobal.length; i++) {
			console.log(i);
			groupGlobal[i].setAttribute("unit-attribute", pad(i+1));
		}

		document.querySelectorAll(".svg-tool-selected").forEach((e) => {
			if (document.querySelectorAll(".svg-tool-selected").length < 2) {
				e.setAttribute(
					"group-attribute",
					document.getElementById("group").value,
				);
				e.setAttribute(
					"unit-attribute",
					document.getElementById("unit").value,
				);
				if (
					e.hasAttribute("group-attribute") &&
					e.hasAttribute("unit-attribute")
				) {
					e.id =
						e.getAttribute("group-attribute") +
						"_" +
						e.getAttribute("unit-attribute");
				}
			} else {
				e.setAttribute(
					"group-attribute",
					document.getElementById("group").value,
				);
				e.id =
					e.getAttribute("group-attribute") +
					"_" +
					e.getAttribute("unit-attribute");
			}
		});
	}

	function rotateCircles(angle) {
    const svgElement = document.querySelector("#svg-container svg");
    const circles = svgElement.querySelectorAll("circle");

    if (circles.length === 0) return;

    let minX = Infinity,
        maxX = -Infinity,
        minY = Infinity,
        maxY = -Infinity;

    // Calculate bounding box
    circles.forEach((circle) => {
        const cx = parseFloat(circle.getAttribute("cx"));
        const cy = parseFloat(circle.getAttribute("cy"));
        const r = parseFloat(circle.getAttribute("r"));

        if (cx - r < minX) minX = cx - r;
        if (cx + r > maxX) maxX = cx + r;
        if (cy - r < minY) minY = cy - r;
        if (cy + r > maxY) maxY = cy + r;
    });

    const bboxCenterX = minX + (maxX - minX) / 2;
    const bboxCenterY = minY + (maxY - minY) / 2;

    const radians = (angle * Math.PI) / 180;

    // Rotate each circle around the bounding box center
    circles.forEach((circle) => {
        const cx = parseFloat(circle.getAttribute("cx"));
        const cy = parseFloat(circle.getAttribute("cy"));

        const dx = cx - bboxCenterX;
        const dy = cy - bboxCenterY;

        const newCx =
            bboxCenterX + dx * Math.cos(radians) - dy * Math.sin(radians);
        const newCy =
            bboxCenterY + dx * Math.sin(radians) + dy * Math.cos(radians);

        circle.setAttribute("cx", newCx.toFixed(4));
        circle.setAttribute("cy", newCy.toFixed(4));
    });
}

	//Add zero to single digit
	function pad(d) {
		return d < 10 ? "0" + d.toString() : d.toString();
	}

	document.addEventListener("keydown", (e) => {
		if (e.key == "Escape") {
			document.querySelectorAll(".svg-tool-selected").forEach((e) => {
				e.classList.remove("svg-tool-selected");
				e.style.fill = "";
				groupGlobal = [];
				document.querySelectorAll("#group").value = "";
			});
		}

		if (e.key == "Shift") {
			multiSelect = true;
		}
	});

	document.addEventListener("keyup", (e) => {
		if (e.key == "Shift") {
			multiSelect = false;
			console.log(multiSelect)
		}
	});

	document.getElementById("hide-toggle").addEventListener("click", (e) => {
		if (document.getElementById("id-list").style.display == "none") {
			document.getElementById("id-list").style.display = "block";
			document.getElementById("hide-toggle").classList.remove("expand");
		} else {
			document.getElementById("id-list").style.display = "none";
			document.getElementById("hide-toggle").classList.add("expand");
		}
	});

	// document.getElementById("export-csv").addEventListener("click", (e) => {
	// 	exportCSV();
	// });

	// document.getElementById("remove").addEventListener("click", (e) => {
	// 	removeData();
	// });

	// document
	// 	.getElementById("export-csv-count")
	// 	.addEventListener("click", (e) => {
	// 		exportCSVId();
	// 	});

	document.getElementById("export").addEventListener("click", (e) => {
		exportSVG();
	});

	document
		.getElementById("export-csv-layer")
		.addEventListener("click", (e) => {
			exportFloorNamePosition();
		});

	document
		.getElementById("export-csv-layer-2048")
		.addEventListener("click", (e) => {
			exportFloorNamePosition2048();
		});

	// CSV Conversion
	function exportCSV() {
		const file = fileNameGlobal;
		var data = clusterId;
		data.forEach((e) => {
			delete e.id;
		});
		if (clusterId.length > 0) {
			// We can create a header row by mapping the object keys
			var header = Object.keys(data[0])
				.map((key) => `"${key}"`)
				.join(",");

			var rows = data.map((obj) =>
				Object.values(obj)
					.map((val) => `"${val}"`)
					.join(","),
			);

			var csv = [header, ...rows].join("\n");
			var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);

			link.download = file.replace(/\.[^/.]+$/, "") + "_" + type + ".csv";
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
	}
	//SVG Conversion
	function exportSVG() {
		const file = fileNameGlobal;
		var svg = document.querySelector("#svg-container").querySelector("svg");
		document.querySelectorAll("[id]").forEach((e) => {
			const str = e.getAttribute("id");
			e.setAttribute("data-name", str.replace(/\s+/g, "_"));
		});
		document.querySelectorAll("[group-attribute]").forEach((e) => {
			e.removeAttribute("group-attribute");
		});
		document.querySelectorAll("[unit-attribute]").forEach((e) => {
			e.removeAttribute("unit-attribute");
		});
		if (svg) {
			var serializer = new XMLSerializer();
			var svgString = serializer.serializeToString(svg);
			var blob = new Blob([svgString], { type: "image/svg+xml" });
			var url = URL.createObjectURL(blob);
			var link = document.createElement("a");
			link.href = url;
			link.download = file.replace(/\.[^/.]+$/, "") + "_" + type + ".svg";
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		} else {
			alert("Import and SVG to start!");
		}
	}
	//SVG Conversion
	function exportFloorNamePosition() {
		// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
		if (document.querySelector("#svg-container").querySelector("svg")) {
			const parser = new DOMParser();
			var doc = null;
			doc = document.querySelector("#svg-container").querySelector("svg");

			const layers = Array.from(doc.querySelectorAll("g"))
				.map((layer, index) => {
					
					if(layer.getAttribute("id") != null || layer.getAttribute("id") != undefined ){
						if (layer.getAttribute("id").toLowerCase() != "reference") {
							console.log("Layer ID is found")
						const id = layer.getAttribute("id").replace("_", "");
						const children = Array.from(layer.children).map(
							(child) => {
								console.log(child);
								const childId = child.getAttribute("data-name")
									? decodeHtml(
											child.getAttribute("data-name"),
									  )
									: child.getAttribute("id");

								const x = child.getAttribute("cx");
								const y = child.getAttribute("cy");
								return { id: childId, x, y };
							},
						);
						console.log(id, children);
						return { id, children };
						}
					}  else {
							console.log("Layer ID is null")
							console.log(layer)
							const id = `item-${index}`
						const children = Array.from(layer.children).map(
							(child) => {
								console.log(child);
								const childId = child.getAttribute("data-name")
									? decodeHtml(
											child.getAttribute("data-name"),
									  )
									: child.getAttribute("id");

								const x = child.getAttribute("cx");
								const y = child.getAttribute("cy");
								return { id: childId, x, y };
							},
						);
						console.log(id, children);
						return { id, children };
						}
					
				})
				.filter((layer) => layer !== undefined);

			var csv;
			if (layers.length < 2) {
				if(flipYX){
					csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) => `${child.id},${child.y},${child.x}`,
						),
					)
					.join("\n");
				} else {
					csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) => `${child.id},${child.x},${child.y}`,
						),
					)
					.join("\n");
				}


			} else {
				if(flipYX){
					csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) =>
								`${layer.id} ${child.id},${child.y},${child.x}`,
						),
					)
					.join("\n");
				} else {
					csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) =>
								`${layer.id} ${child.id},${child.x},${child.y}`,
						),
					)
					.join("\n");
				}

			}

			const file = fileNameGlobal;
			var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);
			link.download =
				file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "");
			(".csv");
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
	}

	//SVG Conversion
	function exportFloorNamePosition2048() {
		// console.log(document.querySelector("#svg-container").querySelector("svg").childNodes.length)
		if (document.querySelector("#svg-container").querySelector("svg")) {
			const parser = new DOMParser();
			var doc = null;

			doc = document.querySelector("#svg-container").querySelector("svg");
			const height = doc.viewBox.baseVal.height;
			const width = doc.viewBox.baseVal.width;

			const layers = Array.from(doc.querySelectorAll("g"))
				.map((layer) => {
					if (layer.getAttribute("id").toLowerCase() != "reference") {
						const id = layer.getAttribute("id").replace("_", "");
						const children = Array.from(layer.children).map(
							(child) => {
								console.log(child);
								const childId = child.getAttribute("data-name")
									? decodeHtml(
											child.getAttribute("data-name"),
									  )
									: child.getAttribute("id");

								const x =
									(child.getAttribute("cx") / width) * 2048;
								const y =
									(child.getAttribute("cy") / height) * 2048;
								return { id: childId, x, y };
							},
						);
						console.log(id, children);
						return { id, children };
					}
				})
				.filter((layer) => layer !== undefined);

			var csv;
			if (layers.length < 2) {
				if(flipYX){
					csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) => `${child.id},${child.y},${child.x}`,
						),
					)
					.join("\n");
				} else {
					csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) => `${child.id},${child.x},${child.y}`,
						),
					)
					.join("\n");
				}


			} else {
				if(flipYX){
					csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) =>
								`${layer.id} ${child.id},${child.y},${child.x}`,
						),
					)
					.join("\n");
				} else {
					csv = layers
					.flatMap((layer) =>
						layer.children.map(
							(child) =>
								`${layer.id} ${child.id},${child.x},${child.y}`,
						),
					)
					.join("\n");
				}

			}

			console.log(csv);

			const file = fileNameGlobal;
			var blob = new Blob([csv], { type: "text/csv" });
			var link = document.createElement("a");
			link.href = URL.createObjectURL(blob);
			link.download =
				file.replace(/\.[^/.]+$/, "") + (flipped ? "-flipped" : "");
			(".csv");
			link.click();
		} else {
			alert("Import an SVG to start!");
		}
	}

	function decodeHtml(html) {
		var txt = document.createElement("textarea");
		txt.innerHTML = html;
		return txt.value;
	}

	document.getElementById("flip-x").addEventListener("click", (e) => {
		// var svg = document.querySelector("#svg-container").querySelector("svg");
		// svg.style.scale = "-1 1"
		flipped = !flipped;

		var doc = null;
		doc = document.querySelector("#svg-container").querySelector("svg");
		const width = doc.viewBox.baseVal.width;
		const layers = Array.from(doc.querySelectorAll("g")).map((layer) => {
			// if(layer.getAttribute("id").toLowerCase() != 'reference'){
			// const id = layer.getAttribute("id").replace('_', "");
			const children = Array.from(layer.children).map((child) => {
				if (child.tagName == "image") {
					// child.getAttribute("transform")
					// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
					if (!child.hasAttribute("flipped")) {
						child.setAttribute("flipped", "");
						child.style.transform =
							"scaleX(-1) translate(-100%, 0)";
					} else {
						child.removeAttribute("flipped");
						child.style.transform = "scaleX(1) translate(0, 0)";
					}

					console.log(child.style.scale);
				} else {
					const x = child.getAttribute("cx");
					child.setAttribute("cx", width - x);
				}
			});
			// }
		});
	});

	document.getElementById("flip-y").addEventListener("click", (e) => {
		// var svg = document.querySelector("#svg-container").querySelector("svg");
		// svg.style.scale = "-1 1"
		flipped = !flipped;

		var doc = null;
		doc = document.querySelector("#svg-container").querySelector("svg");
		const height = doc.viewBox.baseVal.height;
		const layers = Array.from(doc.querySelectorAll("g")).map((layer) => {
			// if(layer.getAttribute("id").toLowerCase() != 'reference'){
			// const id = layer.getAttribute("id").replace('_', "");
			const children = Array.from(layer.children).map((child) => {
				if (child.tagName == "image") {
					// child.getAttribute("transform")
					// child.style.transform = "translate(-100%, 0) scale(-1, 1)"
					if (!child.hasAttribute("flipped")) {
						child.setAttribute("flipped", "");
						child.style.transform =
							"scaleY(-1) translate(0, -100%)";
					} else {
						child.removeAttribute("flipped");
						child.style.transform = "scaleX(1) translate(0, 0)";
					}

					console.log(child.style.scale);
				} else {
					const y = child.getAttribute("cy");
					child.setAttribute("cy", height - y);
				}
			});
			// }
		});
	});

	function spawnLabel(group){
		var circles = [];
		console.log("Group")
		console.log(group)
		if(group.length > 1){

		} else if(group instanceof SVGGElement){
			circles = [].slice.call(group.getElementsByTagName('circle'))
		}
		console.log(circles)

		const svgContainer = document.getElementById("svg-container")
		const {scaleX, scaleY} = calculateSensitivity(globalSvgContainer.querySelector('svg'))
		const { width } = globalSvgContainer.querySelector('svg').getBoundingClientRect()
		const labelDiv = document.createElement('div');
		labelDiv.setAttribute('id', "labelDiv")
		labelDiv.style.width = '4096px';
		labelDiv.style.height = '4096px';
		labelDiv.style.position = 'absolute';
		labelDiv.style.transform = `scale(${1/scaleX})`;
		labelDiv.style.left = `-${2048 - (4096 / scaleY) / 2}px`
		labelDiv.style.top = `-${2048 - (4096 / scaleY )/ 2}px`

		circles.forEach((e) => {
			const div = document.createElement('div');
			div.style.position = 'absolute';
			div.style.left = `${e.getAttribute('cx')}px`;
			div.style.top = `${e.getAttribute('cy')}px`;
			div.style.transform = 'translateX(-50%) translateY(1%)';
			div.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
			div.style.border = '2px solid rgba(255, 255, 255, 0.1)';
			div.style.padding = '8px 16px';
			div.style.borderRadius = `0.75rem`;
			div.style.marginBottom = '0.25rem';
			div.style.pointerEvents = 'auto';
			div.style.zIndex = '10';
			div.style.backdropFilter = 'blur(10px)';
			div.style.cursor = 'pointer';
			div.style.width = 'auto';
			div.style.whiteSpace = 'nowrap';
			div.style.textAlign = 'center';
			div.style.fontSize = '2.25rem';
			div.onclick = killLabels
			div.setAttribute("data-name", e.id)

			// Create the first paragraph (normal state)
			const pNormal = document.createElement('p');
			pNormal.className = 'text-normal';
			pNormal.style.color = 'white';
			pNormal.style.margin = '0';
			div.onclick = killLabels
			pNormal.textContent = `${e.id.replace(/([A-Z0-9])/g, ' $1').trim()}`;

			// Create the second paragraph (hover state)
			const pHover = document.createElement('p');
			pHover.className = 'text-hover';
			pHover.style.color = 'white';
			pHover.style.display = 'none';
			pHover.style.margin = '0';
			div.onclick = killLabels
			pHover.textContent = `${e.id.replace(/([A-Z0-9])/g, ' $1').trim()}`;

			// Append paragraphs to the div
			div.appendChild(pNormal);
			div.appendChild(pHover);

			// Add mouseover event to show hover state
			div.addEventListener('mouseover', function() {
			this.style.borderColor = 'rgba(255, 255, 255, 1)';
			pNormal.style.display = 'none';
			pHover.style.display = 'block';
			});

			// Add mouseout event to revert to normal state
			div.addEventListener('mouseout', function() {
			this.style.borderColor = 'rgba(255, 255, 255, 0.1)';
			pNormal.style.display = 'block';
			pHover.style.display = 'none';
			});

			labelDiv.appendChild(div)
			svgContainer.appendChild(labelDiv)
		})

		console.log(labelDiv)
	}

	function killLabels() {
		if(document.getElementById('labelDiv')){
			document.getElementById('labelDiv').remove()
			console.log(document.getElementById('showLabelsToggle').checked)
			document.getElementById('showLabelsToggle').checked = false
		} else {
			console.log("labelDiv not found")
		}

	}

	function removeData() {
		const doc = document.querySelector("#svg-container");
		const xml = `<?xml version="1.0" encoding="UTF-8"?>`;
		const defs = doc.querySelector("defs");
		const maskParent = document.querySelector("defs");
		const maskChild = maskParent.children;
		const maskShape = Array.from(maskChild).map((e) => {
			const shape = e.children[0];
			if (shape) {
				if (shape.nodeName == "polygon" || shape.nodeName == "path") {
					const className = shape.classList[0];
					shape.classList.remove(className);
					return shape;
				}
			}
		});

		var kvPair = Object.assign(
			{},
			...Array.from(document.styleSheets[1].cssRules).map((e) => {
				// return e.selectorText
				// return e.style.clipPath
				if (e.style.clipPath) {
					var str = e.style.clipPath;
					var regex = /#([\w-]+)/; // \w matches any alphanumeric character
					var match = regex.exec(str); // exec returns an array of matches
					var id = "#" + match[1]; // the first capture group is the ID
					return { [e.selectorText.replace(/[-.]/g, "")]: id };
				}
			}),
		);

		// kvPair = kvPair.filter(element => {
		//     return element !== undefined;
		// })
		var classes = [
			"cls-8158",
			"cls-8167",
			"cls-8163",
			"cls-8166",
			"cls-8165",
		];
		console.log(kvPair);
		const classValues = document
			.getElementById("myClasses")
			.value.replace(/\s/g, "");
		if (classValues) {
			classes = classValues.split(",");
		}

		var units = [];
		if (classes) {
			classes.forEach((e) => {
				doc.querySelectorAll(`.${e}`).forEach((i) => {
					console.log(i);
					const parentClass = String(i.parentElement.classList[0]);
					const refId = kvPair[parentClass.replace(/[-.]/g, "")];
					console.log(parentClass);
					const refEl = doc
						.querySelector("defs")
						.querySelector(refId);
					var child;
					if (refEl) {
						console.log(refEl);
						child = refEl.children[0];
						child.classList.remove(child.classList[0]);
						child.classList.add(e);
						units.push(child);
						return child;
					}
				});
			});
		}

		console.log("units");
		console.log(units);

		const output = document.createElementNS(
			"http://www.w3.org/2000/svg",
			"g",
		);

		var svg = doc.querySelector("svg");
		console.log(svg);
		while (svg.firstChild) {
			svg.removeChild(svg.firstChild);
		}
		// // const parent = document.createElement("g");
		svg.append(defs);
		units.forEach((e) => {
			console.log(e);
			svg.append(e);
		});


	}



	function getStyleSheet(unique_title) {
		for (const sheet of document.styleSheets) {
			if (sheet.title === unique_title) {
				return sheet;
			}
		}
	}
</script>
